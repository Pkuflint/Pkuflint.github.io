<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>初晴 - 有诗意的天气，有温度的诗句</title>
      <link href="/2019/chu-qing/"/>
      <url>/2019/chu-qing/</url>
      
        <content type="html"><![CDATA[<p>最近完成了Flutter的入门课程，使得进行android开发成为了可能。我起初想把我原来的《爱跑》应用重写一遍，研究了几天发现没有适合的能够在后台运行的定位相关插件，所以暂时作罢。flutter在这方面确实还有一些不足，官方给的后台运行的相关指引文章，太过复杂和不切重点了。</p><p>接下来确定参考iOS端的《雨时》这款app做一个拷贝版本。一两年前最初学iOS时就想做这个，最后没有完成。现在使用Flutter用了一周时间完成了基础功能，命名为《初晴》。</p><p>这个应用就是调用了3个API来实现获取天气数据，获取随机诗词，获取随机一句话功能。界面如下。</p><img style="zoom:50%;" data-src="chuqing.jpg"><p>因为调用的都是免费API，所以不太好大面积传播。所以我只想传到google play商店和iOS付费版。但iOS审核被拒，应用太过简单，仅仅是聚合了网络内容。所以，作罢。</p><p>我上传到了百度云，有喜欢的可以直接下载使用。安卓下载地址如下：</p><blockquote><p>链接:<a href="https://pan.baidu.com/s/1VWPH_Orm0qsh7PMA4dNH6w" target="_blank" rel="noopener">https://pan.baidu.com/s/1VWPH_Orm0qsh7PMA4dNH6w</a>  密码:6rmc</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>零基础自学编程有多难</title>
      <link href="/2019/how-hard-is-self-taught-programming/"/>
      <url>/2019/how-hard-is-self-taught-programming/</url>
      
        <content type="html"><![CDATA[<p>一个零基础的文科生学编程有多难？为什么单把文科生拎出来，这里不是歧视文科生，只是想强调过往没有任何的编程和计算机基础这一点，而大多数理工科的毕业生多少都有一点基础。</p><p>我到现在都不能说自己是个程序员，但我自认为有足够曲折的编程自学经历来现身说法。</p><a id="more"></a><h2 id="第一难：学什么语言"><a href="#第一难：学什么语言" class="headerlink" title="第一难：学什么语言"></a>第一难：学什么语言</h2><p>6年前的春天，我买了第一本编程书，一本C语言的书，得有4厘米厚，京东畅销书。这可能是任何一个自学编程的人能做出的最差的选择。然而，我不知道是听信了谁的鬼话，也不记得为何没有进行网上搜索，也许那时还没养成搜索的习惯。</p><p>C语言公认的难学、难用，用途比较单一，大概只有毕业没多久理工科生的才会带着学校课程表的惯性给新手推荐先学C语言。</p><p>正确答案是：Java、Python、JavaScript，随便选一个吧。</p><h2 id="第二难：选择什么教程"><a href="#第二难：选择什么教程" class="headerlink" title="第二难：选择什么教程"></a>第二难：选择什么教程</h2><p>上面说我学编程的第一步是买书。这是我犯的第二个错误。书籍中的内容更新滞后，远远比不上现代的编程语言。书籍的内容偏重理论，而编程是一个注重实操的手艺。而且不是每个人都适合跟着书学习，视频的互动更强一些。书不会照顾一个新手，而视频课程的设计者会考虑新手的学习曲线，会把教学和练习相结合，会根据编程学习的特点强调实践。另外，编程书一般都非常厚，里面不是文字就是代码，真的让人望而却步，尤其是对于战战兢兢的新手来说。</p><p>正确的选择是：靠谱的视频课程，推荐Udemy这种大平台的热门课程。不要选大学课程，那也是偏理论的。</p><h2 id="第三难：如何面对报错"><a href="#第三难：如何面对报错" class="headerlink" title="第三难：如何面对报错"></a>第三难：如何面对报错</h2><p>我已记不清有多少次了，百度我的报错文本根本没有结果。为什么？因为没有人出过这个报错。只有我，只有纯新手，才会因为种种奇葩的原因，发现全新的报错。而根据我的经验，这个报错的原因一般是一个低级错误。</p><p>前两天，Xcode就无法预览某一个View。我有什么办法？没办法，我跳过了。</p><p>我觉得对于无关紧要的问题或者报错，一个核心态度就是打不过就跑，认怂。不要在上面浪费无谓的时间和精气。同理，对于那些一时不能理解和掌握的概念，留给时间，留给后面的学习。</p><h2 id="第四难：如何练习"><a href="#第四难：如何练习" class="headerlink" title="第四难：如何练习"></a>第四难：如何练习</h2><p>初学编程时，我以为练习就是要去<code>codewars</code>这样的网站完成一个个小任务，一个个代码片段，对基本的编程语法做练习。</p><p>但这样的练习做一万遍，还是徒劳。正确的做法是以项目为导向。练习一开始的目标就是完成一个项目。项目可大可小，但项目有明确的用途。在完成项目的过程中，你会学习从整体看问题，会学习试着解决任何一个出现的小问题。</p><p>正确的做法：从项目学习，用项目练习。</p><h2 id="第五难：如何坚持"><a href="#第五难：如何坚持" class="headerlink" title="第五难：如何坚持"></a>第五难：如何坚持</h2><p>对于新手来说，很多概念都是闻所未闻的。每一个闻所未闻的概念，都是似懂非懂的。就是这种似懂非懂的状态下，持续往下学习。累积的似懂非懂越多，就越心虚，越决定自己不行。</p><p>同时，越深入学习，越觉得编程中有太多的细枝末节需要考虑，太多的库需要学习，太多的弱点需要强化。胡适会说，进一寸就进一寸的欢喜。但霸王别姬里的小豆子，却哭着喊“这得挨多少打啊”。不是所有人都能面对重压。</p><p>对自己的怀疑，加上对编程学习本身的质疑，放弃真是一个诱人的选择。</p><p>这里的建议是，不要对自己太苛求。累了就休息，休息好了就继续。别有完美情结。</p><h2 id="第六难：学习编程为什么"><a href="#第六难：学习编程为什么" class="headerlink" title="第六难：学习编程为什么"></a>第六难：学习编程为什么</h2><p>千辛万苦学会了一门编程语言，做了一两个小项目。然后呢？转行基本没门。本职工作好像也不怎么用得上。那这个新学的手艺就撂这儿啦？只要3个月不写代码，再捡起来就又得重新复习那些本就基础不牢的语法。捡起来后也还是不知道能拿这个来干什么。</p><p>所以，如果你想能够持续地学下去，你得知道自己想用编程做什么。仅仅是喜欢？这是一个不错的答案。不管什么答案，都一定会有一个与之匹配的结局，种瓜得瓜种豆得豆而已。</p><p>祝你学有所得，学有所成。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 自学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>换电脑时如何正确地迁移Hexo博客</title>
      <link href="/2019/how-to-migrate-hexo-properly/"/>
      <url>/2019/how-to-migrate-hexo-properly/</url>
      
        <content type="html"><![CDATA[<p>一句话，不要保留旧电脑hexo博客文件夹中的<code>package.json</code>文件。百度搜到的迁移教程，整体步骤没错，就是这一条，非常有误导性，如果保留下来可能会导致奇怪的报错。</p><p>下面是我验证有效的迁移步骤。</p><a id="more"></a><h2 id="保存旧数据"><a href="#保存旧数据" class="headerlink" title="保存旧数据"></a>保存旧数据</h2><p>从旧电脑的博客目录中，拷贝保存以下文件或文件夹：</p><ol><li>站点配置文件<code>_config.yml</code></li><li><code>source</code>文件夹</li><li><code>scaffolds</code>文件夹，如果你没有改过这里，其实也不用保存</li><li><code>themes</code>文件夹视情况保存，如果你没改过，或者像我一样主题的自定义配置都写在了站点的<code>/source/_data</code>里面，这里也不用保存，到时重新下载。</li></ol><h2 id="安装必备模块"><a href="#安装必备模块" class="headerlink" title="安装必备模块"></a>安装必备模块</h2><ol><li>安装Git：官网下载安装包安装。</li><li>安装Node：官网下载安装包安装。</li><li>安装Hexo：命令行运行<code>npm install -g hexo-cli</code></li></ol><h2 id="初始化博客目录"><a href="#初始化博客目录" class="headerlink" title="初始化博客目录"></a>初始化博客目录</h2><ol><li>创建博客目录，然后cd到该文件夹</li><li>初始化博客目录：<code>hexo init</code>，必须是一个空文件夹。</li><li>安装deploy插件：<code>npm install hexo-deployer-git --save</code></li></ol><h2 id="替换旧数据"><a href="#替换旧数据" class="headerlink" title="替换旧数据"></a>替换旧数据</h2><p>这个直接替换同名文件和文件夹，覆盖即可。</p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>我迁移前没保留主题，这里需要重新下载我用的主题<code>next</code>。先cd到博客主目录，然后执行下面的命令。</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/theme-<span class="keyword">next</span>/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure><p>我的主题的自定义配置，是另外创建了一个名为<code>next.yml</code>的文件保存在站点目录<code>/source/_data</code>文件夹中（如果<code>_data</code>文件夹不存在，可以手动创建一个）。这样我可以直接升级主题，而不用担心配置冲突。</p><h2 id="按需安装插件"><a href="#按需安装插件" class="headerlink" title="按需安装插件"></a>按需安装插件</h2><ul><li>Local Search：<code>npm install generator-search --save</code></li><li>Rss生成：<code>npm install hexo-generator-feed --save</code></li><li>Sitemap生成：<code>hexo-generator-sitemap --save</code></li></ul><p>如果运气好，网速快，15分钟就可以搞定。如果你运气不好，像我一样，又被教程误导，那可能要浪费一个下午的宝贵时光。</p><p>祝你好运！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python正则表达式CheatSheet</title>
      <link href="/2019/python-regular-expression-cheatsheet/"/>
      <url>/2019/python-regular-expression-cheatsheet/</url>
      
        <content type="html"><![CDATA[<p>这里是正则表达式常用表示法与函数，以备查询。</p><a id="more"></a><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><h3 id="普通符号"><a href="#普通符号" class="headerlink" title="普通符号"></a>普通符号</h3><table><thead><tr><th>表示法</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>.</td><td>匹配任意字符，\n除外</td><td>b.b，表示以b开头以b结尾的任意字符串</td></tr><tr><td>\d</td><td>匹配0-9的数字字符</td><td>\d{3}，表示3个数字</td></tr><tr><td>\w</td><td>匹配任意字母数字下划线字符</td><td>\w+，至少一个字母数字下划线组合</td></tr><tr><td>\s</td><td>匹配任何空格，与[\n\t\r\v\f]相同</td><td>\s\s+，至少2个空格</td></tr><tr><td>[…]</td><td>匹配括号内字符集的任意单一字符</td><td>[aeiou]，匹配aeiou这5个字符中的一个</td></tr><tr><td>[x-y]</td><td>匹配x~y之间任意字符</td><td>[0-9]，匹配0-9这10个数字，同\d</td></tr><tr><td>\N</td><td>匹配已保存的子组，N是子组的序号</td><td>\2，表示已匹配的第2个子组</td></tr><tr><td>\c</td><td>c是一个特殊字符，匹配非转义的字符</td><td>\, \*</td></tr><tr><td>literal</td><td>表示字面值</td><td>输入什么，就匹配什么</td></tr><tr><td>\D</td><td>与\d相反，匹配非数字</td><td></td></tr><tr><td>\W</td><td>与\w相反，匹配非字母数字下划线</td><td></td></tr><tr><td>\S</td><td>与\s相反，匹配非空格</td><td></td></tr></tbody></table><h3 id="辅助符号"><a href="#辅助符号" class="headerlink" title="辅助符号"></a>辅助符号</h3><table><thead><tr><th>表示法</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>*</td><td>匹配0次或多次，默认贪婪</td><td></td></tr><tr><td>+</td><td>匹配1次或多次，默认贪婪</td><td></td></tr><tr><td>?</td><td>匹配0次或1次，默认贪婪</td><td></td></tr><tr><td>{N}</td><td>匹配N次</td><td></td></tr><tr><td>{M, N}</td><td>匹配M~N次，默认贪婪</td><td></td></tr><tr><td>?</td><td>在上述符号后面，加上?，转为非贪婪</td><td></td></tr><tr><td>&#124;</td><td>表示或，用在两个表达式之间</td><td></td></tr><tr><td>^（或者\A）</td><td>匹配字符串起始部分</td><td></td></tr><tr><td>$（或者\Z）</td><td>匹配字符串结束部分</td><td></td></tr><tr><td>[^…]</td><td>不匹配字符集内的字符</td><td></td></tr><tr><td>\b</td><td>表示在字符串边界，即开始或结尾</td><td>\bthe，表示以the开头字符串；\bthe\b，表示the</td></tr><tr><td>\B</td><td>与\b相反，表示不在边界</td><td>\Bthe，表示字符串不以the开头</td></tr></tbody></table><h3 id="扩展符号"><a href="#扩展符号" class="headerlink" title="扩展符号"></a>扩展符号</h3><table><thead><tr><th>表示法</th><th>描述</th></tr></thead><tbody><tr><td>?iLmsux</td><td>加入特殊标记</td></tr><tr><td>(?:…)</td><td>括号内的匹配不分组</td></tr><tr><td>(?=…)</td><td>匹配…出现在之后的位置</td></tr><tr><td>(?!…)</td><td>匹配…不出现在之后的位置</td></tr><tr><td>(?&lt;=…)</td><td>匹配…出现在之前的位置</td></tr><tr><td>(?&lt;!…)</td><td>匹配…不出现在之前的位置</td></tr><tr><td>(?(id/name)Y/N)</td><td>如果id或name对应的分组存在，则返回Y，否则返回N</td></tr><tr><td>(?P<name>…)</name></td><td>由name标识而不是数字id标识的分组匹配</td></tr><tr><td>(?P=name)</td><td>在同一个字符串中匹配由(?P<name>)分组的文本</name></td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>match(pattern, string, flags=0)</td><td>从字符串起始位置，匹配1次，起始必须匹配</td></tr><tr><td>search</td><td>从字符串左侧开始，匹配1次，起始不必匹配</td></tr><tr><td>findall</td><td>查找所有匹配，返回列表</td></tr><tr><td>finditer</td><td>查找所有匹配，返回迭代器</td></tr><tr><td>split(pattern, string, max=0)</td><td>返回根据pattern分割后字符串列表，默认分割max次</td></tr><tr><td>sub(pattern, repl, string, count=0)</td><td>替换所有匹配pattern并返回新字符串，默认替换无数次</td></tr><tr><td>groups</td><td>返回包括所有匹配子组的元组，若无匹配，则为空元组</td></tr><tr><td>group(num=0)</td><td>返回指定序号的子组，若编号为0，则返回整个匹配</td></tr></tbody></table><h3 id="常用模块属性"><a href="#常用模块属性" class="headerlink" title="常用模块属性"></a>常用模块属性</h3><table><thead><tr><th>模块属性</th><th>描述</th></tr></thead><tbody><tr><td>re.I, re.IGNORECASE</td><td>不区分大小写</td></tr><tr><td>re.L, re.LOCALE</td><td>根据使用的本地语言环境通过\w \W \b \B \s \S实现匹配</td></tr><tr><td>re.M, re.MULTILINE</td><td>^ $ 分别匹配目标字符串每行的起始和结尾</td></tr><tr><td>re.S, re.DOTALL</td><td>.点号可以匹配\n</td></tr><tr><td>re.X, re.VERBOSE</td><td>允许忽略字符串中换行符和注释段落，增强可读性</td></tr></tbody></table><h3 id="函数调用示例"><a href="#函数调用示例" class="headerlink" title="函数调用示例"></a>函数调用示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加(?i)使匹配忽略大小写</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r'(?i)yes'</span>, <span class="string">'yes? Yes. YES!'</span>)  </span><br><span class="line">[<span class="string">'yes'</span>, <span class="string">'Yes'</span>, <span class="string">'YES'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加(?im)表示匹配忽略大小写，^$从每行开始和结束匹配。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r'(?im)(^th[\w ]+)'</span>, <span class="string">""" </span></span><br><span class="line"><span class="string"><span class="meta">... </span>This line is the first,</span></span><br><span class="line"><span class="string"><span class="meta">... </span>another line,</span></span><br><span class="line"><span class="string"><span class="meta">... </span>that line, it's the best.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span>)</span><br><span class="line">[<span class="string">'This line is the first'</span>, <span class="string">'that line'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ?:使用表示不分组，?(1)表示判断分组1是否存在</span></span><br><span class="line"><span class="comment"># (?:(x)|y)，表示x或者y，但x是一个子组，整体却不是。即如果匹配到x，x是一个子组；匹配到y，y不是子组。</span></span><br><span class="line"><span class="comment"># (?(1)y|x)，表示匹配到的第一个子组如果存在，即x存在，那么下一个应该是y；若不存在，下一个则是x。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = <span class="string">r'(?:(x)|y)(?(1)y|x)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(re.search(pattern, <span class="string">'xy'</span>))</span><br><span class="line"><span class="meta">... </span><span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 正则表达式 </tag>
            
            <tag> cheatsheet </tag>
            
            <tag> regular expression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我为什么不玩魔兽世界怀旧服</title>
      <link href="/2019/say-no-to-wow-nostalgia-server/"/>
      <url>/2019/say-no-to-wow-nostalgia-server/</url>
      
        <content type="html"><![CDATA[<p>魔兽世界怀旧服开了，据说有的服务器排队时间高达5个小时。我兴味索然，虽然我从大二就开始玩魔兽世界，玩得疯的时候每天玩十个多小时，厌倦的时候又很久不上线。不管AFK多久，出了新版本总是想回来看看。</p><p>但怀旧服是个例外，我不想玩。</p><a id="more"></a><p>怀旧服几乎不提供任何新的游戏体验。它只是把原有的游戏体验变得更糟或者更好。怀旧服的练级体验，装备获取体验，两点之间的移动体验都比现在更糟。我丝毫不觉得用大量时间升级很有趣，不觉得费半天劲得一件蓝装很有趣，也不觉得一步一步从这个地图跑到另一个地图很有趣。尤其是当我见识过体验过更便捷的升级、更好的装备、更快的速度，我为什么要骗自己慢下来更好呢？而且我在普通服里练过十几个号，真心不想再重复那个过程：相同的地图、相同的任务、相同的副本。</p><p>即使我一时昏头，加入了怀旧服，接受怀旧服的新规则。我会花费时间跑路、升级、获取装备，然后呢？魔兽世界当年有句名言：满级才是游戏的开始。满级之后，我能玩的就是打副本、打战场、野外pvp。看到了吧，依然是旧的东西，依然是普通服里唾手可得的东西。</p><p>就算我能坚持下去，一直玩下去。但怀旧服版本就像任何的游戏一样，每个版本都有其生命周期。生命到了后期，人人都想要新东西，用户活跃大幅下滑。于是燃烧远征怀旧服开启，燃烧远征之后呢？</p><p>怀旧服从头到脚没有一丝新意，如果说有，也是在游戏营销上开创了炒冷饭的花样。怀旧服没有提供新的内容，却有比当前版本更差的游戏体验，最重要的是怀旧服最终将因为生命周期的规律不得不继续更新。一个持续更新的怀旧服，跟普通服还有区别吗？一定要眼睁睁地看着怀旧服更新到军团再临再能明白？</p><p>怀旧服，一个营销的花把式，一个低成本的试水之作，一个在游戏末期收割玩家的套路。</p><blockquote><p>客官，快来呀，只要75元就能回到那年夏天，回到大学校园，回到记忆中那绯红色的青春时代。</p></blockquote><p>啊，呸！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 魔兽世界 </tag>
            
            <tag> 怀旧服 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何用 Python 生成带 Logo 二维码</title>
      <link href="/2018/make-qr-with-logo-in-python/"/>
      <url>/2018/make-qr-with-logo-in-python/</url>
      
        <content type="html"><![CDATA[<p>如何用 Python 生成像微信名片那样的中间带有 Logo 的二维码？使用 Python 的qrcode模块可以很容易做到。</p><p>首先，import 所需的模块。完成工作，需要 <code>qrcode</code>和<code>PIL</code>模块。安装这些模块的方法可以自行百度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> qrcode</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFont, ImageDraw</span><br></pre></td></tr></table></figure><p>接着，生成二维码。二维码仅至少接收一个文本参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_qrcode</span><span class="params">(text)</span>:</span></span><br><span class="line">    qr = qrcode.QRCode(version=<span class="number">10</span>, </span><br><span class="line">    error_correction=qrcode.constants.ERROR_CORRECT_H,</span><br><span class="line">    box_size=<span class="number">8</span>,border=<span class="number">4</span>)</span><br><span class="line">    qr.add_data(text)</span><br><span class="line">    qr.make(fit=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> qr.make_image(fill_color=<span class="string">"black"</span>, back_color=<span class="string">"white"</span>)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>version，通俗来说，用于控制二维码的尺寸。version=1时，二维码包含21个块，其后 version 每增加1，二维码块数增加4。因此，version=10包含21+4*9=57个块。每个块的实际像素，由下面的参数 box_size 决定。</li><li>error_correction，即容错率，按照「草料二维码」的建议，应当选择30%，这个比例下最容易被各种设备识别，也就是常量<code>qrcode.constants.ERROR_CORRECT_H</code>。其他的常量还有：<ul><li>ERROR_CORRECT_L，大约7%容错；</li><li>ERROR_CORRECT_M，大约15%容错，默认值；</li><li>ERROR_CORRECT_Q，大约25%容错率。</li></ul></li><li>box_size，即每个块的占据的像素数，8就是8像素。</li><li>border，即二维码区域在边缘的留白，数字是块数，比如border=4即4块，也就是是4*8=32像素的留白，默认是4，建议最小值也是4，不过可以根据实际情况调整。</li><li>整体上，生成二维码实际大小这么算。（version 块数 + border 块数）* box_size，因此以上参数实际会生成（57 + 4）* 8 = 488像素大小的正方形。</li><li>最后 make_image 方法中的参数，可以根据实际需要调整，默认值就是白底黑色二维码。</li></ul><p>二维码生成了，下一步就是往二维码上添加 Logo。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将logo添加到二维码中间，logo的尺寸为二维码的1/4，且居中显示；</span></span><br><span class="line"><span class="comment"># 同时为了美观，logo与二维码中间会有适当留白。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_image_to_center</span><span class="params">(back_image, logo_image)</span>:</span></span><br><span class="line">    qrcode_size = back_image.size[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 创建一个qrcode大小的背景，用于解决黑色二维码粘贴彩色logo显示为黑白的问题。</span></span><br><span class="line">    qr_back = Image.new(<span class="string">'RGBA'</span>, back_image.size, <span class="string">'white'</span>)</span><br><span class="line">    qr_back.paste(back_image)</span><br><span class="line">    logo_background_size = int(qrcode_size / <span class="number">4</span>)</span><br><span class="line">    <span class="comment"># 创建一个尺寸为二维码1/4的白底logo背景</span></span><br><span class="line">    logo_background_image = Image.new(<span class="string">'RGBA'</span>, (logo_background_size, logo_background_size), <span class="string">'white'</span>)</span><br><span class="line">    <span class="comment"># logo与其白底背景设置背景尺寸1/20的留白</span></span><br><span class="line">    logo_offset = int(logo_background_size / <span class="number">20</span>)</span><br><span class="line">    logo_size = int(logo_background_size - logo_offset * <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 将 logo 缩放至适当尺寸</span></span><br><span class="line">    resized_logo = logo_image.resize((logo_size, logo_size))</span><br><span class="line">    <span class="comment"># 将logo添加到白色背景</span></span><br><span class="line">    logo_background_image.paste(resized_logo, box=(logo_offset, logo_offset))</span><br><span class="line">    <span class="comment"># 将白色背景添加到二维码图片</span></span><br><span class="line">    logo_background_offset = int((qrcode_size - logo_background_size) / <span class="number">2</span>)</span><br><span class="line">    qr_back.paste(logo_background_image, box=(logo_background_offset, logo_background_offset))</span><br><span class="line">    <span class="keyword">return</span> qr_back</span><br></pre></td></tr></table></figure><p>以上代码中，需要说明的是关于第5行的问题。我发现直接往白底黑色二维码上粘贴彩色 Logo 会造成 Logo 显示为黑白色颗粒的问题。网上一时找不到解决方案，就只好折衷一下，先创建一个与二维码底色一样的背景 image，然后把二维码以及 logo 都粘贴到这个背景上。只是一个曲线救国方案，如果谁有更好的方法，欢迎联系我。</p><p>最终，到了实际生成步骤了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text_for_qrcode = <span class="string">r'www.baidu.com'</span></span><br><span class="line">logo_image_file = <span class="string">r'avatar.jpg'</span></span><br><span class="line"><span class="keyword">with</span> Image.open(logo_image_file) <span class="keyword">as</span> logo_image:</span><br><span class="line">    qr_code = make_qrcode(text_for_qrcode)</span><br><span class="line">    qr_code_with_logo = add_image_to_center(qr_code, logo_image)</span><br><span class="line">    qr_code_with_logo.save(<span class="string">'qr.png'</span>)</span><br></pre></td></tr></table></figure><p>最终效果如下图所示：</p><p><img alt="qr" data-src="qr.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 二维码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>意义</title>
      <link href="/2018/meaning/"/>
      <url>/2018/meaning/</url>
      
        <content type="html"><![CDATA[<blockquote><p>意义，就是对特定对象的价值。</p></blockquote><p>当这个词语被用到的时候，一般都会忽略到「特定对象」。“要过有意义的人生”，“人生没有意义”，这种泛指的用法让人迷惑。有意义的人生，对谁或者对什么有意义呢？对自己本人，对家庭，对族群，对国家？对世界和平、自由平等？对耶稣佛陀？</p><p>厘清定义之后，意义不再令人困惑。没有意义，也不再令人恐惧。「我的人生」的意义，如果有，注定是为「第三方」提供价值。如果只是对我自己有价值，那这就是所有人的现状，自为的状态。因此，当提到「我的人生」的意义时，一定会指向第三方。</p><p>第三方的可能性是什么？</p><a id="more"></a><p>第一类，就是大词。自由平等博爱民主法治伟大高尚慈善智慧和平，他们的共同点就是足够抽象，这样的标的可以接受无限的价值提供，整个生命都会充满意义感。</p><p>第二类，宗教。宗教的本义就是无条件的相信。「我的人生」全部都可以献给我的唯一的神。</p><p>第三类，极致的专业。绘画、音乐、物理、数学等，这种艺术类和研究类的专业领域，有无止境的追求深度。</p><p>这些是足够贯穿一生接受意义注入的对象。还有一些，比如保护亚文化、保护某个弱势群体，我想可以归入到第一类中。</p><p>既然意义是身外之物，我们要来何用？</p><blockquote><p> 意义本身提供了人生持久的动力。</p></blockquote><p>对自由、对宗教、对音乐的追求，会让人持续地保持向上的状态。即使在低谷有迷茫的时候，也明确地知道自己的方向。</p><p>所以，意义对于个人来说还是有意义的。但没有意义的生活，也可以一样的精彩。因为，到最后，你还有对自己的意义。你的意义不依赖于外物，而在于你自己。</p><p>同时，我们也可以看到，选择一个有深度的专业领域，可以成为一个未来潜在的意义之源。</p><p>有时候的很多烦恼，都是来自于对个人现状的不满。比如，我处在一个自私自为的状态，烦恼于为什么我不是一个为国为民或者天地境界这种更高的层次。为什么天地境界就比自私自为更高级？</p><p>安心地做一个自私的人。安心地做一个不为外物提供意义的人。是啊，我对大词、宗教、专业都没有什么价值，那有怎样呢？我为什么要为这些事物提供价值呢？回答不出这个问题，我为什么要烦恼呢？我们本来就天然没有价值联系啊！</p><p>人生有没有天然的意义？有！你的父母盼望你的降生，国家想要一个劳动力，人类希望你传播基因…</p><p>但你没必要去回应这些意义。一个人不必刻意地去追求大词和宗教，期望他们给自己带来有意义的人生。反倒是可以选择一个有深度的专业，为自己谋得一个富足的人生，而且可能会提供持久的意义。有些事情不是靠个人选择，而是水到渠成。</p><p>「没有意义」没什么大不了，只要你知道它对你自己的意义。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 意义 </tag>
            
            <tag> 人生意义 </tag>
            
            <tag> 生命意义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《爱上跑步的13周》专属App软件</title>
      <link href="/2018/app-for-13-week-run-program/"/>
      <url>/2018/app-for-13-week-run-program/</url>
      
        <content type="html"><![CDATA[<p>《爱上跑步的13周》提供了完整的13周跑步训练计划。该计划核心在于循序渐进地提升运动量，在避免运动受伤的前提下，用13周让几乎任何体能状况的人完成自己的10公里跑。</p><p>心动不如行动。</p><p>但实际行动起来，却发现要完全跟随计划有点困难，因为这套训练计划的核心是跑步与走路相结合。我们需要知道什么时候该跑步，什么时候该走路。</p><p>《爱跑十三周》这个工具型app就是为此而生。</p><ul><li>下载地址：<a href="https://itunes.apple.com/cn/app/id1403686503" target="_blank" rel="noopener">https://itunes.apple.com/cn/app/id1403686503</a> </li><li>或苹果商店搜索「爱跑十三周」下载。</li></ul><p>《爱跑十三周》的主要功能如下：</p><a id="more"></a><h3 id="一、内置完整13周训练计划"><a href="#一、内置完整13周训练计划" class="headerlink" title="一、内置完整13周训练计划"></a>一、内置完整13周训练计划</h3><p>《爱跑十三周》100%还原《爱上跑步的13周》中制定的训练计划，包括中后期的「跑步多一些」和「走路多一些」选项，也都可以在《爱跑十三周》中进行设定。除了基础计划，还包括进阶的13周维持计划和13周快跑计划，完全还原原书计划。</p><img alt="program" style="zoom:70%;" data-src="program.jpg"><h3 id="二、后台语音提示，践行计划无压力"><a href="#二、后台语音提示，践行计划无压力" class="headerlink" title="二、后台语音提示，践行计划无压力"></a>二、后台语音提示，践行计划无压力</h3><p>根据训练计划，在跑步与走路需要切换时，会有语音提示。再也不用担心跟不上计划了。</p><p>同时，每满1公里，还会有语音提示。即使熄灭手机跑步，一样可以在切换跑步走路时进行语音提示。</p><h3 id="三、实时GPS数据，一目了然"><a href="#三、实时GPS数据，一目了然" class="headerlink" title="三、实时GPS数据，一目了然"></a>三、实时GPS数据，一目了然</h3><p>基于GPS，可以实时看到自己跑步的速度、距离、卡路里。跑完，还可以看到自己跑步的路线。</p><img alt="IMG_0008" style="zoom:50%;" data-src="IMG_0008.PNG"><h3 id="四、详细运动记录，方便回顾"><a href="#四、详细运动记录，方便回顾" class="headerlink" title="四、详细运动记录，方便回顾"></a>四、详细运动记录，方便回顾</h3><p>每次运动，这款专属《爱上跑步的13周》的工具软件都会记录详细的跑步数据以及跑步路线。</p><img alt="record" style="zoom:80%;" data-src="record.jpg"><h3 id="五、跑步提醒，规律运动"><a href="#五、跑步提醒，规律运动" class="headerlink" title="五、跑步提醒，规律运动"></a>五、跑步提醒，规律运动</h3><p>每隔2天，系统会提醒你该进行下一次训练了。就是这样。</p><blockquote><p>如果你想践行《爱上跑步的13周》跑步计划，这就是你最佳的工具软件App。</p></blockquote><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p>最后，再发一次下载地址，仅支持苹果手机哦！</p><ul><li>下载地址：<a href="https://itunes.apple.com/cn/app/id1403686503" target="_blank" rel="noopener">https://itunes.apple.com/cn/app/id1403686503</a> </li><li>或苹果商店搜索「爱跑十三周」下载。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爱上跑步的13周 </tag>
            
            <tag> 爱跑十三周 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的App审核简史</title>
      <link href="/2018/a-brief-history-of-app-review/"/>
      <url>/2018/a-brief-history-of-app-review/</url>
      
        <content type="html"><![CDATA[<p>两款应用终于过审了。记录下过程，以备参考。</p><p>先交代下两款应用的背景：<br>应用一：爱跑十三周，跑步应用，本地化为3种语言，没有开关隐藏、热更、第三方支付等常见违规问题；<br>应用二：魔板拼图，解密游戏应用，本地化为3种语言，没有开关隐藏、热更、第三方支付等常见违规问题。</p><a id="more"></a><h2 id="「爱跑十三周」审核来往记录"><a href="#「爱跑十三周」审核来往记录" class="headerlink" title="「爱跑十三周」审核来往记录"></a>「爱跑十三周」审核来往记录</h2><p>6月29日，首次提交审核；<br>6月30日，进入审核，元数据被拒；原因主要有两点：</p><ol><li>需要确认并声明遵守Guideline 2.1，因为这个类型的应用被认为可能会违反苹果审核规定。</li><li>苹果截图中不能包含价格或者免费字样。因为我的一张截图提到了免费字眼。</li></ol><p>6月30日，修改截图，并在待审核版本备注上声明遵守协议；重新提交审核。</p><p>7月3日，进入In Review状态。<br>7月17日，审核状态一直没变化。于是参考晚上的建议，将应用撤回，修改为1元付费应用，并重新提交审核。</p><p>7月20日，进入In Review状态。<br>7月21日，被拒绝，原因是：App在iPv6网络下点击某个菜单按键会闪退。我查看了他们附带的崩溃日志，没看到代码相关的报错。而且实际利用Mac创建iPv6网络测试，也没有问题。不过实际测试时，确实发现了因为没有及时移除KVO观察导致的崩溃，于是修复了这个Bug。但依然不确定，苹果审核人员的闪退是不是由这个Bug导致的。</p><p>7月23日，重新提交应用审核。<br>7月24日，进入In Review状态。<br>7月24日，元数据被拒，理由是：应用的中文名，包含了关键词或者描述语句。我的中文名是：爱跑 - 爱上跑步的13周。于是，我把中文名直接改成了爱跑十三周。并重新提交审核。</p><p>7月25日，再次进入In Review，并当天被拒，理由是：</p><ol><li>爱跑十三周，依然被认为是关键词或者描述语句，需要修改；</li><li>应用请求用户的位置但没有说明使用目的。</li></ol><p>我直接回复，爱跑十三周就是正式的app名字；同时截图给他看了我的本地化后的关于InfoPlist.string中与获取位置权限相关的描述。</p><p>7月26日，苹果回复说，中文名翻译以后是Love running for thirteen weeks，如果这是本意的话，则需要修改英文名字。当前的英文名是Into Run。<br>我回复说，在13周内爱上跑步就是本意。对于英文名来说，Into Run意思就是Love Running，英文名太长，不能完全照搬中文名的含义。同时举例微信和Wechat的例子来说明我的观点。最后，总结说这个名字是有效的。</p><p>7月26日下午，苹果回复说，中文名描述了在13周内跑步这个过程，但英文名却没有符合那个名字或过程。因此，要求修改名字，使之匹配。<br>我直接将英文名改为：Into Run: 13-week Run Program，然后回复说已经修改。</p><p>7月26日晚上将近12点左右，应用过审。</p><h2 id="「魔板拼图」审核来往记录"><a href="#「魔板拼图」审核来往记录" class="headerlink" title="「魔板拼图」审核来往记录"></a>「魔板拼图」审核来往记录</h2><p>7月21日，首次提交审核；提审后大约2个小时，返回错误：Invalid Binary。原因是我用了Xcode 10 Beta去编译生成的包。<br>于是，重新下载Xcode 9正式版，调整了app里的Swift4.2的方法，编译测试通过后，重新提交。</p><p>7月24日，重新提交并进入In Review状态；<br>7月24日，被拒，原因是：元数据包含误导或者故意欺骗用户的信息。我猜测大概是因为截图，因为我在中国区和其他语言使用了不同的截图，app内实际也是这样的设定。于是，回复说明了这个情况。<br>大约10分钟，他们就回复了，当时是上午9点21分。回复提到了另一个问题：说中文名可能存在利用另一个类似app的情况，要求改名字。<br>我当时立刻修改了名字。然后，我又重新提交了一次应用。</p><p>7月27日，凌晨2点左右，应用过审。</p><h2 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h2><ol><li>进入审核超过3天状态没有变化，可以撤掉重新提审，从记录来看，进入审核1-2天内就有结果；</li><li>主动声明绝无违反Guidline 2.1提到的那几个条款；</li><li>主动用iPv6测试App；</li><li>本地化的各个名字在实际含义上要匹配；</li><li>对于权限的请求，主动声明或者提供相关描述的截图；</li><li>应用名称中不要加各种看似关键词的东西；</li><li>不要使用Xcode的beta版本去打提审包；</li><li>对于不同地区使用不同截图的情况，可以主动说明情况；</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 审核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字华容道怎样才能有解</title>
      <link href="/2018/puzzle-random-algorithm/"/>
      <url>/2018/puzzle-random-algorithm/</url>
      
        <content type="html"><![CDATA[<p>数字华容道，是在4x4的格子中，依次从左到右，从上到下放置1-15这15个数字。经过一定的随机，必须将这15个数字复原。每个数字只能向相邻的唯一空格移动。难度更高的，格子和数字会更多，比如5x5。</p><p>我在开发一个类数字华容道游戏时，发现自己3x3的格子，居然怎么都解不出来。比如：一排1、2、3，二排4、5、6，三排8，7。经过网上查询，才知道完全随机位置的数值华容道仅有50%的概率是有解的。而我就是用的完全随机方式去打乱次序。</p><p>网上有两篇文章说的很好，以下是根据这两篇文章的总结。</p><h2 id="数字华容道必然有解的前提"><a href="#数字华容道必然有解的前提" class="headerlink" title="数字华容道必然有解的前提"></a>数字华容道必然有解的前提</h2><p>首先，要弄清楚一个概念：逆序数。逆序数，即一个数字序列，将其中所有数字依次两两对比，若大数在前，小数在后，那么这就是一对逆序数。这里说到的逆序数，指的是数字序列中逆序数的数量。比如：上文提到的1、2、3、4、5、6、8、7，逆序数只有1个，即8和7。</p><p>另外，还有一点要提出来。一般来讲，复原状态（初始状态）的数字华容道，会有一个空格，一般会设置在最末行的右下角。但也可以根据实际的需求，设置在其他行。请留意，初始空格所在的行数，是决定是否有解的一个重要因素。</p><p>数字华容道，必然有解，只存在于如下3个细分情形：</p><ol><li>若格子列数为奇数，则逆序数必须为偶数；</li><li>若格子列数为偶数，且逆序数为偶数，则当前空格所在行数与初始空格所在行数的差为偶数；</li><li>若格子列数为偶数，且逆序数为奇数，则当前空格所在行数与初始空格所在行数的差为奇数。</li></ol><p>实际的推演涉及到我一时难以彻底理解的数学推算，我只能用浅显的方式来理解这个问题。</p><a id="more"></a><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>首先，有解的前提在于：当前空格回到初始空格所在行数时，逆序数一定得是偶数！为什么，我不清楚。</p><p>要想把空格移动到初始空格所在行，必须进行若干次上下移动和若干次左右移动。</p><p>左右移动，不会改变逆序数；上下移动，若格子列数为奇数，则每次增减偶数个逆序数，若格子列数为偶数，则每次增减奇数个逆序数。</p><p>也就是说：</p><ol><li>格子列数为奇数，怎么移动，都不会改变原始的逆序数。因为奇数加减偶数还是奇数，偶数加减偶数还是偶数。所以，只要保证逆序数是偶数即可，不必关心空格的位置。</li><li>格子列数为偶数，那么进行奇数次上下移动，会改变其逆序数的奇偶性。所以，如果当前逆序数是偶数，要想有解，就要保证实际上下移动会进行偶数次，也就是说空格所在行与初始空格所在行的差为偶数。</li><li>同理，若当前逆序数是奇数，要想有解，要进行奇数次的移动，才能保证最终逆序数是偶数。</li></ol><h2 id="如何转换逆序数奇偶性"><a href="#如何转换逆序数奇偶性" class="headerlink" title="如何转换逆序数奇偶性"></a>如何转换逆序数奇偶性</h2><p>具体实现应该很简单，不多说了，就说一点。如果想更改一个数字序列的逆序数的奇偶性，只需要调换一对逆序数的位置即可。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>可能是CS106A课程上的一句话，并不是原文：</p><blockquote><p>程序员要在不理解内在实现逻辑的情况下，也能顺畅地使用别人的成果。</p></blockquote><p>不理解没关系，会用就行。</p><p>参考文档：</p><ul><li><a href="https://www.guokr.com/article/54088/" target="_blank" rel="noopener">https://www.guokr.com/article/54088/</a></li><li><a href="https://segmentfault.com/a/1190000013284274" target="_blank" rel="noopener">用React写一个数字华容道，你需要知道的秘密 - 地铁上的小前端 - SegmentFault 思否</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 华容道 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用类型 vs 数值类型</title>
      <link href="/2018/reference-type-and-value-type/"/>
      <url>/2018/reference-type-and-value-type/</url>
      
        <content type="html"><![CDATA[<p>引用类型，Reference Type，多个实例可以共享统一份数据。</p><p>数值类型，Value Type，一个实例独享一份数据。这里的数据指的是内存中位置，并不是指具体的数值。</p><p>如果要将一个引用类型的的实例，赋值给一个变量，那么变量仅仅是共享内存中的这份数据，变量获得的是对这份数据的引用；如果是将一个数值类型的实例赋值给一个变量，那么将会在内存中创建一份相同的数据，赋值给变量。</p><p>两者的核心在于：</p><ul><li>引用类型实例赋值给其他变量后，对变量的修改，原引用实例会一起被修改；</li><li>数值类型实例赋值给其他变量后，对变量的修改，不会影响原来的数值实例。</li></ul><p>平时在使用和选择时，务必要记得这一点，否则可能会像我一样用踩坑来获取知识。（PS，我也不好说踩坑一定不好，我踩了一天的坑，对这个问题才会印象深刻。）</p><a id="more"></a><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>一般的类，大多都是引用类型，自定义的类更是如此。</p><p>下面用代码说明下引用类型赋值后共享数据的情况：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstPerson = <span class="type">Person</span>(<span class="string">"Shen"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将引用类型的实例赋值给变量</span></span><br><span class="line"><span class="keyword">var</span> secondPerson = firstPerson</span><br><span class="line">secondPerson.name = <span class="string">"Mike"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是Mike，因为引用类型共享同一份数据</span></span><br><span class="line"><span class="built_in">print</span>(firstPerson.name)</span><br></pre></td></tr></table></figure><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>在Swift里，基本数据类型，都是数值类型，比如：<code>Int</code>、<code>Bool</code>、<code>Double</code>等。</p><p>另外，<code>String</code>、<code>Array</code>、<code>Dictionary</code>这些基础的类也是数值类型。</p><p>最后，<code>struct</code>、<code>enum</code>、<code>tuple</code>这些也都是数值类型。</p><p>下面用代码说明下，数据类型赋值后，独享数据互不干涉的情况：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuperPerson</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstSuper = <span class="type">SuperPerson</span>(name: <span class="string">"Clark"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> secondSuper = firstSuper</span><br><span class="line">secondSuper.name = <span class="string">"Bruce"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是Clark，因为Struct是数值类型，赋值给其他变量时，是直接复制给其他变量的。</span></span><br><span class="line"><span class="built_in">print</span>(firstSuper.name)</span><br></pre></td></tr></table></figure><h2 id="特殊情形：Array里的引用类型"><a href="#特殊情形：Array里的引用类型" class="headerlink" title="特殊情形：Array里的引用类型"></a>特殊情形：Array里的引用类型</h2><p>Array是数值类型，就是说，将一个Array赋值给另一个变量时，变量持有的是不同的Array，在内存中的数据是不同的。比如下面的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstPerson = <span class="type">Person</span>(<span class="string">"Huo"</span>)</span><br><span class="line"><span class="keyword">let</span> secondPerson = <span class="type">Person</span>(<span class="string">"Shi"</span>)</span><br><span class="line"><span class="keyword">let</span> persons = [firstPerson, secondPerson]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值类型的Array赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> newPersons = persons</span><br><span class="line"><span class="comment">// 修改变量</span></span><br><span class="line">newPersons[<span class="number">0</span>] = <span class="type">Person</span>(<span class="string">"Mike"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是Huo，即newPersons和persons其实是两个不同的对象。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(persons[0].name)"</span>)</span><br></pre></td></tr></table></figure><p>对于一般的赋值，比如上面的<code>var newPersons = persons</code>，因为<code>persons</code>里面的元素本身是引用类型，而且这种默认执行的是<strong>浅复制</strong>，所以在新的<code>newPersons</code>中包含的并不是拥有全新数据的元素，而仅仅是分享<code>persons</code>中所包含的元素的内存数据而已，就像上面讨论的引用类型一样。请参考下面的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取newPersons中的第2个元素，并修改元素的name属性</span></span><br><span class="line"><span class="keyword">let</span> second = newPersons[<span class="number">1</span>]</span><br><span class="line">second.name = <span class="string">"Jim"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果也是Jim，即虽然newPersons和persons是不同的数组。</span></span><br><span class="line"><span class="comment">// 但由于其生成方式是直接赋值，两个数组里其实是相同的元素。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(persons[1].name)"</span>)</span><br></pre></td></tr></table></figure><p>如果你在赋值时，关心里面的元素且需要对元素进行独立修改，那么就需要使用<strong>深复制</strong>，或者将元素替换为数值类型。</p><p>以下是对上面<code>Person</code>类的深复制代码实例：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义一个深复制方法，其实就是重新创建一个实例，并且对其属性赋予相同的数值。</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">()</span></span> -&gt; <span class="type">Person</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> person = <span class="type">Person</span>(name)</span><br><span class="line">        <span class="keyword">return</span> person</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对每个元素进行深复制然后加入新的Array</span></span><br><span class="line"><span class="keyword">var</span> newerPersons = persons.<span class="built_in">map</span> &#123; $<span class="number">0</span>.copy() &#125;</span><br><span class="line"><span class="keyword">let</span> secondP = newerPersons[<span class="number">1</span>]</span><br><span class="line">secondP.name = <span class="string">"Jim"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果不是Jim</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(persons[1].name)"</span>)</span><br></pre></td></tr></table></figure><h2 id="使用数据类型时的注意事项"><a href="#使用数据类型时的注意事项" class="headerlink" title="使用数据类型时的注意事项"></a>使用数据类型时的注意事项</h2><p>务必记得，要修改数据变量，必须直接对其进行修改，而不能像对普通类的对象一样，先进行一次临时变量赋值，再对变量进行修改。</p><p>最后：</p><blockquote><ul><li>引用类型实例赋值给其他变量后，对变量的修改，原引用实例会一起被修改；</li><li>数值类型实例赋值给其他变量后，对变量的修改，不会影响原来的数值实例。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 引用类型 </tag>
            
            <tag> 数值类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS工程的本地化-Swift</title>
      <link href="/2018/localization-of-ios-project/"/>
      <url>/2018/localization-of-ios-project/</url>
      
        <content type="html"><![CDATA[<p>应用如果需要根据设备语言显示不同的语言，就需要进行本地化的工作。就iOS工程而言，需要本地化的内容主要有：文字、图片、语音。一般而言，图片和语言的本地化，都可以转化为实质上的字符串的本地化。</p><ul><li>info.plist本地化</li><li>代码字符串本地化</li><li>storyboard, xib文件本地化</li><li>launchScreen.storyboard本地化</li><li>图片本地化</li><li>一次性导出本地化文件</li><li>新增内容的本地化</li><li>多人协作下使用自定义Localizable.strings文件</li></ul><a id="more"></a><h2 id="本地化的前置配置"><a href="#本地化的前置配置" class="headerlink" title="本地化的前置配置"></a>本地化的前置配置</h2><p>要进行任何本地化之前，需要先配置本地化语言。前往Project - Info - Localizations，添加本地化的目标语言。</p><h2 id="Info-Plist本地化"><a href="#Info-Plist本地化" class="headerlink" title="Info.Plist本地化"></a>Info.Plist本地化</h2><p><code>Info.plist</code>文件中，有：应用显示名称，还有系统权限文字说明，比如：请求位置或者拍照时弹出系统提示，我们需要在那里显示请求权限的用途。这部分的文字，都在<code>info.plist</code>中。</p><h3 id="创建文件InfoPlist-strings"><a href="#创建文件InfoPlist-strings" class="headerlink" title="创建文件InfoPlist.strings"></a>创建文件InfoPlist.strings</h3><p>我们可以直接创建名为<code>InfoPlist.strings</code>的文件。文件名不能自定义。</p><h3 id="勾选本地化语言"><a href="#勾选本地化语言" class="headerlink" title="勾选本地化语言"></a>勾选本地化语言</h3><p>创建后，选中文件，在Xcode右侧边栏<code>File Inspector</code>中可以找到<code>Localization</code>勾选项。勾选一个语言，就会自动生成一个对应那个语言的<code>InfoPlist.strings</code>文件。</p><h3 id="添加要修改键值对"><a href="#添加要修改键值对" class="headerlink" title="添加要修改键值对"></a>添加要修改键值对</h3><p>在<code>InfoPlist.strings</code>文件中，我们可以直接像这样一样，去手动输入键和对应的本地化文本，最后用分号标识：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Bundle display name */</span></span><br><span class="line"><span class="string">"CFBundleDisplayName"</span> = <span class="string">"爱跑十三周"</span>;</span><br></pre></td></tr></table></figure><p>前提是你得知道要修改的文本对应的键是什么，比如`”CFBundleDisplayName”是应用的显示名称。</p><p>如果想知道键是什么，可以选中<code>info.plist</code>，右键选择<code>Open As - Source Code</code>。在那里可以到真实的键名。</p><h2 id="代码字符串的本地化"><a href="#代码字符串的本地化" class="headerlink" title="代码字符串的本地化"></a>代码字符串的本地化</h2><h3 id="代码中调用NSLocalizedString"><a href="#代码中调用NSLocalizedString" class="headerlink" title="代码中调用NSLocalizedString"></a>代码中调用NSLocalizedString</h3><p>要本地化代码字符串，在使用字符串时，不能直接用具体明文的<code>String</code>，而要把需要本地化显示的字符串写成<code>NSLolalizedString(string: String, comment: String)</code>。方法里第一个参数，可以理解为本地化的键，这个值应该是唯一的，是本地化字符串的唯一标识。comment，是字符串的注释，方便你进行后续的翻译。</p><p>比如：<code>label. text = NSLocalizedString(&quot;屏幕尺寸&quot;, comment: &quot;屏幕尺寸label的标题&quot;)</code></p><h3 id="创建文件Localizable-Strings"><a href="#创建文件Localizable-Strings" class="headerlink" title="创建文件Localizable.Strings"></a>创建文件Localizable.Strings</h3><p>创建名为<code>Localizable</code>的<code>strings</code>文件，名称不能自定义。</p><h3 id="勾选本地化语言-1"><a href="#勾选本地化语言-1" class="headerlink" title="勾选本地化语言"></a>勾选本地化语言</h3><p>创建后，选中文件，在Xcode右侧边栏<code>File Inspector</code>中可以找到<code>Localization</code>勾选项。勾选一个语言，就会自动生成一个对应那个语言的<code>Localizable.strings</code>文件。</p><h3 id="添加要修改的本地化键值对"><a href="#添加要修改的本地化键值对" class="headerlink" title="添加要修改的本地化键值对"></a>添加要修改的本地化键值对</h3><p>添加如下代码进入<code>Localizable.strings</code>。<strong>请注意添加代码末尾的分号</strong></p><p>简体中文的<code>Localizable.strings</code></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 屏幕尺寸label的标题 */</span></span><br><span class="line"><span class="string">"屏幕尺寸"</span> = <span class="string">"屏幕尺寸"</span>;</span><br></pre></td></tr></table></figure><p>繁体中文的<code>Localizable.strings</code></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 屏幕尺寸label的标题 */</span> </span><br><span class="line"><span class="string">"屏幕尺寸"</span> = <span class="string">"熒幕尺寸"</span>;</span><br></pre></td></tr></table></figure><p>英文的<code>Localizable.strings</code></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 屏幕尺寸label的标题 */</span>  </span><br><span class="line"><span class="string">"屏幕尺寸"</span> = <span class="string">"Screen Size"</span>;</span><br></pre></td></tr></table></figure><p>这样那一处的字符串就完成了本地化。再对其他需要本地化的字符串做相同的处理即可。</p><h2 id="storyboard和xib的本地化"><a href="#storyboard和xib的本地化" class="headerlink" title="storyboard和xib的本地化"></a>storyboard和xib的本地化</h2><p>有时我们创建的storyboard和xib上也有字符串需要本地化。要做也非常简单。</p><h3 id="勾选本地化语言-2"><a href="#勾选本地化语言-2" class="headerlink" title="勾选本地化语言"></a>勾选本地化语言</h3><p>选中storyboard或者xib，在File Inspector中勾选Localization中需要本地化的语言。勾选后，就会在原来的文件下面生成本地化的strings文件，文件名是storyboard或者xib的名称。</p><h3 id="进入strings文件修改"><a href="#进入strings文件修改" class="headerlink" title="进入strings文件修改"></a>进入strings文件修改</h3><p>进入自动生成的strings文件，可以看到里面把带有字符串的按钮都列出来了。我们可以直接去修改对应的数值即可。</p><h2 id="LaunchScreen-storyboard的本地化"><a href="#LaunchScreen-storyboard的本地化" class="headerlink" title="LaunchScreen.storyboard的本地化"></a>LaunchScreen.storyboard的本地化</h2><p>上面本地化storboard的方法并不适用于<code>LaunchScreen.storyboard</code>。但要本地化也有办法。</p><h3 id="手动创建多个storyboard"><a href="#手动创建多个storyboard" class="headerlink" title="手动创建多个storyboard"></a>手动创建多个storyboard</h3><p>手动创建多个针对不同语言的storyboard，设置其样式和外观。</p><h3 id="添加InfoPlist-strings键值对"><a href="#添加InfoPlist-strings键值对" class="headerlink" title="添加InfoPlist.strings键值对"></a>添加InfoPlist.strings键值对</h3><p>在上文提到的InfoPlist.strings中加入如下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* LauchScreen storyboard for the language */</span></span><br><span class="line"><span class="string">"UILaunchStoryboardName"</span> = <span class="string">"LaunchScreenSC"</span>;</span><br></pre></td></tr></table></figure><p>为不同语言的InfoPlist.strings指定不同的用于启动的storyboard名称。</p><h2 id="图片的本地化"><a href="#图片的本地化" class="headerlink" title="图片的本地化"></a>图片的本地化</h2><h3 id="使用本地化的图片名称"><a href="#使用本地化的图片名称" class="headerlink" title="使用本地化的图片名称"></a>使用本地化的图片名称</h3><p>图片的调用一般是用图片名称，也就是字符串，因此图片本地化可以转化为字符串本地化问题。</p><h3 id="对图片资源设置本地化语言"><a href="#对图片资源设置本地化语言" class="headerlink" title="对图片资源设置本地化语言"></a>对图片资源设置本地化语言</h3><p>像对xib那样在File Inspector中配置本地化语言，这样就会在不同的本地化文件夹中出现同名的图片。根据需要替换即可。</p><h2 id="一次性导出本地化文件"><a href="#一次性导出本地化文件" class="headerlink" title="一次性导出本地化文件"></a>一次性导出本地化文件</h2><p>上面的这些方法都没问题，但如果要修改的文字很多，如果翻译需要多人去做，这样就很低效。Xcode提供了一个工具，可以导出所有本地化字符串。</p><h3 id="确认已配置本地化语言"><a href="#确认已配置本地化语言" class="headerlink" title="确认已配置本地化语言"></a>确认已配置本地化语言</h3><ol><li>将需要本地化的storyboard和xib勾选本地化语言</li><li>在代码里添加需要本地化的NSLocalizedString</li></ol><h3 id="导出xliff文件"><a href="#导出xliff文件" class="headerlink" title="导出xliff文件"></a>导出xliff文件</h3><p>选中<code>Target</code>，点击顶部<code>Editor</code>，然后点击<code>Export For Localization</code>。选择要导出的语言，即可导出<code>xliff</code>文件。</p><h3 id="导入xliff文件"><a href="#导入xliff文件" class="headerlink" title="导入xliff文件"></a>导入xliff文件</h3><p>将xliff文件发给本地化小组完成本地化后，可以直接在<code>Editor</code> - <code>Import Localization</code>导入<code>xliff</code>文件。</p><h2 id="新增内容的本地化"><a href="#新增内容的本地化" class="headerlink" title="新增内容的本地化"></a>新增内容的本地化</h2><p>应用出了新版本，又有了新的需要本地化的内容。这时，只需要重新导出<code>xliff</code>文件。原有的本地化内容在导出时会被保留，只需要对新的内容本地化。完成后，重新导入，即可。</p><h2 id="从指定自定义strings文件加载本地化字符串"><a href="#从指定自定义strings文件加载本地化字符串" class="headerlink" title="从指定自定义strings文件加载本地化字符串"></a>从指定自定义strings文件加载本地化字符串</h2><p>如果多人需要操作字符串，那么可以自己创建一个专属于自己的strings字符串，不使用默认的Localizable.strings。比如，你创建了名为<code>MyLocalizable.strings</code>的文件。那么你在调用本地化字符串时，就应该这样写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="type">NSLocalziableString</span>(<span class="string">"屏幕尺寸"</span>, tableName: <span class="string">"MyLocalizable"</span>, comment: <span class="string">"屏幕尺寸"</span>))</span><br></pre></td></tr></table></figure><p>即在参数中加入<code>tableName</code>，指定从哪个文件加载。</p><p>参考文档：</p><ul><li><a href="https://www.jianshu.com/p/88c1b65e3ddb" target="_blank" rel="noopener">https://www.jianshu.com/p/88c1b65e3ddb</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Loalization </tag>
            
            <tag> 本地化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I made an app</title>
      <link href="/2018/i-made-an-app/"/>
      <url>/2018/i-made-an-app/</url>
      
        <content type="html"><![CDATA[<p>我的第一个App终于提审了。</p><p>从2015年开始，我就念叨着要做一个App；而2016和2017年的年度目标之一就是上架一个App。但直到现在，2018年，我才真正完成我的第一款App。</p><p>我看了下代码文档的创建时间最早是在4月23日，也就是说我用了2个月时间完成了一款简单的跑步App。这2个月一开始也是松松垮垮，直到最后几天才通宵达旦地冲着目标冲刺。</p><p>有时候，我会想，我是真的喜欢编程么？是的话，为何这几年都没有实质的进展；而不是的话，为何这几年都心心念念？理性地讲，如果时间回到我刚毕业那会，我可能会选择编程，毫无疑问。但现在，调转航道的成本和风险不能不让我三思。</p><p>不管怎样，至少这是一个里程碑。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> App </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>仿照微信WebView实现ProgressBar</title>
      <link href="/2018/progress-bar-like-wechat-webview/"/>
      <url>/2018/progress-bar-like-wechat-webview/</url>
      
        <content type="html"><![CDATA[<h2 id="两种进度条逻辑"><a href="#两种进度条逻辑" class="headerlink" title="两种进度条逻辑"></a>两种进度条逻辑</h2><p>在网页中，一般我们会用顶部进度条来表示当前网页加载的进度。这里最常见的就是像Safari或Chrome浏览器那样的，用真实的进度百分比来更新进度条。当网速较慢时，进度条几乎完全不动；当网速较快时，进度条则会从大约20%位置嗖一下快速变为100%。</p><p>还有一种，就是微信App里的网页加载进度条。这里的进度条反映的不是真实的加载进度，其设计初衷应该就是让网页加载『看起来』更快。经过观察，大约是这样的一个逻辑：</p><blockquote><p>打开网页，进度条就进到10%；</p><p>再用3秒钟，进度条从10%走到60%；</p><p>再用4秒钟，进度条从60%走到80%；</p><p>再用8秒钟，进度条从80%走到90%；</p><p>从90%位置开始，进度条开始反应真实的加载进度。若此时网络连接极差，那么将会在90%卡住很久。</p><p>在以上的15秒内，若真实进度超过90%，则直接切换到真实进度，所以2秒打开的网页，也只会用2秒，不会固定加载15秒。</p></blockquote><p>从用户提交角度，可以对比不同网速下打开网页时进度条的表现：</p><ul><li>网速快，那么微信用3秒就进到60%，然后第4秒刷一下到100%；而Safari则是慢慢地移动到30%左右，然后刷的进到100%。</li><li>网速慢，那么微信用15秒加载了90%，只差最后10%加载不出；而Safari则一直处于不足10%的加载状态。</li></ul><p>对于小白用户而言，微信的加载条让人『感觉』更快。</p><p>除了这一点，<code>WKWebView</code>的<code>estimatedProgress</code>并不会均匀地返回结果。很可能第一次返回结果就是0.5，然后就是0.1。这样Safari加载时，会看到进度条忽快忽慢。</p><p>总结起来：</p><ul><li><code>estimatedProgress</code>返回值不均匀，这样进度条进度并不平滑；</li><li>虚假进度给人『更好』的用户体验。</li></ul><h2 id="仿微信网页进度条实现方式Swift4"><a href="#仿微信网页进度条实现方式Swift4" class="headerlink" title="仿微信网页进度条实现方式Swift4"></a>仿微信网页进度条实现方式Swift4</h2><p>该实现依赖于对KVO有一定的了解，若不了解，可以参考另一篇：<a href="http://pkuflint.me/2018/understanding-kvo-in-swift/" target="_blank" rel="noopener">理解KVO - 用Swift在WKWebView中添加进度条</a></p><p>首先，声明必要的变量。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们的网页，因为要使用KVO，所以对象必须添加@objc</span></span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">var</span> webView = <span class="type">WKWebView</span>()</span><br><span class="line"><span class="comment">// 我们要监听的另一个对象，即网页加载时间，同样因为要使用KVO，属性要添加@objc和dynamic</span></span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> loadTime: <span class="type">Double</span> = <span class="number">0.0</span></span><br><span class="line"><span class="comment">// 这个是我们的进度条</span></span><br><span class="line"><span class="keyword">var</span> progressLayer: <span class="type">CALayer!</span></span><br><span class="line"><span class="comment">// 统计页面加载时间的timer</span></span><br><span class="line"><span class="keyword">var</span> timer: <span class="type">Timer?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是用于监听webView.estimatedProgress和loadTime的两个监听对象</span></span><br><span class="line"><span class="keyword">var</span> progressObservation: <span class="type">NSKeyValueObservation?</span></span><br><span class="line"><span class="keyword">var</span> loadTimeObservation: <span class="type">NSKeyValueObservation?</span></span><br></pre></td></tr></table></figure><p>接着，创建进度条。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setUpWebView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    webView.frame = view.bounds</span><br><span class="line">    webView.navigationDelegate = <span class="keyword">self</span></span><br><span class="line">    webView.autoresizingMask = [.flexibleWidth, .flexibleHeight]</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: urlString!) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"url is nil"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    webView.load(<span class="type">URLRequest</span>(url: url))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> progress = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: webView.frame.width, height: <span class="number">3</span>))</span><br><span class="line">    webView.addSubview(progress)</span><br><span class="line">    progressLayer = <span class="type">CALayer</span>()</span><br><span class="line">    progressLayer.backgroundColor = <span class="type">APPColor</span>.orange.cgColor</span><br><span class="line">    progress.layer.addSublayer(progressLayer!)</span><br><span class="line"></span><br><span class="line">    view.addSubview(webView)</span><br><span class="line">    <span class="comment">// 设置初始进度条位置为10%</span></span><br><span class="line">    progressLayer!.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: webView.frame.width * <span class="number">0.1</span>, height: <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明遵循<code>WKNavigationDelegate</code>协议后，在协议方法中添加设置监听对象和包含对应处理方法的闭包。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping <span class="params">(WKNavigationActionPolicy)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> navigationAction.navigationType &#123;</span><br><span class="line">    <span class="comment">// other类型，直接从外部赋值url打开页面时，就属于other</span></span><br><span class="line">    <span class="keyword">case</span> .other:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"its an other situation"</span>)</span><br><span class="line">    <span class="keyword">case</span> .reload:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"it's a reload situation"</span>)</span><br><span class="line">    <span class="keyword">case</span> .backForward:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"its going back"</span>)</span><br><span class="line">    <span class="keyword">case</span> .formResubmitted:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"resubmited"</span>)</span><br><span class="line">    <span class="keyword">case</span> .formSubmitted:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"from submitted"</span>)</span><br><span class="line">    <span class="comment">// 点击当前页面连接打开新连接</span></span><br><span class="line">    <span class="keyword">case</span> .linkActivated:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"link activited"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startProgress()<span class="comment">// 设置progressBar初始状态，并添加观察，参考下文</span></span><br><span class="line">    destroyTimer()<span class="comment">// 保险起见，再摧毁一次timer</span></span><br><span class="line">    startTimer()<span class="comment">// 启动timer开始计时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否允许访问</span></span><br><span class="line">    decisionHandler(.allow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置timer为每0.1秒为loadTime赋值，这样可以大约0.1秒就修改一次进度条，看起来更平滑</span></span><br><span class="line">    timer = <span class="type">Timer</span>.scheduledTimer(withTimeInterval: <span class="number">0.1</span>, repeats: <span class="literal">true</span>, block: &#123; (timer) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">        weakself?.loadTime += <span class="number">0.1</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">destroyTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    timer?.invalidate()</span><br><span class="line">    loadTime = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startProgress</span><span class="params">()</span></span> &#123;</span><br><span class="line">    progressLayer.opacity = <span class="number">1</span></span><br><span class="line">    progressLayer!.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: webView.frame.width * <span class="number">0.1</span>, height: <span class="number">3</span>)</span><br><span class="line">    setupObservations()<span class="comment">// 设置监听</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置监听</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupObservations</span><span class="params">()</span></span> &#123;</span><br><span class="line">    setupProgressObservation()</span><br><span class="line">    setupLoadTimeObservation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止监听</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopObservations</span><span class="params">()</span></span> &#123;</span><br><span class="line">    progressObservation?.invalidate()</span><br><span class="line">    loadTimeObservation?.invalidate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是设置监听的具体方法，也是重头戏：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听webView.estimatedProgress，即页面加载实际进度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupProgressObservation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    progressObservation = webView.observe(\.estimatedProgress, options: [.old, .new], changeHandler: &#123; (webView, change) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> newValue = change.newValue  ?? <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> oldValue = change.oldValue  ?? <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">        <span class="comment">//  在达到0.9之前，进度条由loadTime决定；到0.9以后，根据实际进度进行加载</span></span><br><span class="line">        <span class="keyword">if</span> newValue &gt; oldValue &amp;&amp; newValue &gt; <span class="number">0.9</span> &#123;</span><br><span class="line">            weakself?.progressLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: (weakself?.webView.frame.width)! * <span class="type">CGFloat</span>(newValue), height: <span class="number">3</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> newValue == <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="comment">// 加载结束时，停止监听，停止timer</span></span><br><span class="line">            weakself?.stopObservations()</span><br><span class="line">            weakself?.destroyTimer()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 结束时隐藏progress bar并回到初始位置</span></span><br><span class="line">            <span class="keyword">let</span> time1 = <span class="type">DispatchTime</span>.now() + <span class="number">0.4</span></span><br><span class="line">            <span class="keyword">let</span> time2 = time1 + <span class="number">0.1</span></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: time1) &#123;</span><br><span class="line">                weakself?.progressLayer.opacity = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: time2) &#123;</span><br><span class="line">                weakself?.progressLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">0</span>, height: <span class="number">3</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听loadTime</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupLoadTimeObservation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    loadTimeObservation = observe(\.loadTime, changeHandler: &#123; (<span class="keyword">self</span>, changes) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">        <span class="comment">// 假如加载进度超过90%，则不再通过loadTime更新</span></span><br><span class="line">        <span class="keyword">if</span> weakself!.progressLayer.frame.width &gt;= weakself!.webView.frame.width * <span class="number">0.9</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> ratio = <span class="number">0.0</span> <span class="comment">// 进度条的进度比例</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> time = weakself?.loadTime <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> time &lt;= <span class="number">3</span> &#123;</span><br><span class="line">            <span class="comment">// 前3秒进度条走50%，那么每秒是走0.5 / 3；</span></span><br><span class="line">            <span class="comment">// 0.1是已经固定的进度，下面的逻辑类似</span></span><br><span class="line">            ratio = time * <span class="number">0.5</span> / <span class="number">3</span> + <span class="number">0.1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> time &gt; <span class="number">3</span> &amp;&amp; time &lt;= <span class="number">7</span> &#123;</span><br><span class="line">            ratio = (time - <span class="number">3</span>) * <span class="number">0.2</span> / <span class="number">4</span> + <span class="number">0.6</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> time &gt; <span class="number">7</span> &amp;&amp; time &lt;= <span class="number">15</span> &#123;</span><br><span class="line">            ratio = (time - <span class="number">7</span>) * <span class="number">0.1</span> / <span class="number">8</span> + <span class="number">0.8</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> time &gt; <span class="number">15</span> &amp;&amp; time &lt;  <span class="number">25</span> &#123;</span><br><span class="line">            ratio = <span class="number">0.9</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        weakself?.progressLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: weakself!.webView.frame.width * <span class="type">CGFloat</span>(ratio), height: <span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，进度条的全部实现已经完成。</p><p>如果对KVO有不理解，可以参考我的另一篇使用KVO的例子：<a href="http://pkuflint.me/2018/understanding-kvo-in-swift/" target="_blank" rel="noopener">理解KVO - 用Swift在WKWebView中添加进度条</a>。在这篇文章中，我用于实现进度条的逻辑正是像Safari那样的真实进度。</p><blockquote><p>本人初学，有错误或疏漏之处，欢迎斧正！</p></blockquote><p>参考文档：</p><ul><li><a href="https://www.jianshu.com/p/24b3e3ddc946" target="_blank" rel="noopener">https://www.jianshu.com/p/24b3e3ddc946</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 进度条 </tag>
            
            <tag> WKWebView </tag>
            
            <tag> Progress bar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解KVO - 用Swift在WKWebView中添加进度条</title>
      <link href="/2018/understanding-kvo-in-swift/"/>
      <url>/2018/understanding-kvo-in-swift/</url>
      
        <content type="html"><![CDATA[<p>KVO，即Key-value observation，是苹果提供的一种机制，它可以使监听对象在被监听对象的数值发生改变时收到通知，进而去进行响应的处理。</p><p>KVO实现起来比较简单，主要的流程只有3个：</p><ol><li>添加观察者</li><li>在监听方法中处理监听结果</li><li>监听结束后移除观察者</li></ol><p>下面我们用一个实际的例子来说明一下这3个步骤。在App里使用<code>WKWebView</code>来加载网页时，我们希望实现一个在页面顶部的进度条，来表示网页加载的进度。而恰好<code>WKWebView</code>的实例有一个<code>estimatedProgress</code>属性，我们可以在此基础上使用KVO来实现。</p><h2 id="添加观察者"><a href="#添加观察者" class="headerlink" title="添加观察者"></a>添加观察者</h2><p>第一步，是要正确地声明变量。因为KVO是在Objective-C中提供的，要在Swift中使用，被观察的属性必须添加<code>@objc</code>和<code>dynamic</code>关键词，来确保可以正确地被观察到。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明属性，我们的网页视图</span></span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">var</span> webview: <span class="type">WKWebView!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建私有变量，用于添加观察者时创建context参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> progressContext = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>第二步，就是在适合的位置添加观察者。一般来说在<code>viewDidLoad</code>中添加就可以。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订阅观察webView.estimatedProgress属性</span></span><br><span class="line">webView.addObserver(<span class="keyword">self</span>, forKeyPath: #keyPath(estimatedProgress), options: [.new, .old], context: &amp;progressContext)</span><br></pre></td></tr></table></figure><a id="more"></a><p>对于方法<code>func addObserver(_ observer: NSObject, forKeyPath keyPath: String, options: NSKeyValueObservingOptions = [], context: UnsafeMutableRawPointer?)</code>简单介绍下其参数：</p><ul><li><p>方法消息接受者，就是被监听的对象。不过就上面的代码而言，<code>webView</code>同样也是<code>self</code>当前controller的属性，所以这条消息也可以发送给<code>self</code>，但是<code>keyPath</code>就要相应地修改为<code>keyPath(webView.estimatedProgress)</code>。</p></li><li><p>观察者，即订阅观察的对象，在被观察者数值变化时收到通知。一般来说，就是当前的controller。</p></li><li><p>keyPath，即相对于接受者对象，需要观察的属性。可以直接用明确的字符串<code>&quot;estimatedProgress&quot;</code>来替代<code>#keyPath(estimatedProgress)</code>，但那样直接操作字符串出现打错，还是用#keyPath构造比较简单。</p></li><li><p>options，这里是接收对象时，选择接收的累类型。总共有4种，需要接受就添加其enum值进入数组参数传入：</p><ul><li><code>.new</code>，接收到变化后的新数值。</li><li><code>.old</code>，接收到变化前的老数值。</li><li><code>initial</code>，即要求立刻返回通知给观察者，在注册观察者方法返回之前。</li><li><code>.prior</code>，即是否需要在数值变化前和变化后各发送一条通知，而不是默认的只在变化后发送通知。</li></ul></li><li><p>context，这里的环境变量，一般用于在不同的观察者在观察相同的<code>keyPath</code>时用于区分。上面的添加观察者代码中，我其实没必要传入<code>context</code>，只是为了演示如何创建与传入<code>context</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先是声明私有变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> myContext = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后直接使用`&amp;myContext`作为`context`参数传入。</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="接收被观察者通知并响应处理"><a href="#接收被观察者通知并响应处理" class="headerlink" title="接收被观察者通知并响应处理"></a>接收被观察者通知并响应处理</h2><p>我们的目的是实现进度条，因此需要先添加一条进度条。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setUpWebView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    webView.frame = view.bounds</span><br><span class="line">    webView.navigationDelegate = <span class="keyword">self</span></span><br><span class="line">    webView.autoresizingMask = [.flexibleWidth, .flexibleHeight]</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: urlString!) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"url is nil"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    webView.load(<span class="type">URLRequest</span>(url: url))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建名为progress的进度条</span></span><br><span class="line">    <span class="keyword">let</span> progress = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: webView.frame.width, height: <span class="number">3</span>))</span><br><span class="line">    webView.addSubview(progress)</span><br><span class="line">    <span class="comment">// 之前已经提前声明了progressLayer作为实例变量，方便作为进度条修改</span></span><br><span class="line">    progressLayer = <span class="type">CALayer</span>()</span><br><span class="line">    progressLayer.backgroundColor = <span class="type">APPColor</span>.orange.cgColor</span><br><span class="line">    progress.layer.addSublayer(progressLayer!)</span><br><span class="line"></span><br><span class="line">    view.addSubview(webView)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置进度条进度的方法，这里直接在打开网页时，设置10%的加载进度，让页面加载看起来更快</span></span><br><span class="line">    progressLayer!.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: webView.frame.width * <span class="number">0.1</span>, height: <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进度条配置好了，下面就可以设置监听方法，来处理进度条了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?, of object: <span class="keyword">Any</span>?, change: [NSKeyValueChangeKey : <span class="keyword">Any</span>]?, context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> keyPath == #keyPath(webView.estimatedProgress) &amp;&amp; context == &amp;progressContext &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> changes = change <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">//请注意这里读取options中数值的方法</span></span><br><span class="line">    <span class="keyword">let</span> newValue = changes[<span class="type">NSKeyValueChangeKey</span>.newKey] <span class="keyword">as</span>? <span class="type">Double</span> ?? <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> oldValue = changes[<span class="type">NSKeyValueChangeKey</span>.oldKey] <span class="keyword">as</span>? <span class="type">Double</span> ?? <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为我们已经设置了进度条为0.1，所以只有在进度大于0.1后再进行变化</span></span><br><span class="line">    <span class="keyword">if</span> newValue &gt; oldValue &amp;&amp; newValue &gt; <span class="number">0.1</span> &#123;</span><br><span class="line">        progressLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: webView.frame.width * <span class="type">CGFloat</span>(newValue), height: <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当进度为100%时，隐藏progressLayer并将其初始值改为0</span></span><br><span class="line">    <span class="keyword">if</span> newValue == <span class="number">1.0</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> time1 = <span class="type">DispatchTime</span>.now() + <span class="number">0.4</span></span><br><span class="line">        <span class="keyword">let</span> time2 = time1 + <span class="number">0.1</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: time1) &#123;</span><br><span class="line">            <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">            weakself?.progressLayer.opacity = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: time2) &#123;</span><br><span class="line">            <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">            weakself?.progressLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">0</span>, height: <span class="number">3</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移除观察者"><a href="#移除观察者" class="headerlink" title="移除观察者"></a>移除观察者</h2><p>在不需要监听时，或者至少在<code>观察者</code>要被释放之前，需要移除观察者身份。</p><p>在<code>viewDidDisappear</code>或者其他适当的位置，调用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">removeObserver(<span class="keyword">self</span>, forKeyPath: #keyPath(webView.estimatedProgress))</span><br></pre></td></tr></table></figure><p>这样利用KVO实现加载进度条的目的已经达成了。</p><h2 id="更Swifty的实现方式：Block-based-KVO"><a href="#更Swifty的实现方式：Block-based-KVO" class="headerlink" title="更Swifty的实现方式：Block-based KVO"></a>更Swifty的实现方式：Block-based KVO</h2><p>在Swift4里，官方推荐了另外Key-value Oberservation的实现方式。简单来说，就是创建一个变量observation、给obervation赋值。赋值实现了既添加观察者又实现响应通知的功能。最后在不需要观察时，直接把observation设置为<code>nil</code>即可。</p><p>针对上面的进度加载条，实现代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明变量，被观察的属性依然还需要添加@objc和dynamic</span></span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">var</span> webView = <span class="type">WKWebView</span>()</span><br><span class="line"><span class="keyword">var</span> progressLayer: <span class="type">CALayer!</span></span><br><span class="line"><span class="keyword">var</span> progressObervation: <span class="type">NSKeyValueObservation?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置观察</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupObserver</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 请务必注意方法的写法</span></span><br><span class="line">    progressObservation = observe(\.webView.estimatedProgress, options: [.old, .new], changeHandler: &#123; (<span class="keyword">self</span>, change) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> newValue = change.newValue  ?? <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> oldValue = change.oldValue  ?? <span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"new value is \(newValue)"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"new value is \(oldValue)"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> newValue &gt; oldValue &amp;&amp; newValue &gt; <span class="number">0.1</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"time to reset new value"</span>)</span><br><span class="line">            <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">            weakself?.progressLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: (weakself?.webView.frame.width)! * <span class="type">CGFloat</span>(newValue), height: <span class="number">3</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> newValue == <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> time1 = <span class="type">DispatchTime</span>.now() + <span class="number">0.4</span></span><br><span class="line">            <span class="keyword">let</span> time2 = time1 + <span class="number">0.1</span></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: time1) &#123;</span><br><span class="line">                <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">                weakself?.progressLayer.opacity = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: time2) &#123;</span><br><span class="line">                <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">                weakself?.progressLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">0</span>, height: <span class="number">3</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">destroyObserver</span><span class="params">()</span></span> &#123;</span><br><span class="line">    progressObservation = <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    progressObserver?.invalidate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看来是不是很简单？而且一个NSKeyValueObservation对象只负责观察一个<code>keyPath</code>，非常清晰。同时只用一行代码和闭包，更简洁。</p><p>这里介绍下给observation赋值的方法参数。</p><ul><li><p>receiver，即方法的接受者。上面的方法可以改成：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">progressObserver = webView.observe(\.estimatedProgress, options: [.old, .new], changeHandler: &#123; (webView, change) &#123;</span><br><span class="line"><span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>keyPath，这里的<code>keyPath</code>与上文中的<code>keyPath</code>接收的参数类型不同。这里是<code>KeyPath</code>类型，而上面<code>addObserver</code>方法中的<code>keyPath</code>是字符串。写法是<code>\.property</code>，这里的<code>property</code>是相对于<code>receiver</code>的，所以当<code>receiver</code>是controller时，<code>keyPath</code>就是<code>\.webView.estimatedProgress</code>；而当<code>receiver</code>是<code>webView</code>时，keyPath则是<code>\.estimatedProgress</code>。</p></li><li><p>options，与上文一样，传入可选的<code>.new, .old, .initial, .prior</code>。可不传入options，这样的话，不能从闭包中接收到的<code>change</code>里的<code>newValue</code>和<code>oldValue</code>都是0。</p></li><li><p>closure，闭包接收2个参数，即<code>receiver</code>和作为<code>NSKeyValueObservedChange</code>类型的<code>change</code>。从change可以读取其<code>newValue</code>和<code>oldValue</code>。</p></li></ul><p>最后关于停止监听，有两个办法可选：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁</span></span><br><span class="line">progressObserver = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不销毁，仅仅停止监听</span></span><br><span class="line">progressObserver?.invalidate()</span><br></pre></td></tr></table></figure><p>如果不需要停止，可以不用处理，也不用刻意去移除监听，<code>controller</code>作为<code>observation</code>的<code>owner</code>会自动处理。</p><blockquote><p>本人初学，有错误或疏漏之处，欢迎斧正！</p></blockquote><p>参考文档：</p><ul><li><a href="http://swifter.tips/kvo/" target="_blank" rel="noopener">http://swifter.tips/kvo/</a></li><li><a href="https://cocoacasts.com/key-value-observing-kvo-and-swift-3" target="_blank" rel="noopener">https://cocoacasts.com/key-value-observing-kvo-and-swift-3</a></li><li><a href="https://www.jianshu.com/p/24b3e3ddc946" target="_blank" rel="noopener">https://www.jianshu.com/p/24b3e3ddc946</a></li><li><a href="https://developer.apple.com/documentation/swift/cocoa_design_patterns/using_key_value_observing_in_swift" target="_blank" rel="noopener">Using Key-Value Observing in Swift | Apple Developer Documentation</a></li><li><a href="https://nshipster.com/key-value-observing/" target="_blank" rel="noopener">https://nshipster.com/key-value-observing/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> KVO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苹果内购接入的坑与核心流程 - Swift</title>
      <link href="/2018/swift-iap-pitfalls/"/>
      <url>/2018/swift-iap-pitfalls/</url>
      
        <content type="html"><![CDATA[<p>通过苹果开发文档、搜索与挣扎摸索，我已经在App上实现了【消耗型商品】的内购。总结流程如下：</p><ol><li>完成必须的准备工作</li><li>用有效的商品id创建<code>SKProductRequest</code>请求苹果服务器返回商品（<code>SKProduct</code>）。</li><li>用返回的有效的商品创建payment，并将payment加入苹果的支付队列。</li><li>监听队列，并根据监听到的交易状态进行适当的处理，尤其需要在交易完毕时关闭交易。</li></ol><p>这方面的文档，我觉得苹果官方的Programming Guide就写的很好。可以仔细读一下。</p><h2 id="我实际遇到的坑"><a href="#我实际遇到的坑" class="headerlink" title="我实际遇到的坑"></a>我实际遇到的坑</h2><ol><li><p>必须先签署协议才能进行内购开发，否则无法返回商品。</p></li><li><p>创建沙箱测试员时，密码必须是强密码，即同时包含大写字母、小写字母和数字。否则，会报错：Unknown Errors while creating Sandbox Tester, Please check Error Log, email=xxx。</p></li><li><p>请求商品的<code>SKProductRequest</code>实例的<code>delegate</code>必须在离开页面时<code>viewDidDisappear</code>设置为<code>nil</code>，因为即使你已经离开了页面，苹果依然会尝试向<code>SKProductRequest</code>的代理发送消息，然后App就崩溃了。</p></li><li><p>必须在<code>AppDelegate</code>中声明遵守<code>SKPaymentTransactionObserver</code>协议、实现协议方法<code>updatedTransactions</code>、并在<code>didFinishLaunching</code>方法中加入如下代码<code>SKPaymentQueue.default().add(self)</code>。</p><p>这一行代码是将AppDelegate作为内购队列的监听者。这样，即使你离开了内购页面、即使上次支付未完成等情况，都能够在这里得到及时的处理。</p><p>如果不在这里这么做，可能的报错有：<br><code>This In-App purchase has already been bought. It will be restored for free.</code></p><p>如果需要在内购页面上实现交互，可以也在内购界面上添加监听，并进行交互上面适当的处理。但无路如何，不能省掉<code>AppDelegate</code>中的那部分。</p></li></ol><h2 id="内购接入核心流程"><a href="#内购接入核心流程" class="headerlink" title="内购接入核心流程"></a>内购接入核心流程</h2><p>以下是我实际接入中使用的代码。</p><a id="more"></a><h3 id="请求商品"><a href="#请求商品" class="headerlink" title="请求商品"></a>请求商品</h3><p>商品是由苹果服务器返回的，请求有三个步骤：获取商品id字符串、发起请求、代理协议中处理结果。</p><h4 id="获取商品id"><a href="#获取商品id" class="headerlink" title="获取商品id"></a>获取商品id</h4><p>获取商品id，这个可以请求服务器，也可以保存在App上。我的App是用的后者。</p><p>首先创建一个名为<code>ProductID</code>的<code>plist</code>文件。文件内容是一个<code>Array</code>，里面是保存的商品id字符串。</p><blockquote><p>这里需要说明的是，商品id，即product identifier，就是你在iTunes Connect 内购列表页面上看到的商品id，不需要再拼接包名bundle identifier。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get product id from plist.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">predefinedProductIdentifiers</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>]? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"ProductID"</span>, withExtension: <span class="string">"plist"</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> productIdentifiers = <span class="type">NSArray</span>(contentsOf: url) <span class="keyword">as</span>? [<span class="type">String</span>] <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> productIdentifiers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证商品id"><a href="#验证商品id" class="headerlink" title="验证商品id"></a>验证商品id</h4><p>请求苹果服务器验证我们提供的商品id是否有效。不过记得要把内购Controller设置为遵循<code>SKProductsRequestDelegate</code>协议，否则无法收到通知。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateProductIdentifers</span><span class="params">(with productIdentifiers: [String])</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">set</span> = <span class="type">NSSet</span>(array: productIdentifiers) <span class="keyword">as</span>? <span class="type">Set</span>&lt;<span class="type">String</span>&gt; <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> productRequest = <span class="type">SKProductsRequest</span>(productIdentifiers: <span class="keyword">set</span>)</span><br><span class="line">    request = productRequest<span class="comment">// 将request强引用，避免在完成前被提前释放；不过也务必在离开页面后，将request.delegate设置为nil</span></span><br><span class="line">    productRequest.delegate = <span class="keyword">self</span></span><br><span class="line">    productRequest.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在协议中处理商品"><a href="#在协议中处理商品" class="headerlink" title="在协议中处理商品"></a>在协议中处理商品</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productsRequest</span><span class="params">(<span class="number">_</span> request: SKProductsRequest, didReceive response: SKProductsResponse)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"received product response"</span>)</span><br><span class="line">    products = response.products<span class="comment">// 将获取到的商品存储在界面实例变量，再次购买时不需要重复请求商品</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面是继续进行支付请求</span></span><br></pre></td></tr></table></figure><h3 id="请求支付"><a href="#请求支付" class="headerlink" title="请求支付"></a>请求支付</h3><p>在获取了有效商品后，就可以用商品创建<code>SKPayment</code>，并将<code>payment</code>实例加入苹果支付队列中。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestPayment</span><span class="params">(with product: SKProduct)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> payment = <span class="type">SKPayment</span>(product: product)</span><br><span class="line">    <span class="type">SKPaymentQueue</span>.<span class="keyword">default</span>().add(payment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理支付"><a href="#处理支付" class="headerlink" title="处理支付"></a>处理支付</h3><p>这个步骤核心的点就是创建并添加<code>SKPaymentTransactionObserver</code>。</p><h4 id="AppDelegate添加observer"><a href="#AppDelegate添加observer" class="headerlink" title="AppDelegate添加observer"></a>AppDelegate添加observer</h4><ol><li><p>在AppDelegate声明遵循<code>SKPaymentTransactionObserver</code>协议。</p></li><li><p>实现协议方法，实现后实现者就可以作为observer。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">*<span class="comment">// MARK: - SK Product Request Delegate*</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">paymentQueue</span><span class="params">(<span class="number">_</span> queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> transaction <span class="keyword">in</span> transactions &#123;</span><br><span class="line">        <span class="keyword">switch</span> transaction.transactionState &#123;</span><br><span class="line">        <span class="keyword">case</span> .purchasing:</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                <span class="type">SVProgressHUD</span>.show(withStatus: <span class="type">NSLocalizedString</span>(<span class="string">"订单处理中"</span>, comment: <span class="string">"请求支付提示"</span> ))</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .deferred:</span><br><span class="line">            <span class="type">SVProgressHUD</span>.show(withStatus: <span class="type">NSLocalizedString</span>(<span class="string">"订单处理中"</span>, comment: <span class="string">"请求支付提示"</span> ))</span><br><span class="line">        <span class="keyword">case</span> .purchased:</span><br><span class="line">        <span class="comment">// 购买成功，此处需要发送玩家道具、保存凭证等动作。    </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当然交易完毕后，一定要手动关闭            </span></span><br><span class="line">        <span class="type">SKPaymentQueue</span>.<span class="keyword">default</span>().finishTransaction(transaction)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> .failed:</span><br><span class="line">        <span class="comment">// 交易失败，也要关闭交易         </span></span><br><span class="line">        <span class="type">SKPaymentQueue</span>.<span class="keyword">default</span>().finishTransaction(transaction)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> .restored:</span><br><span class="line">        <span class="comment">// 恢复订单</span></span><br><span class="line">        <span class="type">SKPaymentQueue</span>.<span class="keyword">default</span>().finishTransaction(transaction)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"other situation"</span>)</span><br><span class="line">        <span class="type">SKPaymentQueue</span>.<span class="keyword">default</span>().finishTransaction(transaction)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>didFinishLaunchingWithOptions</code>方法中添加观察者：<br> <code>SKPaymentQueue.default().add(self)</code></p></li></ol><h4 id="其他界面添加observer"><a href="#其他界面添加observer" class="headerlink" title="其他界面添加observer"></a>其他界面添加observer</h4><p>假如用户一直呆在内购界面等待结束，我们很可能需要在内购界面也要一套前端的展示机制。跟AppDelegate的流程一样，我们将内购界面也作为<code>SKPaymentTransactionObserver</code>添加到队列中。这样，内购界面也能收到通知了。</p><blockquote><p>离开其他界面时，记得调用<code>SKPaymentQueue.default().remove(self)</code>来移除observer，否则可能会崩溃。</p></blockquote><p>当内购界面可用的时候，就可以让内购界面去处理一些前端交互，比如弹出窗口，关闭当前界面等。</p><h3 id="恢复支付"><a href="#恢复支付" class="headerlink" title="恢复支付"></a>恢复支付</h3><p>如果用户购买的是非消耗型商品，比如是一个去广告服务。用户卸载后，如果重新安装回来，是可以申请恢复记录的。我使用的办法比较简陋，没有用加密和服务端验证，只是对比了下<code>transaction.payment.productIdentifier</code>。</p><p>首先，在用户发起「恢复购买记录」后，调用<code>SKPaymentQueue.default().restoreCompletedTransactions()</code>。</p><p>然后，在<code>updateTransactions</code>协议方法中，在<code>case .restored</code>中验证用户的<code>transaction.payment.productIdentifier</code>，若符合，则修改<code>UerDefaults</code>中的去广告标记。</p><blockquote><p>本人初学，有不当或错漏之处，感谢斧正！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> 坑 </tag>
            
            <tag> IAP </tag>
            
            <tag> In App Purchase </tag>
            
            <tag> 内购 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自学路上的坑01 - Scheme勾选项带来的一些列问题</title>
      <link href="/2018/self-taught-swift-lesson-01/"/>
      <url>/2018/self-taught-swift-lesson-01/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">如果你的问题在网上找不到，那一定是你犯了一个低级错误。</blockquote><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><blockquote><p><code>Edit Scheme</code>中勾选<code>Malloc Stack</code>会导致每次Xcode覆盖安装App都预先占用一定量的数据存储空间，且由于某种原因，本来每次存储几十KB的数据结果占用了几十MB；同时，这个勾选项还会导致<code>Instrument - Leak</code>界面出现名为<code>&lt;Allocated Prior To Attach&gt;</code>的Leak。</p></blockquote><p><code>Edit Scheme</code>中<code>Zombie Object</code>调试结束要记得关掉，否则会在<code>Instrument - Leak</code>界面产生大量的名为<code>Zombie Object</code>的Leak。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>有天突然发现iPhone储存空间管理界面，显示我的App占用了3.7GB的文稿数据空间。震惊之余，立马用模拟器和真机重新安装，边跑边记录文稿数据变化情况。经过整理如下有2个问题表现：</p><ol><li><p>真机每次跑完一次步，会增加10几MB的文稿数据存储空间。</p></li><li><p>真机每次Xcode覆盖安装都会额外增加8MB的文稿数据存储空间。</p></li><li><p>在<code>Instruments - Leak</code>中有数不尽的Leaks，其中占比最大的是叫做<code>&lt;Allocated Prior To Attach&gt;</code>的Leak。</p><p> <img alt data-src="http://p94ibkeg8.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-20%2007.09.57.png"></p></li></ol><p>一通搜索，尝试了以下几个方案：</p><ol><li>将工程代码中闭包里的被强引用的<code>self</code>全部改为弱引用。虽然这点学了点东西，不过对于当前的问题，没有实际效果。</li><li>在<code>Leak</code>界面看到了<code>Zombie Object</code>，想到之前修改过<code>Scheme</code>，于是前往将<code>Zombie Object</code>反选。之后Leak界面一下子少了很多所谓的<code>Leak</code>。</li><li>数据量大的问题，一筹莫展之际，去看了<code>Xcode</code>运行状态中的<code>Disk</code>，发现确实每次都有7MB新增的空间，于是拿这个界面的关键词进行搜索，结果还是<code>Scheme</code>的锅。在<code>Edit Scheme</code>中反选<code>Malloc Stack</code>，问题立马解决了。</li><li>步骤三做了以后，<code>Leak</code>界面就没有<code>&lt;Allocated Prior To Attach&gt;</code>的Leak名称了。</li></ol><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>整个过程，前后搜索、尝试、验证，花了我大约5个小时。就是这样的时刻，让我觉得新手自学有太多的艰难。有些东西，对于别人几乎像是常识般；而对于新手，就是一个有待解决的问题，而正因为在别人眼里是常识，导致新手很难在网络上找到现成的答案。</p><blockquote><p>如果你的问题在网上找不到答案，那一定是你犯了一个低级错误。</p></blockquote><p>我之前就有这样的意识了，也许以后可以考虑先把问题搁置起来，而不必第一时间就要找到解决方案，尤其是网上搜不到同类问题的时候。</p><p>不过，今天这番至少知道了：要在闭包里用弱引用，怎样使用Instrument - Leak，以及查看Xcode的运行状态。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> 自学 </tag>
            
            <tag> 坑 </tag>
            
            <tag> Scheme </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自学编程6年，从入门到放弃</title>
      <link href="/2018/from-zero-to-quit/"/>
      <url>/2018/from-zero-to-quit/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">我会用4种编程语言写出Hello World！</blockquote><h2 id="2013年-C语言"><a href="#2013年-C语言" class="headerlink" title="2013年 C语言"></a>2013年 C语言</h2><p>自学编程的想法，最早应该可以追溯到2013年，证据就是我于当时写下的博客，以及博客中提到的新买的、后来被村长带走的《C语言编程》。我已经记不得当时为何要学编程，为何要从C语言开始，以及那本书我看了多少。</p><p>不过，打出上面最后一句话后，我还是想起来了：当时我没能用C语言打出<code>Hello World!</code>就放弃了，因为没弄好编译器。</p><a id="more"></a><h2 id="2014年-购入Macbook"><a href="#2014年-购入Macbook" class="headerlink" title="2014年 购入Macbook"></a>2014年 购入Macbook</h2><p>这一年，我花了六千大洋买了最低配的Macbook Air 11.6英寸版本。</p><p>为什么要买？在我的记忆里，应该就是为了编写iOS App。不过，我并没有在这一年留下任何的学习笔记。</p><h2 id="2015年-Java语言"><a href="#2015年-Java语言" class="headerlink" title="2015年 Java语言"></a>2015年 Java语言</h2><p>这一年工作中略有些空闲。在工作时间间隙和下班后，我开始学习Java。这时候学的是网易公开课上的斯坦福大学的CS106A课程。</p><p>我清晰地记得这波自学最后一次编程是用Java语言在画布上画出三节火车车厢。而印象笔记显示我只学到了教材第6章：Methods。</p><h2 id="2016年-Objective-C语言"><a href="#2016年-Objective-C语言" class="headerlink" title="2016年 Objective-C语言"></a>2016年 Objective-C语言</h2><p>机缘巧合，凭借我学到的这点皮毛，我从游戏运营岗位跳到一家云计算公司做售后技术支持，平时就是解答下我们的商业SDK和其他产品使用和接入中的一些问题。我有了工作时间学习编程的理由和一定的时间。</p><p>我开始跟随王寒翻译的Ray Wenderlich的iOS学习教材学习，接着跟着我自己买的书籍，也看过一点网易公开课上的斯坦福大学白胡子老师的课。</p><p>最后的成果，就是我用Objective-C模仿【雨时】开发了一个天气App。基本的界面、天气请求、设置等都已经做的差不多了，大约完成度有7成。</p><p>不过，项目一旦搁置，可能就永远捡不起了。现在这个做了一半的项目还在我的电脑上。</p><h2 id="2017年-Python语言"><a href="#2017年-Python语言" class="headerlink" title="2017年 Python语言"></a>2017年 Python语言</h2><p>在做技术支持的最后一段日子，我开始学习Python。我想用Python写一些工作上可以用到的工具，比如：接口检测脚本，但Objective-C做不到。</p><p>我找到了网上的廖雪峰的Python课程开始学习，基本完成了教程的内容并进行笔记，不过并未完成最后的实战。</p><p>我很快就离职了，最终也没有找到实际使用Python的场景。</p><h2 id="2018年-Swift语言"><a href="#2018年-Swift语言" class="headerlink" title="2018年 Swift语言"></a>2018年 Swift语言</h2><p>我从Udemy上购买了一套Swift课程。我用了一个多月的时间跟着完成了Swift开发相关的部分。我开始开发自己的App，这次是一个跑步App。现在App的开发进度也基本上有八成了。</p><p>现在我又开始复习学过的Python内容。</p><h2 id="我该学什么语言？"><a href="#我该学什么语言？" class="headerlink" title="我该学什么语言？"></a>我该学什么语言？</h2><p>我也曾经有这样的疑问，而且上面提到的几乎每一年我应该都有这样的疑问，即使我已经在学习某种语言的时候，我还是会有疑问，尤其是当我遇到瓶颈和阻碍的时候。</p><p>大约是2018年初，我可能再次提出了这个疑问。我看到廖雪峰也回答说Java开始学习编程。于是，我又捡起了斯坦福大学CS106A网络课程。这次，我学到了第19节课，第19节的标题是：Interface &amp; Map。</p><p>但是，这个问题重要吗？你看了我的经历，你还觉得重要吗？6年了，从自学编程的想法萌发直到现在，我学习了4种编程语言的基本语法。但这有什么用呢？</p><p>中肯地说，我这次在学Swift时，很多概念就很快就能理解，因为之前学过Objective-C，所以通用的代理、通知、第三方库、界面等都不再是问题。所以，实际上每段学习，都有它的价值。这是肯定的，只是，就结果而言，都不能令人满意。毕竟，精通一门语言比仅仅熟悉10门语言的语法要强上10倍吧。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一天</title>
      <link href="/2018/one-day/"/>
      <url>/2018/one-day/</url>
      
        <content type="html"><![CDATA[<p>我下楼去买可乐。</p><p>走下楼梯时，看到楼梯上靠墙坐着一个头发花白的中年人。他低着头，在玩开心消消乐。我走过了，却还是忍不住回头看了他一样。他很严肃。</p><p>这是我今天喝的第三罐可乐。可乐倒进嘴里，苦味已经盖过了甜味。我只能喝可乐。喝酒太辣太苦，而我也没有配得上酒的忧愁或把酒言欢的朋友。我有的只是这种说不出是甜还是苦的平常生活。</p><a id="more"></a><p>是不是太平常了呢？我七点二十起床，有时会赖到七点半。如果前一天晚上没洗澡，那么早上会洗个澡。妈在这里帮忙带孩子，早上她也会准备早饭。吃完早饭，大约八点到八点十分之间离家去上班。我先走十几分钟到一个停放了功能正常的共享单车的公司门口，然后骑车5分钟到地铁站。如果是上一周，进了地铁，我会掏出Kindle来读我下载的古龙小说。今天我却不想。我不关心七种武器那最后一种是怎样的。</p><p>话说回来，是古龙小说不合我的胃口，还是我已经过了为武侠小说着迷的年纪？我看了《多情剑客无情剑》和《七种武器》的前75%部分，并没有欲罢不能的感觉，在思想深度与触动人方面，连同时阅读的另一本《无声告白》都比不上。</p><p>继续说回地铁上，今天我没有掏出Kindle。我今天起来心情就不好，好像又忘记了自己的目标，或者说，又开始在意自己的没有目标的状态。我想要不就随便想点事儿吧，就在这地铁碾压铁轨的有规律的声响中。要不要记录下自己的想法呢？我伸手进口袋掏出了手机。我什么也没有记录，却看了一路的火影漫画，昨天晚上刚下载的APP。</p><p>三忍大战，当时多么激动人心的情节。在漫画上，缺少了音乐、配音、画面的渲染，让感染力减弱了不少。而且我还是二刷，几乎是无感，只是会想起当时自己应该是很激动的。</p><p>到公司后去楼下的自动售卖机买可乐。想着这次要不用支付宝吧。结果用支付宝扫描后反而报错了。</p><p>今天的主要任务就是测试一个新开发完成的麻将玩法。其他同事可以搞定，我就安排与追踪下进度。产品还是有很多小问题，让人有点无可奈何。我又列了下当前主要的模块，安排了下优先级。</p><p>然后，我又开始出离，观察自己现在的这个状态。我需要一罐可乐。</p><p>于是，我下楼去买可乐，今天的第三罐可乐。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 胡思乱想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Core Data入门</title>
      <link href="/2018/Beginning-Core-Data/"/>
      <url>/2018/Beginning-Core-Data/</url>
      
        <content type="html"><![CDATA[<p>在iOS App中，如果要存储的数据量比较大，就会使用Core Data。这里汇总了下使用Core Data的基本方式。</p><ol><li>添加Core Data</li><li>配置Core Data中的Entity</li><li>添加新数据</li><li>读取与修改数据</li><li>使用NSPredicate筛选数据</li><li>删除数据</li><li>保存数据</li><li>一份NSPredicate使用备忘清单</li></ol><a id="more"></a><h2 id="添加Core-Data"><a href="#添加Core-Data" class="headerlink" title="添加Core Data"></a>添加Core Data</h2><p>如果在创建项目时没有勾选Using Core Data，可以手动创建Core Data。手动创建Core Data的方式如下：</p><ol><li>在项目中创建新的文件，类型为：Core Data。</li><li>添加相关的预设方法进入<code>AppDelegate</code>中，相关方法如下：</li></ol><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationWillTerminate</span><span class="params">(<span class="number">_</span> application: UIApplication)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.saveContext()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - Core Data stack</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> persistentContainer: <span class="type">NSPersistentContainer</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> container = <span class="type">NSPersistentContainer</span>(name: <span class="string">"DataModel"</span>)</span><br><span class="line">    container.loadPersistentStores(completionHandler: &#123; </span><br><span class="line">    (storeDescription, error) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> error = error <span class="keyword">as</span> <span class="type">NSError?</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Unresolved error \(error), \(error.userInfo)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> container</span><br><span class="line">&#125;()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// MARK: - Core Data Saving support</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveContext</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = persistentContainer.viewContext</span><br><span class="line">    <span class="keyword">if</span> context.hasChanges &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> context.save()</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> nserror = error <span class="keyword">as</span> <span class="type">NSError</span></span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Unresolved error \(nserror), \(nserror.userInfo)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法是Xcode为使用Core Data的新项目自动创建的，我这里只是拷贝了进来。</p><h2 id="配置Core-Data中的Entity"><a href="#配置Core-Data中的Entity" class="headerlink" title="配置Core Data中的Entity"></a>配置Core Data中的Entity</h2><p>点击创建的Core Data文件，我们在界面中配置Entity。Core Data中的Entity，就相当于编程语言中的Class，类比数据库就是一个Table。Entity的Attribute，就是Class的Property，Table中的Field。</p><p>举个例子：<br>我的To-do App中需要两个类，一个是Category，代表清单的类别；一个是Item，代表清单中的具体事项。</p><p>在Core Data中创建2个Entity分别是Category和Item。Category设置1个Attribute：name，类型为String；Item设置2个Attribute：title和done，分别是String和Bool类型。</p><p>然后配置Category和Item的关系，将Category对Item的关系设置为一对多，而Item对Category的关系设置为一对一，毕竟一个事项只有一个类别。</p><h2 id="添加新数据"><a href="#添加新数据" class="headerlink" title="添加新数据"></a>添加新数据</h2><p>无论要对Core Data做什么，都需要用到<code>context</code>，因此需要在用到Core Data的类中添加一个实例变量：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">let context = (UIApplication<span class="selector-class">.shared</span><span class="selector-class">.delegate</span></span><br><span class="line">as! AppDelegate)<span class="selector-class">.persistentContainer</span><span class="selector-class">.viewContext</span></span><br></pre></td></tr></table></figure><p>我要添加一个新的Category，那么从Core Data的Entity中创建对象是这样的：</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">let <span class="keyword">new</span><span class="type">Category</span> = Category(context: <span class="type">self</span>.context)   <span class="comment">// 用Core Data中的Entity创建对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span><span class="type">Category</span>.name = <span class="string">"Work"</span> <span class="comment">// 设置Entity对象的必要attribute</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新的category对象加入categoryList，而categoryList则指向是从数据库中读取的数据。</span></span><br><span class="line">categoryList.append(<span class="keyword">new</span><span class="type">Category</span>)</span><br></pre></td></tr></table></figure><h2 id="读取与修改数据"><a href="#读取与修改数据" class="headerlink" title="读取与修改数据"></a>读取与修改数据</h2><p>从Core Data中读取全部数据：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> request: <span class="type">NSFetchRequest</span>&lt;<span class="type">Category</span>&gt; = <span class="type">Category</span>.fetchRequest()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 将实例变量categoryList指向读取的数据</span></span><br><span class="line">        categoryList = <span class="keyword">try</span> context.fetch(request)  </span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error fetching request, \(error)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而要修改数据，则可以选择使用以下两种方式之一：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将刚加入的Work改为Shopping</span></span><br><span class="line">categoryList[<span class="number">0</span>]<span class="selector-class">.name</span> = <span class="string">"Shopping"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将刚才的Shopping category的name attribute改为"Chores"</span></span><br><span class="line">categoryList[<span class="number">0</span>].setValue(<span class="string">"Chores"</span>, forKey: <span class="string">"name"</span>)</span><br></pre></td></tr></table></figure><h2 id="使用Predicate筛选数据"><a href="#使用Predicate筛选数据" class="headerlink" title="使用Predicate筛选数据"></a>使用Predicate筛选数据</h2><p>有时我们不需要读取数据库中的所有数据，比如我只想读取：Category是Work的所有待办事项Item；或者我想搜索Work类别里待办事项中名字里包含”urgent”的事项，这时，我们这样写：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> selectedCategory = <span class="string">"Work"</span>  // 清单类别</span><br><span class="line"><span class="keyword">let</span> searchKeyword = <span class="string">"urgent"</span>  // 搜索筛选的关键词</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reques<span class="variable">t:</span> NSFetchRequest<span class="symbol">&lt;Item&gt;</span> = Item.fetchRequest()</span><br><span class="line"></span><br><span class="line">// 此处parentCategory是Core Data中Item的一个关系设定，将关系指向Category并命名为parentCategory。</span><br><span class="line"><span class="keyword">let</span> predicate1 = NSPredicate(forma<span class="variable">t:</span> <span class="string">"parentCategory.name MATCHES %@"</span>, selectedCategory) </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> predicate2 = NSPredicate(forma<span class="variable">t:</span> <span class="string">"title CONTAINS[cd] %@"</span>, searchKeyword)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compoundPredicate = NSCompoundPredicate(andPredicateWithSubpredicate<span class="variable">s:</span> [predicate1, predicate2])</span><br><span class="line"></span><br><span class="line">request.predicate = compoundPredicate</span><br><span class="line">request.sortDescriptors = [NSSortDescriptor(key: <span class="string">"title"</span>, ascendin<span class="variable">g:</span> true)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    self.selectedItems = <span class="keyword">try</span> context.fetch(request)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">"Error fetching data, \(error)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>读取数据后，直接从指向数据的变量中，删除对应的数据即可。</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">self</span><span class="selector-class">.context</span><span class="selector-class">.delete</span>(selectedItems[<span class="number">1</span>]) <span class="comment">// 从数据中移除</span></span><br><span class="line"><span class="selector-tag">selectedItems</span><span class="selector-class">.remove</span>(<span class="attribute">at</span>: <span class="number">1</span>) <span class="comment">// 接着更新下指向数据的实例变量</span></span><br></pre></td></tr></table></figure><h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><p>对Core Data进行新增、修改、删除后，都要进行保存才能生效。</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try <span class="built_in">context</span>.<span class="built_in">save</span>()</span><br><span class="line">&#125; <span class="built_in">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Error saving data, \(error)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NSPredicate使用备忘"><a href="#NSPredicate使用备忘" class="headerlink" title="NSPredicate使用备忘"></a>NSPredicate使用备忘</h2><p>关于Predicate的一份备忘清单，可以随时查看：<a href="https://academy.realm.io/posts/nspredicate-cheatsheet/" target="_blank" rel="noopener">NSPredicate备忘清单</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Swift </tag>
            
            <tag> Core Data </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我现在相信的</title>
      <link href="/2018/things-i-believe/"/>
      <url>/2018/things-i-believe/</url>
      
        <content type="html"><![CDATA[<p>尽管对立的理论都能找到足够多的论据和拥趸，每个人，包括我，还是会对某一方的理论更为认同。尽管这种认同并不能增加理论的正确性，理清自己认同的东西还是很有必要。</p><ol><li><p>有钱很好。</p><p> 有了钱，可以为父母实现愿望，让他们高兴；有了钱，可以购买更多的选项；有了钱，甚至可以为父母或自己买来更长的寿命；有了钱，可以免除相当一部分的忧虑和恐惧。</p></li><li><p>幸福不是终点，也不是绝对的。</p><p> 幸福只可能是短暂的。一开始你觉得幸福，适应后，你不再有幸福感。面对相同的一种情形，有人会觉得幸福，有人会觉得难以忍受。追求幸福，其实就像是追求一个泡影，一个注定会迅速消逝的东西。</p><p> 追求幸福，不如平静。</p></li><li><p>追寻意义有意义。</p><p> 对于个体的人，意义不是天赋的，不是不证自明的。换成有一部分人的话来说，人生本来没有意义。但对于个体，至少是对于部分个体，追寻意义是植入底层的，是从小到大受到的教育的结果。即使不断地对自己说，意义都是假的，人还是不愿意接受一个毫无意义的世界。</p><p> 如果世界上没有意义，我的存在还有什么意义？所以，尽管我们可以说，很多人所谓的意义不过是自我欺骗或者大众合谋，但我们还是无法否认意义感的意义。「我相信」跟「这是真的」，哪个更有意义呢？</p></li><li><p>爱情也许存在，但本质上是短暂的。</p><p> 爱情，必须转化为其他形态的关系，才能长久。我不相信天长地久的爱情，我相信某种长久的关系，但你很难称之为爱情。</p></li></ol><p>未完待续… … </p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>做事靠系统——读《小强升职记》</title>
      <link href="/2018/getting-things-done/"/>
      <url>/2018/getting-things-done/</url>
      
        <content type="html"><![CDATA[<p>《小强升职记》是一本关于时间管理方面的小书，以故事和对话的形式展开，非常易读易懂易用。</p><p>书中主要的核心内容有以下三点：</p><ol><li>如何制作待办任务清单</li><li>如何完成复杂项目</li><li>如何专注地工作</li></ol><h2 id="如何制作待办任务清单"><a href="#如何制作待办任务清单" class="headerlink" title="如何制作待办任务清单"></a>如何制作待办任务清单</h2><p>任务清单可以让我们专注于做事，而不用时时刻刻去挂念其他任务。清单让我们清空大脑专注在某个事情上面。</p><p>制作任务清单主要有以下3个步骤：</p><ol><li>用事务篮收集所有想到的被交付的或大或小的待办项目</li><li>将以上待办项目整理为三份清单加一份日程表</li><li>专注于行动清单，要事为先</li></ol><h3 id="收集任务"><a href="#收集任务" class="headerlink" title="收集任务"></a>收集任务</h3><p>我们平时会接到工作上领导派发的需求，以及自己职责内的事务。它们经常在我们正在忙于另一件事情时出现，我们不应当打断正在做的事情，而是要把这件事情加入待办事务篮。待办事务篮里面可能有打电话这样的小事，也可能有准备某项目的运营计划这样的大事。</p><p>收集的作用是为了不打断当前工作且不遗忘重要的事务，同时也是为后续正确地归类最准备。</p><h3 id="归类清单"><a href="#归类清单" class="headerlink" title="归类清单"></a>归类清单</h3><p>将收集到任务根据「可行动」以及「时间」属性，分类添加到3个清单和1份日程表中。</p><ul><li>行动清单，该清单里都是直接行动的事项，有空就去做；任务是有多个行动组成的，由任务分解后的「下一步行动」也直接写进行动清单。比如：找工作，本身是不能立刻行动的，需要拆分为：写简历、投简历、准备面试等可行动事务。</li><li>项目清单，该清单类似任务清单，由多个行动组成。与任务的区别在于，任务多是靠一个人可以完成，而项目则需要与他人协作。比如：新游戏上线最终确认这个事情，就需要联合多部门进行。</li><li>将来清单，该清单上的事务是不确定某个时间要做，先记录上，待时机成熟时，会转变为行动清单或日程表或者被丢进垃圾箱。</li><li>日程表，就是在确定的未来某个时间需要做的行动，所以这里的行动要写的非常具体，免得过了一段时间忘记。需要转交给其他人完成的事务，也写在日程表里，提醒追踪和验收。</li></ul><p>任务和项目分解后，应该包含着多个「下一步行动」，这个拆分后的行动添加进入行动清单。</p><p>如果有2分钟内就可以解决的事，那么应该立刻去做，不用写进行动清单里，比如：填个报销单。</p><p>有了以上的3个清单，我们脑袋里就不用装着沉甸甸的包袱，专注于清单中的事务就行。</p><h3 id="要事为先"><a href="#要事为先" class="headerlink" title="要事为先"></a>要事为先</h3><p>在行动清单里，列出了我们一天中（或某个时间段）需要做的事情。如何安排他们的优先顺序呢？要事为先！</p><p>把事务根据「重要性」和「紧急性」分类为四类：</p><ol><li>重要且紧急</li><li>重要但不紧急</li><li>不重要但紧急</li><li>不重要也不紧急</li></ol><p>重要且紧急的事情，当然是优先完成；不重要但紧急的事情如果可以转交别人完成，或者有礼貌地拒绝别人丢过来的任务；不重要也不紧急的就不要做了。</p><p>关键是重要而不紧急的行动，这个是关键。如果这类行动做的好，那么「重要且紧急」的事情就会少很多，多数的「重要且紧急」的事情都是因为没有处理好「重要但不紧急」的事情导致的。</p><p>怎么判断「重要性」呢？书中说是依据自己的职业价值观，即某事按照你的职业价值观能最大化你的收益，就是最重要的；不过我觉得一般不牵涉价值观，而仅仅涉及到工作中实际的效用，即业务的实际情况。</p><p>怎么判断「紧急性」呢？依据事务的截止日期。比如：这个需求很简单，你看着办，明天给我。如果说这句话的是某个产品，你可能想怼他；但如果是老板，立马变成了一个「紧急性」超高的任务。</p><a id="more"></a><h2 id="如何完成复杂项目"><a href="#如何完成复杂项目" class="headerlink" title="如何完成复杂项目"></a>如何完成复杂项目</h2><p>面对复杂项目或复杂任务，我们往往拖延症发作，焦虑，不知道从何入手，一直拖延到死线降至，潦草完事。</p><p>系统的方法则是：确认目标与任务分解。</p><h3 id="确认目标"><a href="#确认目标" class="headerlink" title="确认目标"></a>确认目标</h3><p>目标要落地，在制定时就要合理，可以采用SMART原则：</p><ul><li>Specific，目标明确，不能模糊；</li><li>Measurable，可衡量，有实现的标准；</li><li>Attainable，可实现性，经过努力可以实现；</li><li>Relevant，与其他目标有相关性，对其他目标有帮助；</li><li>Time-based，有时限，在规定时间内达成。</li></ul><h3 id="任务分解的步骤"><a href="#任务分解的步骤" class="headerlink" title="任务分解的步骤"></a>任务分解的步骤</h3><p>对项目或任务进行分解，可以采用以下三个步骤：</p><ol><li>确认项目或任务的主要事项，可以先分出模块，在大类里面想这个模块里面的具体的小的任务。这个环节，可以利用「思维导图」来完成。</li><li>将步骤一中确定的各类任务，确定对应的成本、周期、负责人以及里程碑，并通过「甘特图」的形式展现。「甘特图」可以用Excel也可以用微软的Project软件来做。</li><li>最后，就是制定奖励规则，就是里程碑达成的奖励并且兑现，这样可以对自己或团队有相当的激励。</li></ol><h3 id="下一步行动的原则"><a href="#下一步行动的原则" class="headerlink" title="下一步行动的原则"></a>下一步行动的原则</h3><p>任务最终需要分解为「下一步行动」，这样我们才能真的去执行。分解的要素为：</p><ul><li>动词开头</li><li>内容清晰</li><li>描述结果</li><li>设置开始时间、周期、最后期限</li></ul><p>这样就非常清晰地知道自己下一步要做什么了。</p><h3 id="像打游戏一样做项目"><a href="#像打游戏一样做项目" class="headerlink" title="像打游戏一样做项目"></a>像打游戏一样做项目</h3><ul><li>明确的目标，这样可以进行行动；</li><li>明确的规则</li><li>即时反馈，比如里程碑奖励；</li><li>尽量做到自愿参与，来自规则的约束不如来自内在的动力</li></ul><p>以上这几点，同样适用于培养习惯。说到培养习惯，书中说：</p><blockquote><p>培养习惯的秘诀是少而慢，而不是多和快。</p><p>再微不足道的成就，都要大肆庆祝。培养习惯可以不是一个人的事，可以找到同道互相支持鼓励。</p></blockquote><h2 id="如何专注高效工作"><a href="#如何专注高效工作" class="headerlink" title="如何专注高效工作"></a>如何专注高效工作</h2><p>专注工作的目的是提高效率，因此主要手段在于：不受打扰以及精力充沛。</p><ul><li>番茄工作法</li><li>挑选时间段</li><li>拒绝别人的猴子</li></ul><h3 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h3><p>番茄工作法，就是专注工作一段时间并休息一段时间，专注工作的这段时间称为一个番茄。这里的关键点是：专注。</p><p>一般来说，可以采用一个番茄20分钟，然后休息5分钟；连续三个番茄，休息15分钟的方式。在番茄时间内，专注工作，不受打扰；主动休息是为了劳逸结合。</p><p>番茄时间根据实际情况可以调整，比如早上精力充沛，可以设置40分钟的番茄时间。</p><h3 id="挑选时间段"><a href="#挑选时间段" class="headerlink" title="挑选时间段"></a>挑选时间段</h3><p>我们得承认，某些时间段我们的工作效率就是高，也许是因为那时的精力充沛，也许是因为那个时间段内比较不被人打扰，比如早上刚上班以及快下班那会。</p><p>找到这样的时段，安排要事去完成。</p><h3 id="拒绝别人的猴子"><a href="#拒绝别人的猴子" class="headerlink" title="拒绝别人的猴子"></a>拒绝别人的猴子</h3><p>猴子，就是别人的事。别人的事，可能变成你的事。他解脱了，你就要背着这只猴子。</p><p>所以，要懂得用适当的、委婉的方式去处理别人可能丢给你的事，否则你需要做的事务可能会越来越多，且多半没有什么价值，最重要会浪费你自己的时间。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> GTD </tag>
            
            <tag> 小强升职记 </tag>
            
            <tag> 时间管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>那一刻，我感觉到一种疼痛 —— 观《你好，波拉德》</title>
      <link href="/2018/hello-brad/"/>
      <url>/2018/hello-brad/</url>
      
        <content type="html"><![CDATA[<blockquote class="blockquote-center">当我在电视上看到我的同学时，我清楚地感觉到，那是一种疼痛。</blockquote><p>小波睡不着觉了。</p><p>同学小西之前在做白宫的顾问，现在出了畅销书，在大学任教，隔几天上一次电视。小西，有名。</p><p>同学小东在运营一个私募基金，盘子百亿美金，住豪宅，坐私人飞机。小东，有钱。</p><p>同学小北的互联网公司被数千万美元收购，跑到海岛上整日逍遥。小北，有闲。</p><p>小波不断地想着这几个同学，想着今天在电视上看到的小西，想着在私人飞机上的小东，以及在阳光沙滩上搂着两个年轻姑娘的小北。小波想着在大学时他们都还是竞争对手，他们还经常在一起混。小波想到前几天自己的公益组织唯一的雇员，自己很看重且全力培养的下属，跟他提离职，说这个工作没什么价值，天天去找人捐钱，还不如他先去挣钱然后自己捐钱呢。小波想到自己现在社交圈里这些庸人，想到聚会上他们一起把酒言欢而自己若有所失。</p><a id="more"></a><p>床上熟睡的妻子轻哼了一声，接着翻身睡去。哦，小东的老婆很漂亮，小波想到，而且还对小东的事业帮助很大。小波想到当时在大学里跟自己老婆的相遇。他被老婆当时的理想所吸引，为了公益的理想，他成立了自己的公益组织。</p><p>周末，他要跟儿子一起去波士顿参观大学。儿子马上就要高考了，填报志愿之前先去学校看看。</p><p>小波在机场又想起了他的那3个同学，跟儿子说，今天我们飞商务舱。于是去到柜台办升舱。升舱要1600美元，他咬咬牙，从钱包找一个有足够余额的卡给到柜员。柜台说，他的机票是廉价机票，不能升舱；又补刀说，他的卡里也没有足够的钱。</p><p>他俩最后还是飞的经济舱。</p><p>小波跟他儿子说，斯坦福也没什么了不起，我当初报考斯坦福，没考上；最后在塔夫大学也不错。儿子说他有希望上哈佛，他有音乐特长，而且成绩不错，老师也觉得他能上。小波很惊讶，不得不为儿子感到高兴。正好今天是去哈佛参加面试。他在外面等待，最后儿子出来告诉他，他把时间记错了，面试是昨天，而不是今天。</p><p>你有能进哈佛的头脑，怎么可能会记不住哈佛的面试时间？小波忍不住责骂。小波想为儿子出头，但是儿子不想让他大庭广众下吵闹。小波想到了同学小西，他肯定认识哈佛的教授，可以帮忙安排面试。</p><p>小波打了小西的电话，是空号。</p><p>小波打了小北的号码寒暄了一番。小北炫耀了他在海岛的神仙般的生活，每天遛遛狗，打打炮，还开了酒吧连锁。小北还说，上次小东结婚时，我们还聊起了你。我们那时有人说，小波呢？</p><p>原来小东结婚了我都不知道，曾经我们那么熟络，现在结婚居然都不叫我？我已经不在他们的社交层次里了吗？小波心中翻腾，但不忘正事，问他要小西的电话，小北说一会发给他。</p><p>这个一会真的好久，小波等不了，又拨打了小东的电话。电话里的小东听起来很焦虑，亲人住院了，说一会还要去赶飞机。小波顺口说到，你不是有私人飞机吗？小东严肃地说到，谁说我有私人飞机？小波觉得自己说错了话一样，赶紧道歉。</p><p>最终他要到了小西的电话。电话里他们聊得很欢乐，正事也都安排了，改天直接跟教务主任面试。而且小西也和小波约定后天一起见面吃饭。</p><p>事办妥了，小波和儿子很高兴。晚上儿子要去酒吧见哈佛的朋友，小波一起去了。来者是一个漂亮的女孩，学音乐的。女孩的另一个朋友，一会也坐过来了，是一个亚洲女孩，年轻漂亮。他们聊的挺嗨。小波幻想着，在海岛沙滩上上搂着这两个女孩，幻想她俩都是自己的女友，幻想着他的生活像同学小北一样美好。要走时，女孩跟他说，晚上他们还在，可以一起来继续嗨。小波说不了。</p><p>确认了儿子熟睡后，他轻手轻脚地出门去了那家酒吧。他看到了白天时那个女孩。他们一起聊。女孩对他从事公益事业很感兴趣，因为她也是，至少现在也是，一个天真的理想主义者。女孩问小波，如果你回到过去，你会做出什么不同的决定？</p><p>小波很坦诚。他说，我会尝试去赚更多的钱。那一刻，他明显地感受到了女孩的鄙夷。他开始解释。他跟女孩说了自己跟同学一开始都差不多，后来同学个个都比他成功。用他自己的话说，让他看到小西上电视时，那一刻，他清楚地感觉到一种疼痛！他说他一开始也是理想主义者，但现在他希望自己可以像他的同学那样。他说他现在很痛苦，因为没有同学成功。</p><p>小波的解释没有意义，反而更糟。女孩彻底地蔑视他，说他不知足，这点小屁心思真的很没意思。小波欲言又止。</p><p>第二天，跟儿子一起吃饭。他开始想，也许是自己把儿子培养的这么好，居然能够上哈佛了。到时儿子会不会反过来不承认他？会不会去否认他所做的一切？他开始嫉妒儿子了。</p><p>儿子的面试很成功。他们一起去小波的母校塔夫大学参观。小波特意去找大学时代的恩师，却得知他几个月前已经去世了。他居然不知道。</p><p>晚上，他换上了西服，去到跟小西约定的餐厅。服务员把他安排到一个边角位置。他指着大厅中间的一个桌子说，这个是空的。服务员说，是的，但是不可用。过了一会，小西来了，非常精神。服务员把他们领到刚才小波想要的那张桌子那里，请他们落座。小波不甘心地挖苦到，现在这个桌子可用了？服务员说，是的。</p><p>小西说他前几个月参加过恩师的葬礼。小西说小东确实有私人飞机。小西说小北有精神疾病。都是猛料。他试着问小西，问他是不是像自己一样，会有意地跟对方竞争呢？小西说，没有。小波说，一点都没有？小西说，好吧，也许在学校里时有那么一段时间，但之后… … 小西没有说完，但表达得非常清楚。他一点都不把小波认为是竞争对手。小波不想再聊下去了。</p><p>晚上他跟儿子一起去看了哈佛音乐社团的演出，酒吧里认识的那个女孩一个在拉琴，一个在弹琴。他看着她们，听着看着台上的演出。有那么一瞬间，他似乎放下了，放下了与同学竞争落败的焦虑苦闷。就在那一刻，他觉得生活有另一番滋味。为什么呢？</p><p>也许只有放下的人才明白。</p>]]></content>
      
      
      <categories>
          
          <category> 观影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 电影 </tag>
            
            <tag> 中年危机 </tag>
            
            <tag> 电影故事 </tag>
            
            <tag> 你好波拉德 </tag>
            
            <tag> hello brad </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于调试的11个真相</title>
      <link href="/2018/11-truths-of-debugging/"/>
      <url>/2018/11-truths-of-debugging/</url>
      
        <content type="html"><![CDATA[<p>原文来自斯坦福 cs106a 课程的一份讲义。因为翻译能力有限，所以原文也一并贴在下面了。</p><ol><li><p>直觉和预感很好，只是你还得去验证它们。当预感和事实冲突时，事实总是胜出。这就是生活！</p></li><li><p>不要寻找复杂的解释。即使是最简单的疏忽或错别字都会造成非常诡异的行为。认真地看代码，不要想着代码太简单不可能出错，就对简单语句一扫而过。</p><a id="more"></a></li><li><p>代码出问题的线索在你变量的值以及条件语句的流程中。尽力去看事实是怎样的。电脑不会误导你。从事实出发。</p></li><li><p>要有系统性，要坚持不懈。别慌张！Bug 又不会在你的代码里乱动，也不会去欺骗或者躲避你。它只是呆在那个地方，每次都以相同的方式做着错误的事情。</p></li><li><p>如果你的代码一分钟前还好好的，现在却出问题了，那么你最后一次改动了什么？这是条超级可靠的经验法则，也就是为什么你的小组长告诉你代码要边写边测试，而不是到最后一起测试。</p></li><li><p>不要为了追踪 bug 去随意地改动代码。这就好像科学家在做实验时一次性更改了不止一个变量。这会让我们更难解释观察到的行为，而且你可能会引入新的 bug。</p></li><li><p>如果你发现有些代码错误，但是看起来跟你要追踪的 bug 并不相关，也要顺手修复这些代码错误。许多时候错误的代码与 bug 是相关联的或者是以你没有想象到的方式掩盖了bug。</p></li><li><p>你应当能够像福尔摩斯一样解释一系列的事实，测试和最终引导你找到 bug 的推论。而如果有一个 bug 而你又无法定位它，你应当尝试去跟一个认真的第三方论证为什么你的每一个函数不可能有 bug。其中一份论证会有漏洞，因为你的某个函数事实上有 bug。尝试构建论证可能会帮助你发现这个漏洞。</p></li><li><p>对自己代码的信心要有批判心态。当你直觉某个函数是无辜的，那几乎不可能发现这个函数中的 bug。只有当事实证明毫无疑问某个函数不是问题的源头，你才可以假定它是正确的。</p></li><li><p>尽管你需要系统地 debug，但还是会需要信心、预感和猜测等。在你系统性地搜寻 bug 时，用你的直觉去指导搜寻的顺序。先去检查你最怀疑的函数。好的直觉从经验中获得。</p></li><li><p>debug 依靠客观和理性的路径。它依赖对你的代码作用的理解以及全局的合理判断。debug 比写代码还要耗费心智。当你尝试追踪 bug 而无果的时间越长，你会越不能理智判断。当你意识到无法对你的代码 debug 进行理智判断时，休息一下，睡个觉。当你思路不清时你没法 debug。很多时候一个程序员在深夜花费数个小时去定位 bug 却最终在凌晨4点放弃。第二天他们10分钟内就找到了 bug。什么让他们能够在第二天这么快地找到 bug？也许他们只是需要睡眠以及合理判断恢复的时间。或者可能他们的潜意识在他们睡觉的时候想出来了。不管怎样，「去干会别的事情，回来，然后立即找到 bug 」这样的场景太常见，不可能只是意外。</p></li></ol><p>以下是原文：</p><ol><li><p>Intuition and hunches are great—you just have to test them out. When a hunch and a fact collide, the fact wins. That’s life in the city.</p></li><li><p>Don’t look for complex explanations. Even the simplest omission or typo can lead to very weird behavior. Everyone is capable producing extremely simple and obvious errors from<br>time to time. Look at code critically—don’t just sweep your eye over that series of simple statements assuming that they are too simple to be wrong.</p></li><li><p>The clue to what is wrong in your code is in the values of your variables and the flow of<br>control. Try to see what the facts are pointing to. The computer is not trying to mislead<br>you. Work from the facts.</p></li><li><p>Be systematic and persistent. Don’t panic. The bug is not moving around in your code,<br>trying to trick or evade you. It is just sitting in one place, doing the wrong thing in the same<br>way every time.</p></li><li><p>If you code was working a minute ago, but now it doesn’t—what was the last thing you<br>changed? This incredibly reliable rule of thumb is the reason your section leader told you<br>to test your code as you go rather than all at once.</p></li><li><p>Do not change your code haphazardly trying to track down a bug. This is sort of like a<br>scientist who changes more than one variable in an experiment at a time. It makes the<br>observed behavior much more difficult to interpret, and you tend to introduce new bugs.</p></li><li><p>If you find some wrong code that does not seem to be related to the bug you were tracking,<br>fix the wrong code anyway. Many times the wrong code was related to or obscured the bug<br>in a way you had not imagined.</p></li><li><p>You should be able to explain in Sherlock Holmes style the series of facts, tests, and<br>deductions that led you to find a bug. Alternately, if you have a bug but can’t pinpoint it,<br>then you should be able to give an argument to a critical third party detailing why each one<br>of your functions cannot contain the bug. One of these arguments will contain a flaw since<br>one of your functions does in fact contain a bug. Trying to construct the arguments may<br>help you to see the flaw.</p></li><li><p>Be critical of your beliefs about your code. It’s almost impossible to see a bug in a function<br>when your instinct is that the function is innocent. Only when the facts have proven<br>without question that the function is not the source of the problem should you assume it to<br>be correct.</p></li><li><p>Although you need to be systematic, there is still an enormous amount of room for beliefs,<br>hunches, guesses, etc. Use your intuition about where the bug probably is to direct the<br>order that you check things in your systematic search. Check the functions you suspect the<br>most first. Good instincts will come with experience.</p></li><li><p>Debugging depends on an objective and reasoned approach. It depends on overall<br>perspective and understanding of the workings of your code. Debugging code is more<br>mentally demanding than writing code. The longer you try to track down a bug without<br>success, the less perspective you tend to have. Realize when you have lost the perspective<br>on your code to debug. Take a break. Get some sleep. You cannot debug when you are not<br>seeing things clearly. Many times a programmer can spend hours late at night hunting for a<br>bug only to finally give up at 4:00A.M. The next day, they find the bug in 10 minutes. What<br>allowed them to find the bug the next day so quickly? Maybe they just needed some sleep<br>and time for perspective. Or maybe their subconscious figured it out while they were asleep.<br>In any case, the ―go do something else for a while, come back, and find the bug<br>immediately‖ scenario happens too often to be an accident.</p><p>   — Nick Parlante, Stanford University</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调试 </tag>
            
            <tag> debug </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我所知的地方棋牌</title>
      <link href="/2018/an-overview-of-local-board-game/"/>
      <url>/2018/an-overview-of-local-board-game/</url>
      
        <content type="html"><![CDATA[<p>从业内所知的2016年几宗大的地方棋牌收购案之后，地方棋牌开始火爆起来，可以说是遍地开花。由于开发成本低、开发门槛低加上闲徕、乐玩等大的地方棋牌厂商的财富示范效应，在中国二三四线城市出现了无数的地方棋牌公司。而其他行业的老板，眼馋闲徕、乐玩在被收购时漂亮的盈利数据，也纷纷往这方面投资。</p><h2 id="地方棋牌的特征"><a href="#地方棋牌的特征" class="headerlink" title="地方棋牌的特征"></a>地方棋牌的特征</h2><p>经过了2017年一整年的爆炸式发展，棋牌游戏呈现出如下特征：</p><ol><li><p>要活下来不难，要做大不易。</p><p> 针对一个竞争还没那么激励的地级市甚至县级市，做好这个地方的玩法，基本上可以保证团队能够生存下来。但同时，无数的团队在产出地级市、县级、甚至某个更细小地区的玩法，几乎没有哪个地区能够幸免于这种产品泛滥的竞争。</p><p> 与此同时，几乎每个省市都有几个巨头存在。错过了先发优势，要做大的难度很大。</p></li><li><p>竞争激烈，不择手段。</p><p> 地方棋牌在某个市或者某个县直接正面竞争，与以往在线游戏在全国层面的竞争相比，眼前的这个敌人无比明确。于是，不择手段。</p><p> 几乎没有哪家做得好的棋牌没有遭遇过网络攻击。甚至只是在某个地区做得好，你都有可能遭受到其他公司的打击。我甚至见过攻击方不知道你服务器的明确地址所在，就索性把某个区域的服务器全部挨个攻击一遍。</p></li><li><p>产品根据遇到的挑战不断演进。</p><p> 这个是理所当然的，一成不变就是等死。</p><p> 越来的越多的棋牌游戏增加了比赛场模式、增加了俱乐部模式、增加了第三方聊天功能，每个变化都在应对一个具体的问题。</p></li></ol><a id="more"></a><h2 id="地方棋牌的产品形态"><a href="#地方棋牌的产品形态" class="headerlink" title="地方棋牌的产品形态"></a>地方棋牌的产品形态</h2><p>从产品方面来说，地方棋牌主要覆盖了麻将、扑克和桥牌等国内最常见的游戏道具。一些更为地方性的棋牌道具，比如河南的「推饼」用的饼牌等也都有人在做。所以可以说，地方棋牌无所不包，不管你在哪个省、哪个市，玩什么，都能被产品化为一款产品的一个玩法。相对来说，湖南和四川是地方棋牌红海中的红海。</p><p>地方棋牌从闲来游戏开始做房卡模式，就是游戏开房要消耗房卡。一开始，由「代理」低价批发房卡，转售给玩家，代理赚取差价。但现实中的「赌博」群，群主是要抽成的，所以没必要再收房卡钱，于是就有了代开房功能，即群主代理开好房，让别人去打，打完大赢家给钱。代理非要手动去开房不胜其烦，于是市场出现了第三方服务「开房机器人」，在群里的人直接用指令自动开房，不用再劳烦群主代理。再后来，出现了俱乐部模式，凡是加入了俱乐部的玩家，可以自由创建游戏房间，直接扣除俱乐部主人的房卡，俱乐部主人根据俱乐部提供的游戏战绩去找对应的玩家进行结算。现在，俱乐部几乎成了标配。可以看出，地方棋牌在根据现实中的规则去修改自己游戏中的规则，一点点地提高代理的效率，一点点地降低玩家实际买卡的成本（接近于0）。</p><p>地方棋牌除了开房，一般会有匹配场和比赛场，作为开放模式的辅助，一般是用来活跃用户。近来线下比赛越拉越多，通过线下比赛提升品牌，也称为地方棋牌运营的一个方式。</p><h2 id="地方棋牌的运营手法"><a href="#地方棋牌的运营手法" class="headerlink" title="地方棋牌的运营手法"></a>地方棋牌的运营手法</h2><p>翻遍当前市面上主流的地方棋牌，见不到一个在游戏内做大量运营活动的游戏。常见的运营活动有：</p><ul><li>内置抽奖，用于刺激活跃或分享</li><li>内置红包，用于刺激活跃或分享</li><li>内置比赛，用于激励活跃和玩法补充</li><li>内置礼品兑换，用于激励活跃</li><li>公众号活动，因为游戏没有配套运营工具，大部分自发的活动只能手动去进行</li><li>线下比赛，这个有些游戏会专门开发线下比赛的工具，方便合伙人和代理去拓展用户</li></ul><h2 id="地方棋牌的推广体系"><a href="#地方棋牌的推广体系" class="headerlink" title="地方棋牌的推广体系"></a>地方棋牌的推广体系</h2><p>这里的推广方式，主要说下地方棋牌的推广体系。</p><h3 id="闲来模式"><a href="#闲来模式" class="headerlink" title="闲来模式"></a>闲来模式</h3><p>普通玩家，只有拥有一个微信群，就可以成为闲来的代理。代理批发买房卡，有相当的折扣。普通玩家要想拥有房卡，除了游戏内高价购买、自己成为代理，就只能通过代理的二次销售了。</p><p>不确定在普通代理上面，是否有地区总代之类的角色。</p><p>总的来说，闲来模式就是只有一层代理、代理低买高卖。</p><h3 id="提成模式"><a href="#提成模式" class="headerlink" title="提成模式"></a>提成模式</h3><p>玩家，充值成为代理，代理便宜买房卡。同时，代理可以发展下级玩家。下级充值，上级可以拿到提成。一般提成可以拿到二级或三级。代理买到的便宜房卡则通过俱乐部内代开房进行消耗。</p><p>就是说，在提成模式下，代理的收益来自于提成、以及为用户代开房的抽成收益。</p><h3 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h3><p>一般就是在上述两种主要模式之间的混合。</p><p>由于群主代理有抽水收加上拿钻成本低，代理再次销售房卡时的价格会定的极低，造成所谓「乱价」现象。乱价会影响代理整体的利益。同时，相对提成模式，代理少了一部分发展下级用户的动力。</p><p>而提成模式，则主要是有传销和赌博的法律风险。</p><h2 id="地方棋牌的风险和常见问题"><a href="#地方棋牌的风险和常见问题" class="headerlink" title="地方棋牌的风险和常见问题"></a>地方棋牌的风险和常见问题</h2><h3 id="违法违规风险"><a href="#违法违规风险" class="headerlink" title="违法违规风险"></a>违法违规风险</h3><p>做地方棋牌的人都知道，玩家在进行赌博，而且越多人赌博、赌的频繁，他们越挣钱。所以，他们不可能去彻底打击赌博，只能是去表明赌博与他们无关。地方棋牌的运营商会尽可能地撇清与赌博者和赌博组织者的联系。比如，在宣传上，大张旗鼓地宣传赌博违法，违者封号，但实际上，没人真的去做，至多会做做样子。</p><p>但常在河边走哪有不湿鞋，我在公众号上看到两家被公安局端掉的棋牌公司。大家都是游走在灰色地带，一不留神，可能就越界了。这个界，据说就是：不参与代理组局。</p><h3 id="网络攻击风险"><a href="#网络攻击风险" class="headerlink" title="网络攻击风险"></a>网络攻击风险</h3><p>两家棋牌商在一个县城狭路相逢，敌人只有一个且无比具体，不择手段的结果就是：用网络攻击，让它几天无法访问，进而“搞死它”。</p><p>于是一场场的互相的攻防来来往往，只有一旁的阿里云笑呵呵地看着他们互殴，兜售着自己的高防服务器方案。</p><h3 id="微信封号问题"><a href="#微信封号问题" class="headerlink" title="微信封号问题"></a>微信封号问题</h3><p>地方棋牌推广的基础就是微信，如果没有微信，就没有今天的地方棋牌。赌博会给地方棋牌带来利益，但对微信来说，这些全部都是额外的负担：监管负担和法律风险。</p><p>每隔几天，就有代理的账号或群被微信封禁，多半都是微信认为这个账号异常，一般是有频繁的红包行为。</p><p>为了应对微信封号问题，棋牌室也给出了自己的对策：将群或红包转移到别的地方。</p><ol><li><p>自己开发聊天软件</p><p> 开发一个聊天软件并不难，毕竟只给自己用户使用，并不需要高并发。在聊天软件中接入第三方支付红包，同时打通与游戏账号的关联。</p><p> 于是，玩家直接在新聊天软件中开房、结算。</p></li><li><p>接入第三方聊天软件</p><p> 开发一个软件毕竟麻烦，索性直接接入别人的软件。别人的软件需要用户，而棋牌商需要一个微信的替代品。</p><p> 第三方聊天软件可能就没有第三方支付红包这样的功能，但好歹用户可以互相聊天。</p></li><li><p>在游戏中内置聊天功能</p><p> 地方棋牌的俱乐部功能现在成为了标配，有些俱乐部里就可以直接进行聊天。</p></li></ol><h3 id="苹果审核不通过问题"><a href="#苹果审核不通过问题" class="headerlink" title="苹果审核不通过问题"></a>苹果审核不通过问题</h3><p>地方棋牌相对于其他网络游戏，苹果商店的通过率更低。对此，没有特别好的办法，只能是认真阅读苹果审核要点，进行相应的修改。大部分的棋牌游戏，都是用了 lua 语言进行热更新，可以很容易规避一些审核的问题。</p><p>我们自己遇到过的审核问题有：</p><ol><li>定位权限问题：苹果认为我们不需要定位功能，再三沟通也不行。</li><li>支付功能：苹果不允许使用第三方微信支付。</li><li>重复 app 问题：使用两个账号提审同一个包</li><li>基础网络协议问题：最后我们还是从 udp 改成了 tcp</li></ol><h3 id="微信朋友圈分享屏蔽问题"><a href="#微信朋友圈分享屏蔽问题" class="headerlink" title="微信朋友圈分享屏蔽问题"></a>微信朋友圈分享屏蔽问题</h3><p>地方棋牌无一例外，靠游戏内的微信分享去进行裂变。但分享的内容多是一个链接，也有用图片分享的。无论哪种形式，只要分享的人多了，都会被微信屏蔽。之后你再去分享，好友完全看不到。</p><p>对此，我们也没招。我看到闲来已经把所有的游戏内分享改成了分享给好友，不发朋友圈了。</p><h3 id="热更新功能问题"><a href="#热更新功能问题" class="headerlink" title="热更新功能问题"></a>热更新功能问题</h3><p>无一例外，地方棋牌都需要热更新功能，这样可以不用重新提审，就能增加新玩法。如果你的棋牌游戏没有，基本上可以确定这个游戏游戏和开发商是坑。</p><h2 id="地方棋牌使用的第三方服务"><a href="#地方棋牌使用的第三方服务" class="headerlink" title="地方棋牌使用的第三方服务"></a>地方棋牌使用的第三方服务</h2><p>地方棋牌运营过程中难免会用到第三方服务，这些是我们实际用到的。</p><h3 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h3><p>这个自不必说。游戏都需要服务器，现在几乎都是直接买云服务器，没人去自己搭建服务器了。</p><h3 id="苹果企业签名"><a href="#苹果企业签名" class="headerlink" title="苹果企业签名"></a>苹果企业签名</h3><p>如果你的苹果版本没有通过审核，但又需要上线，就只能使用企业签名打包。没有自己的苹果企业账号可以找第三方提供签名打包服务。大概是每款游戏每月300元。</p><h3 id="高防服务器"><a href="#高防服务器" class="headerlink" title="高防服务器"></a>高防服务器</h3><p>网络攻击的频繁使高防服务器成为一个刚性需求。高防服务器，可以承载几百 Gbps 的流量攻击，但价格也相当昂贵。</p><h3 id="红包支付功能"><a href="#红包支付功能" class="headerlink" title="红包支付功能"></a>红包支付功能</h3><p>从游戏内发放红包或者是给代理提现等，需要在网页端或者游戏内实现红包发放和提取功能。这些也都有第三方厂家在提供支持。</p><h3 id="在线客服工具"><a href="#在线客服工具" class="headerlink" title="在线客服工具"></a>在线客服工具</h3><p>直接购买第三方的服务，直接将一个链接集成在游戏内，玩家点击后进入一个网页，跟客服进行交流。这个网页，以及背后的客服后台，直接由第三方提供。当然你要自己写一个，也是可以的。</p><h3 id="代开房机器人"><a href="#代开房机器人" class="headerlink" title="代开房机器人"></a>代开房机器人</h3><p>有些棋牌游戏还没有俱乐部这种自动代开房功能，手动代开房又太费事，于是就有了这种第三方工具的用武之地。按照第三方工具提供的 API 去实现接口，就可以在群里直接发送文本指令开房。开房消耗群主的房卡，同时开完后会自动发送战绩到群里以方便结算。</p><p>我调查的其中一个，是按照每天每群6元收费的。</p><h3 id="软著和版号待办"><a href="#软著和版号待办" class="headerlink" title="软著和版号待办"></a>软著和版号待办</h3><p>这个所有网络游戏都需要的，跟着党走，才有汤喝。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>地方棋牌的神话还在上演，几天前一家浙江的地方棋牌公司又被几十亿收购了。市场上永远不缺乏「别人家的公司」，但实际上自己家的公司呢？苦乐自知吧。</p>]]></content>
      
      
      <categories>
          
          <category> 运营 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏 </tag>
            
            <tag> 地方棋牌 </tag>
            
            <tag> 房卡模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看呐，那个人在玩《王者荣耀》</title>
      <link href="/2017/a-man-playing-wangzherongyao/"/>
      <url>/2017/a-man-playing-wangzherongyao/</url>
      
        <content type="html"><![CDATA[<p>那个人在玩《王者荣耀》。</p><p>他眼睛死死地盯着屏幕，双手死死地握着手机，右手拇指不停地点着屏幕。他不自觉地把伸出了下嘴唇，包住了上嘴唇。他自己都没有意识到他自己的这个习惯。他表情严肃，看不出游戏中的战况如何。</p><p>妻子跟他说了句话，他没有应答，也许“嗯”了一声，也许没有。十个月大的儿子在沙发上爬着玩，看到了他手里发亮的手机，兴奋地爬了过来。他扶着沙发的边缘站起来，兴奋且满怀期望地伸手去抓手机。那个人正打到紧要处，丝毫不敢怠慢。他挪动椅子，转过头去，好让儿子看不到。那小孩子一点也不气馁，他越过沙发边缘爬到了相邻的工作台上。那个人知道这样不安全，趁着等待复活的时间把儿子抱到地上。在地上爬，肯定没啥事，他这么想着。</p><p>妻子要去洗澡，让他看着儿子。他赶紧说，你先等等，等我打完这一局。妻子无奈，继续跟儿子一起玩着。儿子又爬到了沙发上，又伸手来夺手机。他一把将他推倒，儿子倒在沙发上的抱枕堆里，自己翻身，站了起来，又要来拿。妻子看见了，作势对儿子说，来，咱们进里屋吹空调去，别影响你爸。不然一会他打输了，又要发脾气。</p><p>那个人听到这番揶揄的话，并没有任何反应。他当然不会因为打输了就去对亲人发脾气，至少他自己是这么想的。现在，他正忙于一场团战，他正拼命地按着1-2-3和攻击键。现在地方只剩下两个残血的家伙，自己还有大半管血。正好，来个双杀，他心里想。于是他按了技能1，希望能把这俩家伙晕住，然后自己一顿疯狂扫射。不过预判有问题，没有晕到人。敌人没有因为残血就打算撤退，反而丢了一套技能过来。这下不妙。好在闪现还在，他开始后退打算走到墙边，闪现穿墙逃走。可惜他们眼看着就追上来了，一着急直接闪现撞墙，伴随着屏幕上“团灭”的提示，他也回到了等待复活的基地。</p><p>FUUUUUUUUUUUUUCK!他痛苦地喊着，却没有发出声音，只能看到他紧闭的双眼，张大的嘴巴和绷紧的脸。他把手机摔倒了沙发的另一端，用力地握紧拳头砸在新买的工作台上。桌子看起来没事，手也没事，就是有点疼。在等待复活快结束时，他去把手机捡了回来，叹了一口气，继续双手握紧手机拼命点着屏幕。</p><p>妻子在里面叫了他一声，他没听清她说的是什么。妻子又叫了一声，他听清了，是叫他拿一个玩具进去给儿子玩。他没空，右手拇指拼命地点着。操！他骂了一声，他又死了回到基地等待复活。放下手机，他拿了玩具，把它丢到了床上，差一点砸到儿子。妻子赶紧拍拍儿子说，你爸爸又打输了，咱别惹他，来玩玩具吧。</p><p>他心里苦笑，却一刻没停立刻回到了原来的位置，拿起手机继续。在接下来的10分钟里，他又砸桌子1次，双手掰手机一次（我想他肯定不会用到真能把手机败坏的力气），用牙咬沙发一次，咬手一次（只是疼不见血，他知道自己在做什么，应该是吧）。每次发泄之后，他又会叹口气，拿起手机继续。</p><p>最后一波团战，他的2技能成功命中一个残血敌人，拿下击杀，剩下的3个队友，趁机推了地方基地，胜利了。我的作用还是蛮大的，他心里想着，虽然MVP应该不是我。确实不是他，他的评分全队第四，队友给他点了“给力队友”的赞。</p><p>在他脸上出现短暂的放松之后，又开始紧张起来。新的一局开始了。妻子在里屋喊，打完了没有？我还要洗澡呢。</p><p>哦！忘记了！等这局打完！他回复道。</p><p>里屋没有回应。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 王者荣耀 </tag>
            
            <tag> 游戏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>读《寻路中国》</title>
      <link href="/2017/reading-notes-country-driving/"/>
      <url>/2017/reading-notes-country-driving/</url>
      
        <content type="html"><![CDATA[<p>《寻路中国-从乡村到工厂的自驾之旅》，讲述了2001-2007年间作者在中国西北、北京农村以及浙江工厂的见闻。作者彼得海斯勒（中文名：何伟）是一个美国记者，长期住在中国。读他的书，就好像是将自己对中国的视角由第一人称变成了第三人称，借由这个转变，你会看到之前视而不见的东西。</p><p>全书分为三个部分，分别是作者在西部自驾的经历、北京农村居住的经历以及浙江工厂开发区的经历。总体来说，作者并不想刻意地给出一个笼统的结论，来表明自己的观点。他只是作为旁观者去观察，偶尔发表自己的看法，或者用别的方式表达自己的不同意见。</p><p>从另一个角度讲，书的三部分就是中国农村在在过去以及现在的三种归宿。算上书中没有写而现实中发生的，则有4种。</p><p>西北颓败的古长城脚下的村落，地处偏远，中国的城镇化进程绝无可能辐射到的地区，最终的结局只有荒芜。</p><p>北京北郊的三岔村，一开始的迹象跟西北农村一样，全村只有一个小孩儿。因为年轻人都搬去了怀柔或者北京或者去了别的城市打工。但因为北京的发展和汽车的发展，这里成了城市人放松的乡村之旅的目的地。村支书还与某些投资者有一些私下的产权交易。虽然这里还是只有一个小孩儿，但陆续地开通了公路，建起了多个旅馆和饭馆。</p><p>浙江丽水农村，这里则是被规划成了制造业的开发区。政府卖地、从银行贷款、修路，在原本的农村建起了连绵的厂房。老板们来这里制造胸罩扣、钢圈、仿皮、鞋子、打火机、体育用品等。温州这块，本来地就不好种，因此当地的人们头脑活络，倾向于经商。</p><p>最后，就是我们经常在大城市扩张过程中看到的，农村变成了城市的一部分。不过作者没有写到这种情况。</p><p>从这个角度看，作者写的就是中国飞速发展这10年的农村和工厂，以及这其中的人、以及与人有关的东西。</p><p>飞速发展这10年，我刚好是在中学和大学之间。书中讲到的，我很多其实没看到。我没有注意到房价、没有注意到广东和浙江的制造业工厂、没有意识到中国的城镇化。我是两耳不闻窗外事，一心不知在干啥。但是通过作者，一个外国人的描述，我看到的比我自己可能经历过的还要多，他就是有能力让你看到司空见惯之外的事情。比如，作者说到中国教育制度过于强调背诵，尤其是毫无意义的信息，比如顾拜旦哪一年做了什么事情；他冷静地描写了一桌子的男人都在抽烟，旁边的6个月大的小孩儿则快哭了，一个男人拿起筷子蘸了啤酒给孩子去吮吸；他描写了在城市里城市人对打扮老土的农村人的漠视。在打工族在工厂求职时问到工作时间时，作者这样描述老板的回答：”他保证让大家每天有是个小时的活儿干，每个月放假的时间不超过一天。“</p><p>其实，书里面记录的全是小事。正是因为都是小事，既真实又立体。这些小事穿插在当代中国的时代主题里，让经历过和不曾经历过的人，看见了。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 中国 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一晃四个月</title>
      <link href="/2017/how-time-flies/"/>
      <url>/2017/how-time-flies/</url>
      
        <content type="html"><![CDATA[<h2 id="Better-slow-than-never"><a href="#Better-slow-than-never" class="headerlink" title="Better slow than never"></a>Better slow than never</h2><p>四个月前的二三月份，我都仅仅写了一篇博文。四个月后的现在，四五六月完全没有写任何东西。曾经你为懈怠而自责，没想到那竟是你最勤奋状态最好的时候。</p><p>我用iHour记录自己编程的时间。工作期间，看到一个月也才投入了10-12小时，觉得太过懒散，起码每天可以挤出3小时，一个月至少也有将近100小时的投入。现在呢，4-7月没有任何时间投入。</p><p>就好像我前一段时间去跑步，觉得跑得好慢好累，还有时想偷个懒。总觉得那个状态不够好。现在有好几个月没去跑过了。</p><p>所以，当我在做事而觉得自己做的不够好时，反而是我最好的状态。否则，就是完全不做事的状态。</p><p>当你觉得自己做的不够好时，别自责和焦虑，放宽心，因为这代表你还在做事。</p><p>做了总比不做好，好太多。</p><h2 id="关于《王者荣耀》"><a href="#关于《王者荣耀》" class="headerlink" title="关于《王者荣耀》"></a>关于《王者荣耀》</h2><p>几个月前开始尝试《王者荣耀》。同事们天天中午在一起开黑，我起初都不为所动。当我注意到这些同事之前都是几乎没玩过游戏的，我开始尝试这块社交工具。</p><p>到现在，我累积已经卸载过5次了，当然现在手机上也还安装着。</p><p>我打的不好，有时侥幸，有时判断失误，有时不过脑子，有时操作太差，有时缺乏意识。在游戏的过程中，胜率略高于50%，仅此而已。</p><p>在晚上不受打扰的时候，捧着手机，晚上三四个小时，结果排位愣是从黄金4星变成了黄金3星。不是你坑，就是别人坑，或者敌人太狡猾。</p><p>如果每局比赛，都对应一个人的重大事件，那么这个人恐怕早已看透人生。我以为看透了这个游戏后，就会去卸载他。是啊，赢一局输一局，为何？为乐趣？输多赢少，动怒气，伤神伤身，影响家庭（玩游戏时一般不想被打扰），而且还会消耗大量的时间。</p><p>但是，每次卸载后，又都会装回来。或者是忘记了那些痛苦，或者是社交目的，或者是想也许通过练习能够提升水平。或许，是真心觉得好玩，真的喜欢玩，虽然有那么多的不爽。</p><p>我得承认，那些痛苦都是我自己的选择。我可以在被偷袭时候，不去捶墙；我可以在该睡觉的时候放下手机；我可以在该学习的时候，拿起书本；我可以在几局之后稍事游戏；我可以在平时熟悉英雄技能，提升水平。</p><p>我选择了这些痛苦。也许，我可以尝试在面临选择时，选择更为理智的路。我需要这种锻炼。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在中国买房子——读《欧成效文集》</title>
      <link href="/2017/about-real-estate/"/>
      <url>/2017/about-real-estate/</url>
      
        <content type="html"><![CDATA[<p>我是从同学那里获得的《欧成效文集》，是两个pdf文件。在此之前，我从未听说过这个人。作者是上海的一个炒房者，应该是颇有成就，在这个行业内威望颇高。文集里的文章几乎都是以论坛文章的风格写就的，肆意却不够严谨。不过，几乎从未关注过房地产的我，还是大开眼界。</p><p>以下就是《欧成效文集》中的主要观点。</p><ol><li><p>要不要买房？买！</p><p> 国家每年的印钞量惊人，而超发的货币，并没有因此造成物价飞涨，因为这个钞票被房地产吸收了。因此：钱不值钱，必须找到合理的资产去进行保值，而房产是最有效的工具；国家可能还会继续印钞，而有房产者才可以利用房产获得这部分超发货币；房地产还会继续上涨，尤其是超一线城市，据他的计算，上海的房价见顶是在25万一平。</p></li><li><p>政府调控房价会跌么？长期一定会助涨</p><p> 交易产生财富。而举凡增加交易成本的措施，都会降低交易的效率。政府调控，就是人为地设置障碍，增加交易成本，不管是限购、限贷、重税等，最终这些成本都会反映到房价上去。也许房产交易会因为政府干预而暂时冻结，但房产价格不会因此下跌，在稳定一段时间后，房价会报复性上涨。</p><p> 这里有一个所谓”二阶经济学“概念，是说要考虑到对面的反制措施。比如，政府加重税，结果是卖房者不买账，由买房者承担或者直接加到房价里；比如限购限贷，这样可购房的群体变小，那卖房者也不会因此降价，他会一直等到自己满意的价格出现，这时短期看来房价没涨，因为没有成交，但一旦成交量放大，就会发现房价噌噌地涨。</p><p> 而房价在政府不调控也飞涨的原因就是：房子真的值这么多钱。至于为什么一个每年耗损2%的资产会持续增值，还是要回到政府的滥发钞票上去。</p></li><li><p>房价可能会崩盘吗？可能会</p><p> 作者参考香港楼市崩盘的例子，猜测崩盘的话，首年大跌30%，后续2-3年继续叠20%-30%；后面国家就会出来救市，房子起底回升，回到比崩盘前还要高的位置。</p><p> 为了避免崩盘蒙受损失，要尽量买笋盘，避开注定涨幅不足的盘，比如：装修超好溢价超高的豪华楼盘。</p></li><li><p>买房自住要考虑升值吗？要！</p><p> 不管自住还是投资，房产最主要的属性就是金融资产，不升值就是赔钱买卖。</p></li><li><p>买房子的钱从哪里来？借！</p><ul><li>多认识有钱人，直接借；</li><li>信用贷款</li><li>房产二次抵押贷款</li><li>信用卡循环套利</li><li>等等</li></ul></li><li><p>房价是炒房者炒上去的么？不是。</p><ul><li>炒房者并没有想象的那么多</li><li>超一线城市投入几乎整个国家的资源，房价现在是低不是高</li><li>国家大量印钞并引入房地产</li><li>需求</li><li>政府调控加剧或者提前引起了房价的上涨</li></ul></li><li><p>房地产有泡沫吗？有！</p><p> 因此，不要买太远的，不要没有人口净流入城市的，不要买溢价过高的；尽量买笋盘，量力而行。</p></li><li><p>贷款怎么选？选等额本息，选最长还款期的</p><p> 这里说的贷款是商业银行的房贷。因为利息超低还有折扣，因此无论实际情况如何，都可以直接选还款期最长的且使用等额本息方式还款。</p></li></ol><p>这两本pdf没有目录，因此看完后，只能凭印象整理出印象最深的几点，并且跟炒房有关的实际技巧和太繁琐的我都略过了，只写了跟普通购房者相关的一些东西。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 房产 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《CDN技术详解》笔记——CDN是什么</title>
      <link href="/2017/reading-notes-what-is-cdn/"/>
      <url>/2017/reading-notes-what-is-cdn/</url>
      
        <content type="html"><![CDATA[<p>最近粗略地读完了《CDN技术详解》这本书。书中有一部分几乎完全是只看得懂文字而看不懂意思，附录的技术实操部分也直接跳过。尽管如此，读完了还是很有收获，不仅仅对CDN的理解更深了一些，对网络相关的内容如DNS协议、SSL协议等也顺带地了解了一些。</p><p>本文根据该书的阅读笔记整理而成，简要地介绍了CDN的作用、原理和类型等。</p><a id="more"></a><h2 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么"></a>CDN是什么</h2><p>CDN，英文名Content Distribute Network或者Content Delivery Network，中文名内容分发网络。顾名思义，就是协助网络内容的分发。CDN本质上是服务器集群和一套调度系统。通过服务器集群，覆盖更广的用户；通过调度系统分配最合适的服务器给用户访问，从而能够让最广大的用户群体更快地访问到网络内容。</p><h2 id="为什么需要CDN"><a href="#为什么需要CDN" class="headerlink" title="为什么需要CDN"></a>为什么需要CDN</h2><p>网站A的服务器架在广州电信机房，如果没有CDN，全国各地的用户都会直接向这台服务器请求内容，就有可能出现以下几个问题：</p><ol><li>同时访问量大了，网站的服务器性能不足或者带宽不足。</li><li>从较远的物理位置（比如哈尔滨电信）来请求，经过大量中间节点造成延时。</li><li>如果用户不是电信网络，那么可能又会有延迟发生，因为不同宽带运营商互联互通的带宽有限，是经常发生拥堵的地方。</li><li>这种直接访问会占用中心节点带宽，造成拥堵，同样可能会影响体验。</li></ol><p>这些都是体验上的问题，同样还有成本上的考量。假如网站A想要自己动手搭建更多遍布全国的服务器来解决问题的话，成本非常高。除非网站A是流量巨大的网站，否则自建都不划算。</p><p>在CDN出现之前，解决这些问题的办法有：自建服务器集群、镜像技术和缓存技术。而CDN就是缓存技术的发展，可以认为是缓存技术的分布式集群实现。</p><h2 id="CDN的加速原理"><a href="#CDN的加速原理" class="headerlink" title="CDN的加速原理"></a>CDN的加速原理</h2><p>CDN将网站的内容分发到（缓存到）遍布全部各个城市和地区的边缘节点上，同时通过调度系统（负载均衡系统）将不同地区不同运营商的用户合理调度到最适合的边缘节点以及节点内的服务器。</p><p>这样，CDN承载了网站的大部分流量，降低了网站压力；同时利用边缘节点，不走骨干网络减少骨干网络拥堵；而CDN的调度又避开了不同运营商互联互通；大量的分布全国的边缘节点实现了就近访问；同时，网站不需要承载巨量的CDN建设成本，只需要按照带宽付费即可。</p><h3 id="网站接入CDN"><a href="#网站接入CDN" class="headerlink" title="网站接入CDN"></a>网站接入CDN</h3><p>以下是网站接入CDN的典型步骤：</p><ol><li>将需要加速的域名，添加一个由CDN提供的CNAME。这样用户在访问加速域名时，实际上会访问到这个CNAME。</li><li>CNAME在解析时会使用CDN的权威域名服务器。在那里根据DNS，去判断用户的物理位置和运营商情况等，然后返回边缘节点服务器ip客户端。</li><li>客户端再次请求返回的ip，边缘节点服务器由本地负载均衡服务器根据用户请求内容、节点服务器状态等动态因素去判断哪台服务器可以提供服务，通过302重定向到那台服务器。</li></ol><h2 id="CDN的架构"><a href="#CDN的架构" class="headerlink" title="CDN的架构"></a>CDN的架构</h2><p>CDN从组成架构上主要由四个部分组成：分发系统、负载均衡系统、网络管理系统和运营系统。分发系统，就是由各级节点组成；负载均衡系统，就是根据节点情况和用户请求情况按照既定负载均衡策略进行合理调度的系统；网络管理系统，是给运维进行操作，同时也会收集各个节点的信息，为负载均衡系统的运行提供依据；运营系统，则是CDN商业化所需，提供各类查询服务。 </p><p>CDN在以上组成部分中，又有多级架构，即：中心层-区域层-边缘层。每层的每个节点都有对应的分发系统、负载均衡系统和网络管理系统。设置多级架构的初衷是，减少向源站请求的次数。</p><p>CDN的一大作用就是降低源站的压力，尤其是视频网站，因为流量巨大。采用多级架构，则在每个层级都有所请求内容的缓存，如果边缘没有，就去查询区域层，如果有，就取回来；如果区域层也没有，就去中心层；如果中心层也没，就去源站请求，然后缓存在中心层。这种架构可以有效地降低需要去源站请求（回源）的频次。当然了，缓存本身也是有存储成本的，实际也不会把全部内容都缓存，即使缓存也不会每个边缘节点都缓存。这方面会综合性能和成本做平衡的考量。</p><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>负载均衡分为基于四层和基于七层的，基于四层的不了解请求内容，基于七层的可以根据请求内容解析结果更为精准地完成调度。</p><p>负载均衡需要考虑的因素有：</p><ul><li>物理距离（基于本地DNS判断，如果DNS配置错误，则会调度不合理）</li><li>ip地址</li><li>服务器健康状况</li><li>会话保持：相同客户的连贯业务解析到相同服务器</li><li>响应时间</li><li>会话能力阈值</li><li>服务器本身权重：比如费用</li><li>往返时间</li><li>其他信息：比如服务器当前可用会话数，最少选择次数</li></ul><p>基于以上因素，可以有静态策略和动态策略。静态策略是实现就固定的策略，动态策略则会考虑用户请求内容以及服务器状态等因素。一般情况下，会是两类策略的结合。</p><h2 id="CDN加速类型"><a href="#CDN加速类型" class="headerlink" title="CDN加速类型"></a>CDN加速类型</h2><p>CDN加速类型，基本上分为静态内容加速和动态内容加速。静态内容，就是大家访问时看到的都一样，比如视频、图片、网页等；而动态内容，就是不一样的，比如社交网站的时间线、购物网站的搜索结果等动态网页。</p><p>静态内容加速，又分为了：网页加速、流媒体加速、文件传输加速和应用协议加速。应用协议加速，指的是企业应用在局域网和广域网传输的加速，也包括HTTPS的SSL加速。</p><p>不同加速类型的特点不同，所使用的服务器配置也不同，因此一般针对不同加速类型都是配置独立的系统，一般不共用。</p><h3 id="不同加速类型的实现原理"><a href="#不同加速类型的实现原理" class="headerlink" title="不同加速类型的实现原理"></a>不同加速类型的实现原理</h3><p>这里特别要说的是SSL加速和动态加速。</p><p>HTTPS的实现方式要求在请求期间有较大量的计算，因此实现SSL加速一般是通过硬件来实现的。通过在服务器上添加SSL加速版或者将SSL加速板加在专用的SSL加速设备上来实现。</p><p>动态网页，一般包括4个部分：网页表现层（静态）、业务逻辑层、业务数据层、用户数据层。要想实现部分或者全部的动态网页加速的话，就要在边缘节点服务器中复制业务逻辑层来实现“边缘计算”，以及业务数据层和用户数据层。这样，用户在边缘节点就可以完成动态页面的访问。不过，这个方式要注意边缘节点数据库与中心节点的同步与一致。</p><h3 id="流媒体加速原理"><a href="#流媒体加速原理" class="headerlink" title="流媒体加速原理"></a>流媒体加速原理</h3><p>流媒体，分为直播和点播加速。点播的话，基本上是将点播文件切成小块，然后根据实际情况分散缓存到边缘节点。</p><p>直播的话，内容无法提前缓存，在实际请求中，边缘节点会向上级节点去请求然后分发。虽然这个过程中没有了提前缓存带来的效率，但同样可以降低源站的压力，同样可以将用户调度到最合适的节点来提升效率。</p><h2 id="CDN未来的发展"><a href="#CDN未来的发展" class="headerlink" title="CDN未来的发展"></a>CDN未来的发展</h2><p>CDN与云计算在混搭产生新的业务，比如云主机直接搭载CDN服务，比如未云主机服务的CDN等。<br>CDN与P2P技术也可以进行融合，来实现降低成本与提高效率。</p><p>相对于外国的顶尖CDN公司，国内CDN公司的增值较低，基本上就是转卖IDC资源。在CDN行业已成蓝海的情况下，为长尾用户推出特色服务，增加更多服务特色才有服务增值的可能。</p><p>这本书读起来挺难的，里面有很多偏技术的内容，无法理解；还有一些，只能熟悉下相关的名词；好一点的，就是能够理解其表达的逻辑。</p><p>即使是如此，这个依然是CDN行业的必读书，其他介绍CDN的一般性书籍基本上就不用读了。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 工作 </tag>
            
            <tag> CDN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《富爸爸穷爸爸》——从转变观念开始</title>
      <link href="/2017/reading-notes-rich-dad-poor-dad/"/>
      <url>/2017/reading-notes-rich-dad-poor-dad/</url>
      
        <content type="html"><![CDATA[<p>这是一本早就听说过、早就想读、但迟迟没读、直到今天才读完的书。符合这个标准的书，应该还有很多，我会一本一本地补上。</p><p>《富爸爸穷爸爸》是一个系列的书。当我在京东读书APP上搜索“富爸爸”这个关键词时，我发现仅仅是原作者（罗伯特清崎）自己写的就有十几本：</p><a id="more"></a><ul><li>富爸爸穷爸爸</li><li>富爸爸穷爸爸：实践篇</li><li>富爸爸的财务自由之路</li><li>富爸爸点石成金（财商教育版）</li><li>富爸爸富人的阴谋：关于金钱的八条新规则</li><li>富爸爸房地产投资指南</li><li>富爸爸提高你的财商</li><li>富爸爸投资指南</li><li>富爸爸致富需要做的6件事</li><li>富爸爸21世纪的生意</li><li>富爸爸年轻享受生活</li><li>富爸爸商学院</li><li>富爸爸财富大趋势</li><li>富爸爸孩子财商靠父母</li><li>富爸爸发现你孩子的财富基因</li><li>富爸爸不公平的优势：财商教育的力量</li><li>富爸爸我和埃米的富足之路</li><li>富爸爸成功创业的10堂必修课</li><li>富爸爸给你的钱找一份工作</li><li>富爸爸为什么A等生为C等生工作，而B等生为政府工作</li><li>富爸爸现金流游戏   </li><li>富爸爸穷爸爸：漫画版</li><li>富爸爸穷爸爸（少儿猜图版）</li></ul><p>作者在《富爸爸穷爸爸》里说了，他不是一个作家，但他知道如何销售。我想我们肯定没有必要去把整个系列都读了。我猜测后面的书都是对第一本书的补充。</p><p>《富爸爸穷爸爸》本身并没有提供可行的操作步骤，他最大的贡献就是对人观念的影响：对金钱的观念、对工作的观念等。</p><p>全书的核心观点就是这么几条：</p><blockquote><ol><li>工作既不是赚钱的唯一方式，也不是最好的方式。除了工作，你还要有自己的“事业”：即不在场也能产生收入的资产。</li><li>富人购买资产，穷人购买负债。资产带来收入，而负债带走收入。所以，要合理的分配收入，尽可能地购买资产。你花出去的每一分钱，都本可以成为给你带来收入的资产。</li><li>提高财商才能识别投资机会，抓住投资机会。财商这个笼统的概念包含了财务知识、投资知识、市场理解以及法律知识的总和。</li></ol></blockquote><p>书中描述了这样一种被作者称为“老鼠赛跑”的我们感同身受的现象：无论如何存不下钱，挣钱了就去消费，涨工资了就去消费更贵的东西。没钱的人害怕日子过不下去，有钱的人害怕不能维持当前的生活水准。</p><p>如何解决？少支出多买资产，多用脑子，多学习。</p><p>在“老鼠赛跑”的逻辑下，只有降低开支或者有足够多的钱才能最终跳出这个赛道。降低开支是在没钱购买资产时，要降低开支来获取投资的本钱；在有钱时，也要克制购买奢侈品（或非必需品）的冲动，把钱投入到资产上。</p><p>说到底，还是把钱花到能生钱的资产上，让资产带来的收入去提高生活水准。如果还没有购买资产的本钱，少花点，少借钱。同时，不断地提高财商，去了解当前社会上可行的赚钱模式，向有经验的有钱人了解其经验。最后，利用自己掌握的知识和经验去寻找机会并抓住机会。</p><p>虽然书的后两章相对而言是偏实践的，但实际上也并没有提供能够直接可用的策略。从书中或者别人口中去学习赚钱模式，这种模式怕也是昨日黄花了。如何在没钱时获取到投资的钱，如何去寻找便宜的房子，如何去判断某个小公司的股票是否值得购买。这些细节上的实操，作者一概没有提及。只是告诉我们，要我们自己学习知识，去解决这些问题。</p><p>股市上每天都有股票在涨停，但永远不是你买的那只。市场上永远都有赚钱的机会，但你永远不知道它们在哪儿。</p><p>所以，这本书要告诉我们的就是另一种可能性。至于可能性有多大，作者只能说，财商越高，可能性越大。对于新手，我们永远可以从小的简单的做起，去积攒经验。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> 理财 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《余罪1》——连前传都撑不起来的系列第一部</title>
      <link href="/2017/reading-notes-yuzui1/"/>
      <url>/2017/reading-notes-yuzui1/</url>
      
        <content type="html"><![CDATA[<p>在午休时前往老王牛肉面店的路上，我开始阅读这个京东阅读app免费赠送的电子书，毕竟同名网剧在前段时间热过一阵子。</p><p>但这第一部既没有刑侦也没有犯罪，就只是主人公变成主角这条线的一段经历。全书就用一句可以概括：余罪在监狱里喊着“我是警察”，然后剩下的全部都是告诉你他为什么进了监狱。这个开头本身就没有什么吸引力，却要用整本书去铺开。如果这是电影，整个系列就可以不要拍了。事实上如果这是电影，就不可能会被拍出来。</p><p>也许对于作者而言，第一部其实就是第一章，这样算起来也不算太过冗长，同时也就解释得通了。</p><p>整本书唯一出彩的地方，就是在最后，所有人都被安排上车送往监狱，但实际上只有主人公一个人被实际上送进监狱。其他的部分，全都是罗里吧嗦自以为是的blabla。</p><p>最后剧透一下，如果想读第2部，可以直接去读就行了，我反正是不会去读了。</p><p>剧情梗概：<br>领导去警校招精英，警校里垫底的一帮玩得好的兄弟都被秘密招去特训。训练的内容是40天靠自己活下去，过程显出每个人的特质。其中最适合当卧底的主人公被强行送进了监狱以便能过混进去。</p><p>完！</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《岛上书店》——像看电影一样读小说</title>
      <link href="/2017/reading-notes-dao-shang-shu-dian/"/>
      <url>/2017/reading-notes-dao-shang-shu-dian/</url>
      
        <content type="html"><![CDATA[<p>岛上书店的老板，一个中年男人在意外丧妻之后，意志消沉。有一天，一个2岁大的小女孩被遗弃在了他的书店。他决定收养她，于是一切都变了。</p><p>到现在了，还是觉得应该文以载道或者忍不住去想作者想传达什么，但我总结不出来。也许是因为我才读了一遍的缘故。但这本书讲了一个好故事。</p><p>像看电影一样，故事里时不时地就会有事件、冲突以及反转出现。但是同时，这本书在某些时刻会非常地节省，甚至直接几句带过甚至直接就是几年后，让人对某些情节的发展产生疑惑。</p><p>总结来讲，书中的故事是一个非常简单的故事，围绕着书店老板和他收养的女儿从而在时间和空间上展开，让相关的人物在收养前后的时间线上联结起来。</p><p>虽然说读起来还挺带感，但是现在回想起来，排除了书店老板的身份后，这其实是一个挺俗气的故事。所以，根本不能排除书店以及书，这两个是书中人物联结的关键因素。</p><p>有了书这个因素，这个小说中有相当的篇幅其实是在对流行的虚构文学做讨论和评价，当然是以书中人物的口吻。那些书和他们的作者，我大多数都没有听过，因此时不时需要去看书页底部的注释。这本小说的注释挺多，而几乎全部的注释都是在解释某个作者、某本书或某个书中的人物。书店老板最后给我们开了一个书单，这个书单在最后读客二维码公众号上可以获取到。</p><p>我是在每天午休时花20到40分钟来阅读的，刚好读了6天。我很高兴。</p><p>总的来说，这是一个像电影一样讲故事的小说，总有意外和反转。我觉得迟早有一天会被拍成电影的。但关于书中人物命运的联结，我只能是为他们感到高兴或唏嘘，但这种联结是无法预料的，我们只知道某些改变会影响一生，但是怎样的影响呢，我们不知道。</p><p>我们还是继续我们的生活，认真地生活。也许有一天，有一个像岛上书店一样的东西，永远地改变了你。希望这改变是好的。</p>]]></content>
      
      
      <categories>
          
          <category> 读书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017年值得期待的事</title>
      <link href="/2017/good-things-to-expect-in-2017/"/>
      <url>/2017/good-things-to-expect-in-2017/</url>
      
        <content type="html"><![CDATA[<p>2017年，对我来说，有什么值得期待的事情？</p><p>我会拿到驾照，可以租车体验下驾驶的乐趣。</p><p>有多部大片上映，包括《蜘蛛侠》、《正义联盟》、《神奇女侠》等。当然还有美剧《权力的游戏》和《硅谷》。</p><p>孩子应该会说话了吧。</p><p>妈会过来帮忙照看孩子，伙食会好一些。</p><p>发布在苹果商店的第一款应用会是什么样的呢，是否会受欢迎？</p><p>再想不出别的了。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 命题作文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你好，2017</title>
      <link href="/2017/hello-2017/"/>
      <url>/2017/hello-2017/</url>
      
        <content type="html"><![CDATA[<p>这么多年了，定过几次年度计划，或正式或随意。而年度计划中，几乎每次都出现的，就是：读书和健身。读书，活跃大脑、提高认知、增进信心、获得快感。健身，增强身体、提振精神、获得快感。</p><p>但这两项活动，都要花费时间，都会造成一定的痛苦，都不能产生立竿见影的效果。因此，尽管几乎所有人都在理性上认同，却无法真正付诸实施。偶尔付诸实施后带来的快感，会因为中间因为种种理由的搁置而淡忘，只会想起绞尽脑汁的咬文嚼字、和跑步时胸腔和肌肉的疼痛。</p><a id="more"></a><p>与此同时，还有另一项备受推崇的项目：电影。即使是各类牛人，也没有认为电影low或者看电影为不务正业或玩物丧志的。我也喜欢看电影，但与读书和健身不同的事，我想不到，或者说不会第一时间想到做这件事给我带来的好处。在看电影这件事上，我真正做到了打从内心里喜欢。</p><blockquote><p>没有理由的爱，才是真爱。</p></blockquote><p>也许是因为电影这种事情，在让人投入和获得快乐的过程中，较少地产生痛苦吧。如果一上来就去看过去的黑白默片或者大烂片，也许对电影的态度也会变得复杂。</p><p>同时，正是因为不会首先想到做事情的好处，我们会更容易投入。</p><p>那读书和健身，为何不能像看电影一样呢？尝试去减少过程中的痛苦、少去关注实际的收效。比如，在读书和健身的过程中，不要一开始去挑战自己的极限，去读太难或枯燥的书，健身时也不要练得第2天浑身酸痛或者更加害怕健身时身体的感受。</p><p>除了读书和健身的计划之外，我还要继续学习编程和维护博客。为什么要做这两件事呢，他们可不像电影，而更像是读书和健身，过程中有痛苦且见效慢。我的理由是这样的：</p><p>以我当前的工资水平和消费水平，我能在有生之年买到广州市区的房子么？以我当前的能力我能在有生之年获得不凡的成就么？我会衣锦还乡光宗耀祖么？我会有机会移民到美国么？</p><p>不会。静态地看，以上都不会发生。</p><p>这里的静态，指的还不是说我的工资万年不涨，我的能力一直踏步。而是说，我维持当前的工资上涨水平和能力成长情况，以上问题的答案都是“不会”。</p><p>这是一个我不得不接受的现实。接受这个现实，是我能够勇敢地继续生活的前提。如果不能接受自己成为一个普通人，那…那你早干嘛去了？至多可以说，虽然你当前是一个普通的人，但是你心底里有一颗不凡的心。但，还是要承认，普通人的状态是当前以及未来，至少是未来一段时间的状态。</p><p>我的机会就是“突变”。比如，突然我开发的app让我实现了财务自由，突然我的事业有了大的跃进，突然我所在的公司上市我作为主力获得了巨大报酬，我参与了一个牛逼企业的创业，房价暴跌，稳定和忠诚带来回报等等。</p><p>所以，既要接受现实，又要怀抱期待，同时根据自己的理性和兴趣去提升自己，为可能的“突变”做好准备。</p><p>综上，2017年的计划是：</p><ul><li>每月读完一本书，并完成读书笔记。</li><li>每周编程15小时（// 20小时），并发布一款app到应用商店。</li><li>（// 每周运动3次，公园跑步或者家里做Hiit锻炼，）目标是体重降到70kg。</li><li>每月4篇博客文章</li></ul><p>当月未完成，可以在后面补上，不设惩罚。为了能够真正地完成，不对强度和质量做要求；每周和每月进行进度汇总。</p><p>若完成任意一项，则可获得奖励：Kindle Paperwhite一台；<br>若完成全部四项，则可获得奖励：高配版Macbook Pro一台，i7处理器16G内存256G存储15.4寸屏幕。</p><p>2018年1月1日，到时候再来看，我是尴尬地苦笑还是抱着强力的Macbook Pro开心地笑。</p><p>对了，前天刚过往30周岁的生日，我的愿望是：改变。</p><p>后记：<br>文章发布后，我开始去计算为了完成目标，我每周需要耗费的时间。这样算起来，每周需要花费30个小时的空闲时间。算来算去，要能够达成目标，除了坚决的执行力之外，我还需要去把每天中午将近1小时的时间用来读书，然后把健身的3小时节省下来，用骑自行车来上下班来代替健身，毕竟上下班加起来也有15公里以上，可以达到锻炼的目的。</p><p>这样精打细算后，我每周只需要在中午累积读书5小时，下班后和周末去学习编程20小时，抽空写一篇博客就可以了。</p><p>这样就不至于完全没有喘息的空间了，也就真的成为一个可以努力达成的目标。</p><p>再记：<br>经过一周的实践，每周20小时的编程依然是极难达成，而且会因为压力影响到其他方面。因此，考虑到实际情况，将目标降至每周15小时。当周相对目标拖欠的时间，后续可以补上。当周多达成的，不予计算。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有感 </tag>
            
            <tag> 年度计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再见，魔兽世界</title>
      <link href="/2016/a-proper-goodbye-to-wow/"/>
      <url>/2016/a-proper-goodbye-to-wow/</url>
      
        <content type="html"><![CDATA[<p>2005年秋天，我大二。</p><p>我和大学同学一起前往网吧，注册魔兽世界账号，并创建了自己的角色。他的角色是兽人术士，而我则是一个兽人战士。虽然第一次游戏我只进行了2个小时左右，就因为头晕呕吐无法继续，但这却是我魔兽世界生涯的开始。此后我跟他一开始一起白天进网吧玩，到后来我一个人白天进网吧玩，到最后我一个人晚上进网吧通宵玩。到了毕业时，我记得我主要的角色累积纯在线时间超过了200天，就是200*24小时。</p><a id="more"></a><p>当时应该是正处纳克萨玛斯副本开启那段时间前后。我60级的时候虽然混在希利苏斯，但是却没有目睹到安其拉开门的盛况，想来应该是来晚了。虽然，我并不是第一批进入魔兽世界的人，却依然赶上了后来大家一起怀念的60年代，那些经典的任务、经典的副本和经典的装备。</p><p>60级之前我已经记不得什么有趣的事情。记得大约在58级左右时在冬泉谷做任务，单独遭遇了一个联盟玩家的攻击。我已不记得是否获得胜利，只记得激动地手抖。后来的PVP中，不管是战场还是野外PVP，只要是杀的激动，手都会抖。</p><p>60级之后，我加入了一个小公会。当时还没有通关熔火之心。我当时是一个学生，一个不怎么上课也不读书不社交的学生，时间尤其多。我慢慢地在公会里混成了常规团员，跟着一起打副本。在即将开放70级的时候，我们终于在黑翼之巢中开出了AL，我用了我自己攒出来的特权，获得了这把传奇武器。想来，这应该就是我这个角色能达到的顶峰了。</p><p>游戏虽然吸引人，但是不玩游戏且清醒的时候，就会对自己的游戏行为产生抵触，觉得自己在荒掷青春。直到现在，我都没法完全地不带负疚感地长时间玩游戏。总觉得，明明有那么多重要的事情可以做，奈何！就在这样的矛盾情感中，玩的很爽，玩的也很纠结。每天早上从网吧通宵归来时，我都尽量避开正准备去上课的同学，然后进入宿舍，睡到傍晚；然后起床，随便干点啥，到了晚上八九点，出门通宵上网。</p><p>因为这种矛盾和心理的纠结，我有几次AFK，然后我又重新回来。其中的一次，我AFK后把账号交给了游戏里的一个熟人，个把月后他告诉我他把账号分离了，然后把我的主要角色那个战士卖掉了，卖了300元。后来当我重新开始游戏时，这个是我心里最大的痛。虽然我有重新建立了一个兽人战士角色，却无法获得原来的“勇士”军衔，无法获得AL以及其他的寄托。</p><p>几年后，毕业了。我没有工作，没有饭吃，去城里的魔兽工作室做代练。当时国服还是70级，而国外已经是开了80级了。而我代练的就是美服的魔兽，职责就是为客户做任务提升等级。再后来，我在广州有了稳定的工作，买了自己的笔记本，又下载了魔兽世界。</p><p>之后每次开新资料片，我都会回来玩下，做下任务，练满级，打打上一个资料片的副本。但也仅限于此了。</p><p>这样看来，我对魔兽世界的回忆，已经没有具体的东西了。我留下的就是对事实的确认：魔兽世界曾陪伴我相当长的一段时间，而且是在我最宝贵的岁月里。但这段时间里，具体发生了什么，有什么趣事，我是一概记不起来了。所有的青春都是美好的，即使是在虚拟的世界里。</p><p>最新的魔兽资料片我也玩了一周，有一些继续玩的追求，但意愿并不强烈。网易废除点卡那段时间没有提前充值，点卡耗尽了，现在我决定不再充值月卡了。一来是没钱，二来是不愿意让网易得逞。客户端已删，我所缺的就是一个正式的告别。即使我再想起你，我会知道，那是青春赋予的一层抹不去的记忆，然而，we are done.</p><p>再见，魔兽世界！</p><hr><p>附图：大学收获<br><img alt="image" data-src="http://7sbpes.com1.z0.glb.clouddn.com/wowPrepaidCard_%E5%89%AF%E6%9C%AC.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有感 </tag>
            
            <tag> 魔兽世界 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写给2004年春天的你</title>
      <link href="/2016/letter-to-you-of-2004-spring/"/>
      <url>/2016/letter-to-you-of-2004-spring/</url>
      
        <content type="html"><![CDATA[<p>我就是你，2016年冬天的你。</p><p>我突然想找人倾诉，身边没人，就想起了你。</p><a id="more"></a><p>我，未来的你，现在是一个客服。对，不是作家，不是学者，是一个靠学舌去为笨蛋和傻逼们提供服务的傻逼职业。对，我现在可以随意地说出“傻逼”这两个字了，不知道你听到后会不会觉得别扭。当然了，你也许还在因为听到我所从事的职业而在震惊中。我不怪你，也不会笑你。你也别怪你自己。</p><p>你现在成绩还不错，应该也听到过你的朋友真诚地告诉你，“你将来做任何事情应该都没问题的，只要你想做”。不要相信这句话，即使你的朋友和你都无比的真诚。你是可以做任何事情，但你肯定不会真的能够擅长任何事情。因为，你的过去塑造了你的现在，而现在的你，没有时间去擅长所有的事情，仅仅是把手头的事情做好就耗费了你几乎所有的精力。</p><p>你应该还在跟那谁在一起吧。等你大学一开学，你们就差不多分手了。算起来，你俩在一起也就俩月时间。你过于看重你渴望却得不到的东西，以至于一旦得到，忘乎所以。我也有过类似的问题。不要这样子，让人看不起。</p><p>咱们高考考得还不错，但我现在一直觉得志愿填错了。吉林大学所在的东北，整体都在衰落中，而当前的社会，呆在一个不断成长的城市才有更多的机会。都怪咱们当时脑子不好使，也没有高人指点。后面，咱们还会因为脑子不好使而留下更多的遗憾。所以，听妈的话：“长点脑子“。至于怎么长，我现在觉得，保持开放的心态，多读书、多思考、多总结。</p><p>真的不好意思，我带来的都是不怎么好的消息。哦，忘了说了，咱们儿子出生了，有点闹，也有点可爱。其他，真没啥好消息了，顶多是比坏消息好一点的消息。</p><p>咱们大学没咋好好学习，净去网吧上网了。挂科20多门课，毕业证晚了一年多才拿到。毕业了咱也没找到工作了，混得可惨了。当时想着，要是能有一个单间，里面有自己的电脑，这生活也算知足了。咱们在深夜里呐喊，在雪地里狂奔，在熟悉的日常中麻木，偶尔清醒时，痛的不行。</p><p>后来，我们来到了广州，因为曾经的网吧游戏岁月，找了游戏客服的工作，我们也终于有了正式的工作，后来我们就有自己的屋子、自己的电脑——我曾经想要的一切。后来，我想要的更多了。</p><p>好在最难熬的时候过去了。现在我们是比上不足，比下有余。没有房子、车子、存款，也没有狂妄的念想，但还是时不时地会猛砸键盘和鼠标，在愤懑、压抑和顾忌中发出怪异的呐喊，惊醒了沉睡中的儿子，惹来老婆一顿骂。</p><p>咱们娶了一个湖南的女人做老婆，不丑、不白、不高，脾气合得来。所以啊，你要是有机会，可以在大学多发展几个，我当时是没有那个能耐的。</p><p>我知道你现在不怎么学习，一边谈恋爱，一边去上网，还时不时地去质疑下人生的意义，为此弄得自己苦闷不已。我不能说你是在矫情，但你的问题，我现在依然没有明确的答案。但我现在可以带着问题前行，而不是像此时的你和大学时的我们一样，以为这是最重要的问题，没有答案的话，整个人生都不值得一过。说到底，还是蠢。</p><p>很多事情都是不能解决的，很多问题都是没有答案的，至少对于某些人来说，对于你我来说。我们能做的最明智和最诚实的决定，就是承认问题的存在，接受它暂时无解的现实，去做自己想做和该做的事情。它们不是你幸福和智慧的前提，它们有他们存在的逻辑，不要因为你消灭不了它们，就消灭自己的生命力。</p><p>多关心下弟弟，多一起玩玩，一定要让他去上大学，一定记得。</p><p>对了，记得去说服爸妈攒钱买城里的房子啊，以后会疯涨的。</p><p>先到这里吧，下次再聊。</p><p>——2016年冬天的你于广州</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有感 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你的智商不怎么高呀——Gitbook踩坑记</title>
      <link href="/2016/your-iq-not-so-high/"/>
      <url>/2016/your-iq-not-so-high/</url>
      
        <content type="html"><![CDATA[<p>最近在用Gitbook整理工作中的FAQ。这两天遇到了一点Gitbook上的问题，纠结了很久，前后得有整整10个小时吧。Google并没有帮到我，而最后的结果，让我有了这篇文字标题的感受。</p><h2 id="我都做了什么蠢事"><a href="#我都做了什么蠢事" class="headerlink" title="我都做了什么蠢事"></a>我都做了什么蠢事</h2><ol><li><p>Gitbook的book.json配置，同级的不同的配置项之间要用逗号隔开。否则，你会遇到”unexpected string in json”这样的鬼话提示。天知道这是什么意思，而且google也不会告诉你，因为没有其他人会犯这么低级的错误。</p><blockquote><p>如果一个实务问题连谷歌都没有答案，那么一定是你犯了一个很愚蠢的错误，比如：错别字、缺乏基本常识。</p></blockquote><p> 说到常识，不同领域间的常识对新手来说，真的非常不友好的。而网上的各种教程，也大多不是小白来写的，那些真小白会犯的错误，教程的作者恐怕想都想不到。</p><p> 所以，如果真的要接触一个新的领域，像素级的模仿是很好的办法。比如，创建一个Gitbook，可以直接去看别人Gitbook的book.json的配置。</p></li><li><p>Gitbook生成时，一定要指定书籍文档所在的文件夹，否则就会出现类似找不到README.md这样的错误提示。</p><p> 正确的示范：</p> <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接在当前目录生成</span></span><br><span class="line">cd <span class="regexp">/Users/</span>xiaobings<span class="regexp">/GitBook/</span>Library<span class="regexp">/pkuflint/</span>lecloud-faq</span><br><span class="line">gitbook build</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者下面这种指定当前目录的子目录</span></span><br><span class="line">cd <span class="regexp">/Users/</span>xiaobings<span class="regexp">/GitBook/</span>Library/pkuflint</span><br><span class="line">gitbook build ./lecloud-faq</span><br></pre></td></tr></table></figure><p> 错误的示范：</p> <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当前目录中没有书籍时，不能使用build</span></span><br><span class="line">cd <span class="regexp">/Users/</span>xiaobings<span class="regexp">/GitBook/</span>Library/pkuflint</span><br><span class="line">gitbook build</span><br></pre></td></tr></table></figure></li><li><p>Gitbook需要安装插件时，也一定要处在书籍文档所在的文件夹，否则会提示”nothing to install”，与此同时，在你尝试build时，却提示你缺少插件，请运行gitbook install来安装插件。</p><p> 可参考上面的方式。</p></li><li><p>Gitbook的插件如何配置，可以在Plugin Store中，找到该插件，然后点击插件名字右侧的图标链接来跳转到插件的说明页面，上面会显示该插件的配置项和实例代码。</p></li><li><p>Gitbook生成的本地html页面，点击左侧章节是无法跳转的。新版Gitbook就是这样，据说用<code>gitbook build --gitbook=2.6.7</code>，实现用旧版Gitbook生成html，可以实现跳转。但旧版很多插件都不兼容，遂放弃。</p></li><li><p>Gitbook Editor会自动同步<code>_book</code>目录，很烦人。前往gitbook.com在线去编辑.ignore文件，添加<code>_book</code>即可。一般这个是默认添加的，我应该是自己不小心改动了。</p></li><li><p>将website.css里的代码拷贝到pdf.css中，生成的pdf文档依然是没有那些样式。这个没有找到解决方案，放弃。</p></li><li><p>gitbook.com在线编辑书籍，打开页面非常之慢，我在这个点耗尽了我所有的耐心。我的键盘如果被我砸坏了，这个锅要gitbook来背。</p></li></ol><h2 id="冷静一下"><a href="#冷静一下" class="headerlink" title="冷静一下"></a>冷静一下</h2><ul><li>对于不熟悉的领域，尤其是工具类，没事不要折腾。即使寂寞空虚，也还是有别的东西可以聊以排遣，别坑自己。</li><li>事有轻重缓急，不要忘了这个最基本的工作方法论。被琐事绊住时，问下自己：这玩意有必要做么？有必要现在做么？如果答案是否，立即放弃，沉没成本也不要在意了。</li><li>I can do better.</li></ul>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有感 </tag>
            
            <tag> gitbook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客是什么</title>
      <link href="/2016/what-is-blog-for/"/>
      <url>/2016/what-is-blog-for/</url>
      
        <content type="html"><![CDATA[<blockquote><p>The powerful play goes on, and we may contribute a verse.</p></blockquote><p>这是我的博客的副标题，一句来自电影《死亡诗社》中的台词：人生的大幕拉开，我可以贡献一诗篇。</p><p>这本是我对这个博客站点的期许：一个提供价值的地方。</p><p>但实事求是地说，他最大的可能性也仅仅是，对一部分人在特定的时刻有价值。大多数的时候，包括现在，以及近期的将来，博客的文章数量和质量应该都不尽如人意。那么继续写的意义何在？</p><p>有些人的博客，可以为之带来职业生涯的增益，比如之前因为总结运营心得发表在博客而在游戏运营圈知名的小强，我离开游戏圈时他已是西山居的一位运营总监。</p><p>但目前，我的博客主题并不集中，其中与我的职业生涯相关的篇章层次较低，彰显不出自己的实力，倒妥妥地显示出自己没实力。</p><p>以上两项，是我在创建博客之初的美好愿景。那如果在相当长的一段时间，这只是愿景呢？博客还会给我带来什么呢？</p><p>写博客文章，正如某人所言，是一个思考的过程。并不是我们把事情像明白了才能写出来，而是在写的过程中思考还在继续进行，而思考的结果会因为写作的过程而改变。所以，写是思考的一种方式。</p><p>写作对文字的锻炼更不需要多提，如果十年以后，我需要更大的影响力，我的文字要么会成为我的助手要么会成为阻力。</p><p>而博客中的编程相关的总结文章，则相当于一个自己的数据库。都是自己遇到的问题、做过的问题或者学习的笔记，汇总起来，方便自己检索。万一有人需要，当然更好。</p><p>所以，博客文章是自己的思考和自己的经验总结，如果它们能给别人带来帮助或者给自己带来某方面的影响力，当然最好；如果没有，也已经足够好。</p><p>毕竟，我在博客维护和写作中，除了写作能力和业务能力的提升，更重要的是：</p><blockquote><p>博客，是我生活中难得地让我专注和满足的 “好东西”。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再一次折腾博客</title>
      <link href="/2016/i-rebuilt-my-blog-again/"/>
      <url>/2016/i-rebuilt-my-blog-again/</url>
      
        <content type="html"><![CDATA[<p>自打2014年搭建起我的 wordpress 独立博客后，也就累积发了20多篇博文。其中，有翻译的鸡血文，偶尔看书后有读后感，还有生活中经历和感悟。虽然发文很少，但我还是时不时地去加个插件，换个主题。在我无聊的时候，博客有点像购物网站和视频网站，我可以在上面花很多的时间，虽然这时间并不是用于书写。</p><p>在这样的背景下，我早已对我原来的博客主题外观心生怨念：颜色搭配不好、阅读区域太窄。我之前找了不少主题，都是 wordpress 系列的，都不怎么满意。</p><p>机缘巧合，我在搜索别的东西时，看到了别人的博客，布局、颜色搭配都非常满意。于是在那个无聊的时间点，开始再次折腾。</p><h2 id="Jekyll-还是-Hexo？"><a href="#Jekyll-还是-Hexo？" class="headerlink" title="Jekyll 还是 Hexo？"></a>Jekyll 还是 Hexo？</h2><p>区别于 wordpress，jekyll 和 hexo 都是直接把本地的静态文件直接快速生成可浏览的 html 网页，不需要任何后台配置或数据库操作。而且，原生支持 markdown 写作。除此之外，github 的空间是直接支持这两种博客系统的。因此，它们成了程序员的博客系统的上佳之选。</p><p>我的电脑安装 jekyll 遇到了点问题，加上网上说 hexo 的网页生成速度比 jekyll 还要快，于是决定使用 hexo。</p><a id="more"></a><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>我就是靠着这两个关键词“hexo”和“安装”，通过谷歌找到了极为详细的安装教程。感谢教程的制作者！</p><h2 id="主题选择"><a href="#主题选择" class="headerlink" title="主题选择"></a>主题选择</h2><p>又到了这一步了。</p><p>在安装 hexo 的过程中，我就一直在浏览 hexo 官网上可用的主题，我发现了两款满意的：yilia 和 next，尤其是 next，一见倾心。next 的主题制作者，制作了非常精致且详尽的配置教程，全程非常愉悦地完成了基本的设置。</p><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>在 next 教程和网络教程的指引下，继续为博客添加统计阅读数和访客数代码，添加搜索功能、评论功能、打赏功能、404公益页面等。</p><h3 id="一些问题的解决方案"><a href="#一些问题的解决方案" class="headerlink" title="一些问题的解决方案"></a>一些问题的解决方案</h3><p>在我遇到的问题中，有些是网上没有直接答案的，或者答案不完全正确的，这里列出来。</p><h4 id="next-主题-sliderBar-标签页、分类页链接实现"><a href="#next-主题-sliderBar-标签页、分类页链接实现" class="headerlink" title="next 主题 sliderBar 标签页、分类页链接实现"></a>next 主题 sliderBar 标签页、分类页链接实现</h4><p>如果在 menu 中设置了标签页和分类页的显示，这里就不成问题。但是如果你不想在 menu 中显示标签和分类按钮，同时想在 slider 中实现标签和分类的链接，那么就需要做以下的修改。</p><p>在 -themes-next-layout-_macro-slidebar.swig 中，找到这段代码：</p><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> site.categories.length &gt; 0 %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"site-state-item site-state-categories"</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.menu.categories %&#125;</span><span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; url_for(theme.menu.categories) &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-state-item-count"</span>&gt;</span></span><span class="template-variable">&#123;&#123; site.categories.length &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-state-item-name"</span>&gt;</span></span><span class="template-variable">&#123;&#123; __('state.categories') &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  </span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> theme.menu.categories %&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><p>将其修改为：</p><figure class="highlight django"><table><tr><td class="code"><pre><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">if</span></span> site.categories.length &gt; 0 %&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"site-state-item site-state-categories"</span>&gt;</span></span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"</span></span></span><span class="template-variable">&#123;&#123; url_for(theme.menu.categrories + '/categories') &#125;&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-state-item-count"</span>&gt;</span></span><span class="template-variable">&#123;&#123; site.categories.length &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"site-state-item-name"</span>&gt;</span></span><span class="template-variable">&#123;&#123; __('state.categories') &#125;&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml"></span><span class="template-tag">&#123;% <span class="name"><span class="name">endif</span></span> %&#125;</span><span class="xml"></span></span><br></pre></td></tr></table></figure><h4 id="修改代码块的背景色"><a href="#修改代码块的背景色" class="headerlink" title="修改代码块的背景色"></a>修改代码块的背景色</h4><p>只需要在 -themes-next-source-css-_custom-custom.styl 中，添加代码，来补充或覆盖当前的 css 属性。</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">code</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#e8f2fb</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#c9e1f6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">pre</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="number">#e8f2fb</span>;</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#c9e1f6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修改其他-CSS-配置"><a href="#修改其他-CSS-配置" class="headerlink" title="修改其他 CSS 配置"></a>修改其他 CSS 配置</h4><p>打开你的博客页面，然后打开开发者工具（不同浏览器快捷键不一样，比如  Mac Chrome 是 Alt + Option + I）。然后在下方出现的开发者工具中，选中左上角那个箭头符号。</p><p>用这个箭头符号，点击页面上任意的你想修改的位置，就可以在开发工具中看到那个位置对应的 css 参数。</p><p>直接去 -themes-next-source-css-_custom-custom.styl 添加或者修改覆盖现有的参数，就可以了。</p><blockquote><p>虽然这个诀窍对于已经了解的人不值一提，但对于我这种几乎毫无经验的人来讲，已经是像开了新天地一样。</p></blockquote><h3 id="参考网页"><a href="#参考网页" class="headerlink" title="参考网页"></a>参考网页</h3><p>其他的配置，我主要参考以下两个地址，以及谷歌搜索的结果。</p><ul><li><a href="https://neveryu.github.io/" target="_blank" rel="noopener">Never_yu’s Blog</a></li><li><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">Next 主题使用教程</a></li><li><a href="https://github.com/iissnan/hexo-theme-next/issues" target="_blank" rel="noopener">Next 主题 Github Iusses</a></li></ul><p>虽然都说这个主题是烂大街了，但这个却是我见过最好的主题。</p><p>几天折腾下来，仅仅我自己的刷新，都给博客制造了180多个页面访问。</p><p>我觉得，我还会继续折腾下去，毕竟，还有一些想要的效果没有实现呢。说起来，虽然博客没发几篇，代码没写几行，还是蛮开心的。</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 学习笔记——扩展</title>
      <link href="/2016/ios-extension/"/>
      <url>/2016/ios-extension/</url>
      
        <content type="html"><![CDATA[<p>以下是阅读 iOS 官方 Guide 的笔记。</p><h3 id="扩展概述"><a href="#扩展概述" class="headerlink" title="扩展概述"></a>扩展概述</h3><p>扩展（Extension），是我们在通知中心时看到的天气和股票挂件，是我们在点击分享时出现的分享选项，是我们在 iMessage 里发的表情和小游戏。这些都是扩展的实际应用，当然远不止这里提及的几种。</p><p>扩展能做什么，由苹果来规定。苹果事先创建了10几种扩展点，来供开发者选择。扩展点（Extension Point），苹果的官方解释是：扩展的可用系统区域（A system area that enables extensions is called an extension point）。 开发者需要根据自己的实际需求，选择最适合的扩展点。每个扩展，尽量只选择一个扩展点。如果实际需求较复杂，可以创建多个扩展。</p><p>扩展有自己的包名，但不能单独发布，下载主 App 时，会一同下载。主 App 被苹果称为 containing app。</p><p>扩展被调用时，其调用者就是 host app。比如在知乎 app 中分享，微博分享扩展的 host app 就是知乎app，其 containing app 就是微博 app。</p><h3 id="扩展逻辑"><a href="#扩展逻辑" class="headerlink" title="扩展逻辑"></a>扩展逻辑</h3><ul><li>扩展的生命周期独立于其 containing app，即在 containing app 不运行的时候，扩展仍然可以运行。</li><li>host app 发送请求给扩展，扩展回应 host app，一般在回应（执行任务）后会直接终止掉，除非是有后台运行的必要（比如下载）。</li><li>扩展和 containing app 很少通信，但他们有共享的区域（SharedDefaults），可以进行读写。</li></ul><h3 id="扩展设计规范"><a href="#扩展设计规范" class="headerlink" title="扩展设计规范"></a>扩展设计规范</h3><ul><li>快速、流畅、集中在单一任务</li><li>UI 设计要与扩展点的 UI 风格保持协调</li></ul><h3 id="扩展的-API-限制"><a href="#扩展的-API-限制" class="headerlink" title="扩展的 API 限制"></a>扩展的 API 限制</h3><p>某些 API 扩展是不能用的，主要包括如下几类：</p><ul><li><code>sharedApplication</code> 对象相关的所有 API</li><li>写在 <code>NS_EXTENSION_UNAVAILABLE</code> 宏，或者别的类似功能的宏里面的 API</li><li>不能访问摄像头或麦克风（iMessage 扩展除外）</li><li>无法执行长时的后台任务，除了上传和下载扩展点，结束后会通知 containing app 其结果。</li><li>无法通过 airdrop 接收数据，但是可以通过 airdrop 发送数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蜿蜒前行</title>
      <link href="/2016/no-straight-forward/"/>
      <url>/2016/no-straight-forward/</url>
      
        <content type="html"><![CDATA[<p>我一直都很羡慕那些走直线的人，那些知道自己想要什么并能够付诸行动去争取的人。</p><p>大学本科的专业在现实中没什么市场，有人就利用本科和研究生的时间备考注册会计师，以每年通过2门课的速度，顺利拿到的注册会计师证书，获得了硕士学位，进入了知名房地产企业。</p><p>这是身边印象最深刻的例子，而在网络上看到的，以及某个圈子里大牛的事例，更是多不胜数。那些人不仅天资聪慧，而且持之以恒地努力。他们是走直线的人。</p><p>而我走出的路，总是一曲蜿蜒。</p><p>大学里走过的弯路就不说了，年少无知，见识浅薄，不知道也不去追寻更多的可能性。</p><p>到了社会上之后，因为之前的因，没有核心能力，只能是被动地选择。当在这条被动选择的路上，走了相当远的距离后，我有了自己想走的路。而这条路，与我一直在走的路，是两条泾渭分明的路。我知道我天赋一般，不一定能在新的路上走出名堂，但这是我自己审慎思考后的选择，一个更让我心安让我全力以赴的选择。尽管，这是一条太过迂回的路。</p><p>我要减肥，于是连续在Keep打卡28天，每天去跑步或者在家做Hiit有氧锻炼。28天后呢？我瘦了1斤，然后就没有然后了。这是一个近乎圆形的曲线，我都不敢说，它是螺旋上升的。</p><p>我要写博客，于是买了域名、空间搭建了博客。博客写作的曲线是一个连着一个的矮矮的小山丘，山丘之间还有不少平地。</p><p>我要业余时间学习编程，在iHour App上记录自己的学习时长，它的曲线也绝对不是直线，既不是稳稳的横线，也不会稳步上升的斜线，而是一个起伏巨大、有时没有数据的线。</p><blockquote><p>曲线，是我的线条，也是对我来说真实生活的线条。就这样蜿蜒着前进吧，我的底气就是时间。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 有感 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
