<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小兵的诗篇</title>
  
  <subtitle>The powerful play goes on, and we may contribute a verse.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shenxiaobing.com/"/>
  <updated>2019-11-23T01:08:58.821Z</updated>
  <id>http://shenxiaobing.com/</id>
  
  <author>
    <name>小兵</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>初晴 - 有诗意的天气，有温度的诗句</title>
    <link href="http://shenxiaobing.com/2019/chu-qing/"/>
    <id>http://shenxiaobing.com/2019/chu-qing/</id>
    <published>2019-11-22T09:46:59.000Z</published>
    <updated>2019-11-23T01:08:58.821Z</updated>
    
    <content type="html"><![CDATA[<p>最近完成了Flutter的入门课程，使得进行android开发成为了可能。我起初想把我原来的《爱跑》应用重写一遍，研究了几天发现没有适合的能够在后台运行的定位相关插件，所以暂时作罢。flutter在这方面确实还有一些不足，官方给的后台运行的相关指引文章，太过复杂和不切重点了。</p><p>接下来确定参考iOS端的《雨时》这款app做一个拷贝版本。一两年前最初学iOS时就想做这个，最后没有完成。现在使用Flutter用了一周时间完成了基础功能，命名为《初晴》。</p><p>这个应用就是调用了3个API来实现获取天气数据，获取随机诗词，获取随机一句话功能。界面如下。</p><img style="zoom:50%;" data-src="chu-qing/Screenshot_2019-11-15-15-24-56-108_com.shenxiaobing.sunny_flutter.jpg"><img style="zoom:50%;" data-src="Screenshot_2019-11-15-15-25-11-812_com.shenxiaobing.sunny_flutter.jpg"><p>因为调用的都是免费API，所以不太好大面积传播。所以我只想传到google play商店和iOS付费版。但iOS审核被拒，应用太过简单，仅仅是聚合了网络内容。所以，作罢。</p><p>我上传到了百度云，有喜欢的可以直接下载使用。安卓下载地址如下：</p><blockquote><p>链接:<a href="https://pan.baidu.com/s/1jESY3211-vo7X1FzhGYLww" target="_blank" rel="noopener">https://pan.baidu.com/s/1jESY3211-vo7X1FzhGYLww</a>  密码:lmfs</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近完成了Flutter的入门课程，使得进行android开发成为了可能。我起初想把我原来的《爱跑》应用重写一遍，研究了几天发现没有适合的能够在后台运行的定位相关插件，所以暂时作罢。flutter在这方面确实还有一些不足，官方给的后台运行的相关指引文章，太过复杂和不切重点了
      
    
    </summary>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/categories/programming/"/>
    
    
  </entry>
  
  <entry>
    <title>零基础自学编程有多难</title>
    <link href="http://shenxiaobing.com/2019/how-hard-is-self-taught-programming/"/>
    <id>http://shenxiaobing.com/2019/how-hard-is-self-taught-programming/</id>
    <published>2019-10-12T20:16:59.000Z</published>
    <updated>2019-10-12T20:24:32.060Z</updated>
    
    <content type="html"><![CDATA[<p>一个零基础的文科生学编程有多难？为什么单把文科生拎出来，这里不是歧视文科生，只是想强调过往没有任何的编程和计算机基础这一点，而大多数理工科的毕业生多少都有一点基础。</p><p>我到现在都不能说自己是个程序员，但我自认为有足够曲折的编程自学经历来现身说法。</p><a id="more"></a><h2 id="第一难：学什么语言"><a href="#第一难：学什么语言" class="headerlink" title="第一难：学什么语言"></a>第一难：学什么语言</h2><p>6年前的春天，我买了第一本编程书，一本C语言的书，得有4厘米厚，京东畅销书。这可能是任何一个自学编程的人能做出的最差的选择。然而，我不知道是听信了谁的鬼话，也不记得为何没有进行网上搜索，也许那时还没养成搜索的习惯。</p><p>C语言公认的难学、难用，用途比较单一，大概只有毕业没多久理工科生的才会带着学校课程表的惯性给新手推荐先学C语言。</p><p>正确答案是：Java、Python、JavaScript，随便选一个吧。</p><h2 id="第二难：选择什么教程"><a href="#第二难：选择什么教程" class="headerlink" title="第二难：选择什么教程"></a>第二难：选择什么教程</h2><p>上面说我学编程的第一步是买书。这是我犯的第二个错误。书籍中的内容更新滞后，远远比不上现代的编程语言。书籍的内容偏重理论，而编程是一个注重实操的手艺。而且不是每个人都适合跟着书学习，视频的互动更强一些。书不会照顾一个新手，而视频课程的设计者会考虑新手的学习曲线，会把教学和练习相结合，会根据编程学习的特点强调实践。另外，编程书一般都非常厚，里面不是文字就是代码，真的让人望而却步，尤其是对于战战兢兢的新手来说。</p><p>正确的选择是：靠谱的视频课程，推荐Udemy这种大平台的热门课程。不要选大学课程，那也是偏理论的。</p><h2 id="第三难：如何面对报错"><a href="#第三难：如何面对报错" class="headerlink" title="第三难：如何面对报错"></a>第三难：如何面对报错</h2><p>我已记不清有多少次了，百度我的报错文本根本没有结果。为什么？因为没有人出过这个报错。只有我，只有纯新手，才会因为种种奇葩的原因，发现全新的报错。而根据我的经验，这个报错的原因一般是一个低级错误。</p><p>前两天，Xcode就无法预览某一个View。我有什么办法？没办法，我跳过了。</p><p>我觉得对于无关紧要的问题或者报错，一个核心态度就是打不过就跑，认怂。不要在上面浪费无谓的时间和精气。同理，对于那些一时不能理解和掌握的概念，留给时间，留给后面的学习。</p><h2 id="第四难：如何练习"><a href="#第四难：如何练习" class="headerlink" title="第四难：如何练习"></a>第四难：如何练习</h2><p>初学编程时，我以为练习就是要去<code>codewars</code>这样的网站完成一个个小任务，一个个代码片段，对基本的编程语法做练习。</p><p>但这样的练习做一万遍，还是徒劳。正确的做法是以项目为导向。练习一开始的目标就是完成一个项目。项目可大可小，但项目有明确的用途。在完成项目的过程中，你会学习从整体看问题，会学习试着解决任何一个出现的小问题。</p><p>正确的做法：从项目学习，用项目练习。</p><h2 id="第五难：如何坚持"><a href="#第五难：如何坚持" class="headerlink" title="第五难：如何坚持"></a>第五难：如何坚持</h2><p>对于新手来说，很多概念都是闻所未闻的。每一个闻所未闻的概念，都是似懂非懂的。就是这种似懂非懂的状态下，持续往下学习。累积的似懂非懂越多，就越心虚，越决定自己不行。</p><p>同时，越深入学习，越觉得编程中有太多的细枝末节需要考虑，太多的库需要学习，太多的弱点需要强化。胡适会说，进一寸就进一寸的欢喜。但霸王别姬里的小豆子，却哭着喊“这得挨多少打啊”。不是所有人都能面对重压。</p><p>对自己的怀疑，加上对编程学习本身的质疑，放弃真是一个诱人的选择。</p><p>这里的建议是，不要对自己太苛求。累了就休息，休息好了就继续。别有完美情结。</p><h2 id="第六难：学习编程为什么"><a href="#第六难：学习编程为什么" class="headerlink" title="第六难：学习编程为什么"></a>第六难：学习编程为什么</h2><p>千辛万苦学会了一门编程语言，做了一两个小项目。然后呢？转行基本没门。本职工作好像也不怎么用得上。那这个新学的手艺就撂这儿啦？只要3个月不写代码，再捡起来就又得重新复习那些本就基础不牢的语法。捡起来后也还是不知道能拿这个来干什么。</p><p>所以，如果你想能够持续地学下去，你得知道自己想用编程做什么。仅仅是喜欢？这是一个不错的答案。不管什么答案，都一定会有一个与之匹配的结局，种瓜得瓜种豆得豆而已。</p><p>祝你学有所得，学有所成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个零基础的文科生学编程有多难？为什么单把文科生拎出来，这里不是歧视文科生，只是想强调过往没有任何的编程和计算机基础这一点，而大多数理工科的毕业生多少都有一点基础。&lt;/p&gt;
&lt;p&gt;我到现在都不能说自己是个程序员，但我自认为有足够曲折的编程自学经历来现身说法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://shenxiaobing.com/categories/essay/"/>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="自学" scheme="http://shenxiaobing.com/tags/%E8%87%AA%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>换电脑时如何正确地迁移Hexo博客</title>
    <link href="http://shenxiaobing.com/2019/how-to-migrate-hexo-properly/"/>
    <id>http://shenxiaobing.com/2019/how-to-migrate-hexo-properly/</id>
    <published>2019-10-12T10:51:54.000Z</published>
    <updated>2019-10-12T11:41:43.401Z</updated>
    
    <content type="html"><![CDATA[<p>一句话，不要保留旧电脑hexo博客文件夹中的<code>package.json</code>文件。百度搜到的迁移教程，整体步骤没错，就是这一条，非常有误导性，如果保留下来可能会导致奇怪的报错。</p><p>下面是我验证有效的迁移步骤。</p><a id="more"></a><h2 id="保存旧数据"><a href="#保存旧数据" class="headerlink" title="保存旧数据"></a>保存旧数据</h2><p>从旧电脑的博客目录中，拷贝保存以下文件或文件夹：</p><ol><li>站点配置文件<code>_config.yml</code></li><li><code>source</code>文件夹</li><li><code>scaffolds</code>文件夹，如果你没有改过这里，其实也不用保存</li><li><code>themes</code>文件夹视情况保存，如果你没改过，或者像我一样主题的自定义配置都写在了站点的<code>/source/_data</code>里面，这里也不用保存，到时重新下载。</li></ol><h2 id="安装必备模块"><a href="#安装必备模块" class="headerlink" title="安装必备模块"></a>安装必备模块</h2><ol><li>安装Git：官网下载安装包安装。</li><li>安装Node：官网下载安装包安装。</li><li>安装Hexo：命令行运行<code>npm install -g hexo-cli</code></li></ol><h2 id="初始化博客目录"><a href="#初始化博客目录" class="headerlink" title="初始化博客目录"></a>初始化博客目录</h2><ol><li>创建博客目录，然后cd到该文件夹</li><li>初始化博客目录：<code>hexo init</code>，必须是一个空文件夹。</li><li>安装deploy插件：<code>npm install hexo-deployer-git --save</code></li></ol><h2 id="替换旧数据"><a href="#替换旧数据" class="headerlink" title="替换旧数据"></a>替换旧数据</h2><p>这个直接替换同名文件和文件夹，覆盖即可。</p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>我迁移前没保留主题，这里需要重新下载我用的主题<code>next</code>。先cd到博客主目录，然后执行下面的命令。</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/theme-<span class="keyword">next</span>/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure><p>我的主题的自定义配置，是另外创建了一个名为<code>next.yml</code>的文件保存在站点目录<code>/source/_data</code>文件夹中（如果<code>_data</code>文件夹不存在，可以手动创建一个）。这样我可以直接升级主题，而不用担心配置冲突。</p><h2 id="按需安装插件"><a href="#按需安装插件" class="headerlink" title="按需安装插件"></a>按需安装插件</h2><ul><li>Local Search：<code>npm install generator-search --save</code></li><li>Rss生成：<code>npm install hexo-generator-feed --save</code></li><li>Sitemap生成：<code>hexo-generator-sitemap --save</code></li></ul><p>如果运气好，网速快，15分钟就可以搞定。如果你运气不好，像我一样，又被教程误导，那可能要浪费一个下午的宝贵时光。</p><p>祝你好运！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一句话，不要保留旧电脑hexo博客文件夹中的&lt;code&gt;package.json&lt;/code&gt;文件。百度搜到的迁移教程，整体步骤没错，就是这一条，非常有误导性，如果保留下来可能会导致奇怪的报错。&lt;/p&gt;
&lt;p&gt;下面是我验证有效的迁移步骤。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://shenxiaobing.com/categories/essay/"/>
    
    
      <category term="博客" scheme="http://shenxiaobing.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="hexo" scheme="http://shenxiaobing.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Python正则表达式CheatSheet</title>
    <link href="http://shenxiaobing.com/2019/python-regular-expression-cheatsheet/"/>
    <id>http://shenxiaobing.com/2019/python-regular-expression-cheatsheet/</id>
    <published>2019-09-05T02:14:44.000Z</published>
    <updated>2019-09-05T03:29:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>这里是正则表达式常用表示法与函数，以备查询。</p><a id="more"></a><h2 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h2><h3 id="普通符号"><a href="#普通符号" class="headerlink" title="普通符号"></a>普通符号</h3><table><thead><tr><th>表示法</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>.</td><td>匹配任意字符，\n除外</td><td>b.b，表示以b开头以b结尾的任意字符串</td></tr><tr><td>\d</td><td>匹配0-9的数字字符</td><td>\d{3}，表示3个数字</td></tr><tr><td>\w</td><td>匹配任意字母数字下划线字符</td><td>\w+，至少一个字母数字下划线组合</td></tr><tr><td>\s</td><td>匹配任何空格，与[\n\t\r\v\f]相同</td><td>\s\s+，至少2个空格</td></tr><tr><td>[…]</td><td>匹配括号内字符集的任意单一字符</td><td>[aeiou]，匹配aeiou这5个字符中的一个</td></tr><tr><td>[x-y]</td><td>匹配x~y之间任意字符</td><td>[0-9]，匹配0-9这10个数字，同\d</td></tr><tr><td>\N</td><td>匹配已保存的子组，N是子组的序号</td><td>\2，表示已匹配的第2个子组</td></tr><tr><td>\c</td><td>c是一个特殊字符，匹配非转义的字符</td><td>\, \*</td></tr><tr><td>literal</td><td>表示字面值</td><td>输入什么，就匹配什么</td></tr><tr><td>\D</td><td>与\d相反，匹配非数字</td><td></td></tr><tr><td>\W</td><td>与\w相反，匹配非字母数字下划线</td><td></td></tr><tr><td>\S</td><td>与\s相反，匹配非空格</td><td></td></tr></tbody></table><h3 id="辅助符号"><a href="#辅助符号" class="headerlink" title="辅助符号"></a>辅助符号</h3><table><thead><tr><th>表示法</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>*</td><td>匹配0次或多次，默认贪婪</td><td></td></tr><tr><td>+</td><td>匹配1次或多次，默认贪婪</td><td></td></tr><tr><td>?</td><td>匹配0次或1次，默认贪婪</td><td></td></tr><tr><td>{N}</td><td>匹配N次</td><td></td></tr><tr><td>{M, N}</td><td>匹配M~N次，默认贪婪</td><td></td></tr><tr><td>?</td><td>在上述符号后面，加上?，转为非贪婪</td><td></td></tr><tr><td>&#124;</td><td>表示或，用在两个表达式之间</td><td></td></tr><tr><td>^（或者\A）</td><td>匹配字符串起始部分</td><td></td></tr><tr><td>$（或者\Z）</td><td>匹配字符串结束部分</td><td></td></tr><tr><td>[^…]</td><td>不匹配字符集内的字符</td><td></td></tr><tr><td>\b</td><td>表示在字符串边界，即开始或结尾</td><td>\bthe，表示以the开头字符串；\bthe\b，表示the</td></tr><tr><td>\B</td><td>与\b相反，表示不在边界</td><td>\Bthe，表示字符串不以the开头</td></tr></tbody></table><h3 id="扩展符号"><a href="#扩展符号" class="headerlink" title="扩展符号"></a>扩展符号</h3><table><thead><tr><th>表示法</th><th>描述</th></tr></thead><tbody><tr><td>?iLmsux</td><td>加入特殊标记</td></tr><tr><td>(?:…)</td><td>括号内的匹配不分组</td></tr><tr><td>(?=…)</td><td>匹配…出现在之后的位置</td></tr><tr><td>(?!…)</td><td>匹配…不出现在之后的位置</td></tr><tr><td>(?&lt;=…)</td><td>匹配…出现在之前的位置</td></tr><tr><td>(?&lt;!…)</td><td>匹配…不出现在之前的位置</td></tr><tr><td>(?(id/name)Y/N)</td><td>如果id或name对应的分组存在，则返回Y，否则返回N</td></tr><tr><td>(?P<name>…)</name></td><td>由name标识而不是数字id标识的分组匹配</td></tr><tr><td>(?P=name)</td><td>在同一个字符串中匹配由(?P<name>)分组的文本</name></td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>match(pattern, string, flags=0)</td><td>从字符串起始位置，匹配1次，起始必须匹配</td></tr><tr><td>search</td><td>从字符串左侧开始，匹配1次，起始不必匹配</td></tr><tr><td>findall</td><td>查找所有匹配，返回列表</td></tr><tr><td>finditer</td><td>查找所有匹配，返回迭代器</td></tr><tr><td>split(pattern, string, max=0)</td><td>返回根据pattern分割后字符串列表，默认分割max次</td></tr><tr><td>sub(pattern, repl, string, count=0)</td><td>替换所有匹配pattern并返回新字符串，默认替换无数次</td></tr><tr><td>groups</td><td>返回包括所有匹配子组的元组，若无匹配，则为空元组</td></tr><tr><td>group(num=0)</td><td>返回指定序号的子组，若编号为0，则返回整个匹配</td></tr></tbody></table><h3 id="常用模块属性"><a href="#常用模块属性" class="headerlink" title="常用模块属性"></a>常用模块属性</h3><table><thead><tr><th>模块属性</th><th>描述</th></tr></thead><tbody><tr><td>re.I, re.IGNORECASE</td><td>不区分大小写</td></tr><tr><td>re.L, re.LOCALE</td><td>根据使用的本地语言环境通过\w \W \b \B \s \S实现匹配</td></tr><tr><td>re.M, re.MULTILINE</td><td>^ $ 分别匹配目标字符串每行的起始和结尾</td></tr><tr><td>re.S, re.DOTALL</td><td>.点号可以匹配\n</td></tr><tr><td>re.X, re.VERBOSE</td><td>允许忽略字符串中换行符和注释段落，增强可读性</td></tr></tbody></table><h3 id="函数调用示例"><a href="#函数调用示例" class="headerlink" title="函数调用示例"></a>函数调用示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 增加(?i)使匹配忽略大小写</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r'(?i)yes'</span>, <span class="string">'yes? Yes. YES!'</span>)  </span><br><span class="line">[<span class="string">'yes'</span>, <span class="string">'Yes'</span>, <span class="string">'YES'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加(?im)表示匹配忽略大小写，^$从每行开始和结束匹配。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">r'(?im)(^th[\w ]+)'</span>, <span class="string">""" </span></span><br><span class="line"><span class="string"><span class="meta">... </span>This line is the first,</span></span><br><span class="line"><span class="string"><span class="meta">... </span>another line,</span></span><br><span class="line"><span class="string"><span class="meta">... </span>that line, it's the best.</span></span><br><span class="line"><span class="string"><span class="meta">... </span>"""</span>)</span><br><span class="line">[<span class="string">'This line is the first'</span>, <span class="string">'that line'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ?:使用表示不分组，?(1)表示判断分组1是否存在</span></span><br><span class="line"><span class="comment"># (?:(x)|y)，表示x或者y，但x是一个子组，整体却不是。即如果匹配到x，x是一个子组；匹配到y，y不是子组。</span></span><br><span class="line"><span class="comment"># (?(1)y|x)，表示匹配到的第一个子组如果存在，即x存在，那么下一个应该是y；若不存在，下一个则是x。</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pattern = <span class="string">r'(?:(x)|y)(?(1)y|x)'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(re.search(pattern, <span class="string">'xy'</span>))</span><br><span class="line"><span class="meta">... </span><span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这里是正则表达式常用表示法与函数，以备查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/categories/programming/"/>
    
    
      <category term="python" scheme="http://shenxiaobing.com/tags/python/"/>
    
      <category term="正则表达式" scheme="http://shenxiaobing.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="cheatsheet" scheme="http://shenxiaobing.com/tags/cheatsheet/"/>
    
      <category term="regular expression" scheme="http://shenxiaobing.com/tags/regular-expression/"/>
    
  </entry>
  
  <entry>
    <title>我为什么不玩魔兽世界怀旧服</title>
    <link href="http://shenxiaobing.com/2019/say-no-to-wow-nostalgia-server/"/>
    <id>http://shenxiaobing.com/2019/say-no-to-wow-nostalgia-server/</id>
    <published>2019-09-03T12:20:00.000Z</published>
    <updated>2019-09-03T12:57:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>魔兽世界怀旧服开了，据说有的服务器排队时间高达5个小时。我兴味索然，虽然我从大二就开始玩魔兽世界，玩得疯的时候每天玩十个多小时，厌倦的时候又很久不上线。不管AFK多久，出了新版本总是想回来看看。</p><p>但怀旧服是个例外，我不想玩。</p><a id="more"></a><p>怀旧服几乎不提供任何新的游戏体验。它只是把原有的游戏体验变得更糟或者更好。怀旧服的练级体验，装备获取体验，两点之间的移动体验都比现在更糟。我丝毫不觉得用大量时间升级很有趣，不觉得费半天劲得一件蓝装很有趣，也不觉得一步一步从这个地图跑到另一个地图很有趣。尤其是当我见识过体验过更便捷的升级、更好的装备、更快的速度，我为什么要骗自己慢下来更好呢？而且我在普通服里练过十几个号，真心不想再重复那个过程：相同的地图、相同的任务、相同的副本。</p><p>即使我一时昏头，加入了怀旧服，接受怀旧服的新规则。我会花费时间跑路、升级、获取装备，然后呢？魔兽世界当年有句名言：满级才是游戏的开始。满级之后，我能玩的就是打副本、打战场、野外pvp。看到了吧，依然是旧的东西，依然是普通服里唾手可得的东西。</p><p>就算我能坚持下去，一直玩下去。但怀旧服版本就像任何的游戏一样，每个版本都有其生命周期。生命到了后期，人人都想要新东西，用户活跃大幅下滑。于是燃烧远征怀旧服开启，燃烧远征之后呢？</p><p>怀旧服从头到脚没有一丝新意，如果说有，也是在游戏营销上开创了炒冷饭的花样。怀旧服没有提供新的内容，却有比当前版本更差的游戏体验，最重要的是怀旧服最终将因为生命周期的规律不得不继续更新。一个持续更新的怀旧服，跟普通服还有区别吗？一定要眼睁睁地看着怀旧服更新到军团再临再能明白？</p><p>怀旧服，一个营销的花把式，一个低成本的试水之作，一个在游戏末期收割玩家的套路。</p><blockquote><p>客官，快来呀，只要75元就能回到那年夏天，回到大学校园，回到记忆中那绯红色的青春时代。</p></blockquote><p>啊，呸！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;魔兽世界怀旧服开了，据说有的服务器排队时间高达5个小时。我兴味索然，虽然我从大二就开始玩魔兽世界，玩得疯的时候每天玩十个多小时，厌倦的时候又很久不上线。不管AFK多久，出了新版本总是想回来看看。&lt;/p&gt;
&lt;p&gt;但怀旧服是个例外，我不想玩。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://shenxiaobing.com/categories/essay/"/>
    
    
      <category term="魔兽世界" scheme="http://shenxiaobing.com/tags/%E9%AD%94%E5%85%BD%E4%B8%96%E7%95%8C/"/>
    
      <category term="怀旧服" scheme="http://shenxiaobing.com/tags/%E6%80%80%E6%97%A7%E6%9C%8D/"/>
    
  </entry>
  
  <entry>
    <title>如何用 Python 生成带 Logo 二维码</title>
    <link href="http://shenxiaobing.com/2018/make-qr-with-logo-in-python/"/>
    <id>http://shenxiaobing.com/2018/make-qr-with-logo-in-python/</id>
    <published>2018-11-09T07:21:41.000Z</published>
    <updated>2019-08-29T03:45:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>如何用 Python 生成像微信名片那样的中间带有 Logo 的二维码？使用 Python 的qrcode模块可以很容易做到。</p><p>首先，import 所需的模块。完成工作，需要 <code>qrcode</code>和<code>PIL</code>模块。安装这些模块的方法可以自行百度。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> qrcode</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageFont, ImageDraw</span><br></pre></td></tr></table></figure><p>接着，生成二维码。二维码仅至少接收一个文本参数。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_qrcode</span><span class="params">(text)</span>:</span></span><br><span class="line">    qr = qrcode.QRCode(version=<span class="number">10</span>, </span><br><span class="line">    error_correction=qrcode.constants.ERROR_CORRECT_H,</span><br><span class="line">    box_size=<span class="number">8</span>,border=<span class="number">4</span>)</span><br><span class="line">    qr.add_data(text)</span><br><span class="line">    qr.make(fit=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> qr.make_image(fill_color=<span class="string">"black"</span>, back_color=<span class="string">"white"</span>)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>version，通俗来说，用于控制二维码的尺寸。version=1时，二维码包含21个块，其后 version 每增加1，二维码块数增加4。因此，version=10包含21+4*9=57个块。每个块的实际像素，由下面的参数 box_size 决定。</li><li>error_correction，即容错率，按照「草料二维码」的建议，应当选择30%，这个比例下最容易被各种设备识别，也就是常量<code>qrcode.constants.ERROR_CORRECT_H</code>。其他的常量还有：<ul><li>ERROR_CORRECT_L，大约7%容错；</li><li>ERROR_CORRECT_M，大约15%容错，默认值；</li><li>ERROR_CORRECT_Q，大约25%容错率。</li></ul></li><li>box_size，即每个块的占据的像素数，8就是8像素。</li><li>border，即二维码区域在边缘的留白，数字是块数，比如border=4即4块，也就是是4*8=32像素的留白，默认是4，建议最小值也是4，不过可以根据实际情况调整。</li><li>整体上，生成二维码实际大小这么算。（version 块数 + border 块数）* box_size，因此以上参数实际会生成（57 + 4）* 8 = 488像素大小的正方形。</li><li>最后 make_image 方法中的参数，可以根据实际需要调整，默认值就是白底黑色二维码。</li></ul><p>二维码生成了，下一步就是往二维码上添加 Logo。</p><a id="more"></a><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将logo添加到二维码中间，logo的尺寸为二维码的1/4，且居中显示；</span></span><br><span class="line"><span class="comment"># 同时为了美观，logo与二维码中间会有适当留白。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_image_to_center</span><span class="params">(back_image, logo_image)</span>:</span></span><br><span class="line">    qrcode_size = back_image.size[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 创建一个qrcode大小的背景，用于解决黑色二维码粘贴彩色logo显示为黑白的问题。</span></span><br><span class="line">    qr_back = Image.new(<span class="string">'RGBA'</span>, back_image.size, <span class="string">'white'</span>)</span><br><span class="line">    qr_back.paste(back_image)</span><br><span class="line">    logo_background_size = int(qrcode_size / <span class="number">4</span>)</span><br><span class="line">    <span class="comment"># 创建一个尺寸为二维码1/4的白底logo背景</span></span><br><span class="line">    logo_background_image = Image.new(<span class="string">'RGBA'</span>, (logo_background_size, logo_background_size), <span class="string">'white'</span>)</span><br><span class="line">    <span class="comment"># logo与其白底背景设置背景尺寸1/20的留白</span></span><br><span class="line">    logo_offset = int(logo_background_size / <span class="number">20</span>)</span><br><span class="line">    logo_size = int(logo_background_size - logo_offset * <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 将 logo 缩放至适当尺寸</span></span><br><span class="line">    resized_logo = logo_image.resize((logo_size, logo_size))</span><br><span class="line">    <span class="comment"># 将logo添加到白色背景</span></span><br><span class="line">    logo_background_image.paste(resized_logo, box=(logo_offset, logo_offset))</span><br><span class="line">    <span class="comment"># 将白色背景添加到二维码图片</span></span><br><span class="line">    logo_background_offset = int((qrcode_size - logo_background_size) / <span class="number">2</span>)</span><br><span class="line">    qr_back.paste(logo_background_image, box=(logo_background_offset, logo_background_offset))</span><br><span class="line">    <span class="keyword">return</span> qr_back</span><br></pre></td></tr></table></figure><p>以上代码中，需要说明的是关于第5行的问题。我发现直接往白底黑色二维码上粘贴彩色 Logo 会造成 Logo 显示为黑白色颗粒的问题。网上一时找不到解决方案，就只好折衷一下，先创建一个与二维码底色一样的背景 image，然后把二维码以及 logo 都粘贴到这个背景上。只是一个曲线救国方案，如果谁有更好的方法，欢迎联系我。</p><p>最终，到了实际生成步骤了。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">text_for_qrcode = <span class="string">r'www.baidu.com'</span></span><br><span class="line">logo_image_file = <span class="string">r'avatar.jpg'</span></span><br><span class="line"><span class="keyword">with</span> Image.open(logo_image_file) <span class="keyword">as</span> logo_image:</span><br><span class="line">    qr_code = make_qrcode(text_for_qrcode)</span><br><span class="line">    qr_code_with_logo = add_image_to_center(qr_code, logo_image)</span><br><span class="line">    qr_code_with_logo.save(<span class="string">'qr.png'</span>)</span><br></pre></td></tr></table></figure><p>最终效果如下图所示：</p><p><img alt="qr" data-src="qr.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何用 Python 生成像微信名片那样的中间带有 Logo 的二维码？使用 Python 的qrcode模块可以很容易做到。&lt;/p&gt;
&lt;p&gt;首先，import 所需的模块。完成工作，需要 &lt;code&gt;qrcode&lt;/code&gt;和&lt;code&gt;PIL&lt;/code&gt;模块。安装这些模块的方法可以自行百度。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; qrcode&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; PIL &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Image, ImageFont, ImageDraw&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;接着，生成二维码。二维码仅至少接收一个文本参数。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;make_qrcode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(text)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    qr = qrcode.QRCode(version=&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    error_correction=qrcode.constants.ERROR_CORRECT_H,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    box_size=&lt;span class=&quot;number&quot;&gt;8&lt;/span&gt;,border=&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    qr.add_data(text)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    qr.make(fit=&lt;span class=&quot;literal&quot;&gt;True&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; qr.make_image(fill_color=&lt;span class=&quot;string&quot;&gt;&quot;black&quot;&lt;/span&gt;, back_color=&lt;span class=&quot;string&quot;&gt;&quot;white&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;version，通俗来说，用于控制二维码的尺寸。version=1时，二维码包含21个块，其后 version 每增加1，二维码块数增加4。因此，version=10包含21+4*9=57个块。每个块的实际像素，由下面的参数 box_size 决定。&lt;/li&gt;
&lt;li&gt;error_correction，即容错率，按照「草料二维码」的建议，应当选择30%，这个比例下最容易被各种设备识别，也就是常量&lt;code&gt;qrcode.constants.ERROR_CORRECT_H&lt;/code&gt;。其他的常量还有：&lt;ul&gt;
&lt;li&gt;ERROR_CORRECT_L，大约7%容错；&lt;/li&gt;
&lt;li&gt;ERROR_CORRECT_M，大约15%容错，默认值；&lt;/li&gt;
&lt;li&gt;ERROR_CORRECT_Q，大约25%容错率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;box_size，即每个块的占据的像素数，8就是8像素。&lt;/li&gt;
&lt;li&gt;border，即二维码区域在边缘的留白，数字是块数，比如border=4即4块，也就是是4*8=32像素的留白，默认是4，建议最小值也是4，不过可以根据实际情况调整。&lt;/li&gt;
&lt;li&gt;整体上，生成二维码实际大小这么算。（version 块数 + border 块数）* box_size，因此以上参数实际会生成（57 + 4）* 8 = 488像素大小的正方形。&lt;/li&gt;
&lt;li&gt;最后 make_image 方法中的参数，可以根据实际需要调整，默认值就是白底黑色二维码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二维码生成了，下一步就是往二维码上添加 Logo。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/categories/programming/"/>
    
    
      <category term="python" scheme="http://shenxiaobing.com/tags/python/"/>
    
      <category term="二维码" scheme="http://shenxiaobing.com/tags/%E4%BA%8C%E7%BB%B4%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>意义</title>
    <link href="http://shenxiaobing.com/2018/meaning/"/>
    <id>http://shenxiaobing.com/2018/meaning/</id>
    <published>2018-09-03T07:12:31.000Z</published>
    <updated>2018-09-03T07:35:02.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>意义，就是对特定对象的价值。</p></blockquote><p>当这个词语被用到的时候，一般都会忽略到「特定对象」。“要过有意义的人生”，“人生没有意义”，这种泛指的用法让人迷惑。有意义的人生，对谁或者对什么有意义呢？对自己本人，对家庭，对族群，对国家？对世界和平、自由平等？对耶稣佛陀？</p><p>厘清定义之后，意义不再令人困惑。没有意义，也不再令人恐惧。「我的人生」的意义，如果有，注定是为「第三方」提供价值。如果只是对我自己有价值，那这就是所有人的现状，自为的状态。因此，当提到「我的人生」的意义时，一定会指向第三方。</p><p>第三方的可能性是什么？</p><a id="more"></a><p>第一类，就是大词。自由平等博爱民主法治伟大高尚慈善智慧和平，他们的共同点就是足够抽象，这样的标的可以接受无限的价值提供，整个生命都会充满意义感。</p><p>第二类，宗教。宗教的本义就是无条件的相信。「我的人生」全部都可以献给我的唯一的神。</p><p>第三类，极致的专业。绘画、音乐、物理、数学等，这种艺术类和研究类的专业领域，有无止境的追求深度。</p><p>这些是足够贯穿一生接受意义注入的对象。还有一些，比如保护亚文化、保护某个弱势群体，我想可以归入到第一类中。</p><p>既然意义是身外之物，我们要来何用？</p><blockquote><p> 意义本身提供了人生持久的动力。</p></blockquote><p>对自由、对宗教、对音乐的追求，会让人持续地保持向上的状态。即使在低谷有迷茫的时候，也明确地知道自己的方向。</p><p>所以，意义对于个人来说还是有意义的。但没有意义的生活，也可以一样的精彩。因为，到最后，你还有对自己的意义。你的意义不依赖于外物，而在于你自己。</p><p>同时，我们也可以看到，选择一个有深度的专业领域，可以成为一个未来潜在的意义之源。</p><p>有时候的很多烦恼，都是来自于对个人现状的不满。比如，我处在一个自私自为的状态，烦恼于为什么我不是一个为国为民或者天地境界这种更高的层次。为什么天地境界就比自私自为更高级？</p><p>安心地做一个自私的人。安心地做一个不为外物提供意义的人。是啊，我对大词、宗教、专业都没有什么价值，那有怎样呢？我为什么要为这些事物提供价值呢？回答不出这个问题，我为什么要烦恼呢？我们本来就天然没有价值联系啊！</p><p>人生有没有天然的意义？有！你的父母盼望你的降生，国家想要一个劳动力，人类希望你传播基因…</p><p>但你没必要去回应这些意义。一个人不必刻意地去追求大词和宗教，期望他们给自己带来有意义的人生。反倒是可以选择一个有深度的专业，为自己谋得一个富足的人生，而且可能会提供持久的意义。有些事情不是靠个人选择，而是水到渠成。</p><p>「没有意义」没什么大不了，只要你知道它对你自己的意义。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;意义，就是对特定对象的价值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当这个词语被用到的时候，一般都会忽略到「特定对象」。“要过有意义的人生”，“人生没有意义”，这种泛指的用法让人迷惑。有意义的人生，对谁或者对什么有意义呢？对自己本人，对家庭，对族群，对国家？对世界和平、自由平等？对耶稣佛陀？&lt;/p&gt;
&lt;p&gt;厘清定义之后，意义不再令人困惑。没有意义，也不再令人恐惧。「我的人生」的意义，如果有，注定是为「第三方」提供价值。如果只是对我自己有价值，那这就是所有人的现状，自为的状态。因此，当提到「我的人生」的意义时，一定会指向第三方。&lt;/p&gt;
&lt;p&gt;第三方的可能性是什么？&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://shenxiaobing.com/categories/essay/"/>
    
    
      <category term="意义" scheme="http://shenxiaobing.com/tags/%E6%84%8F%E4%B9%89/"/>
    
      <category term="人生意义" scheme="http://shenxiaobing.com/tags/%E4%BA%BA%E7%94%9F%E6%84%8F%E4%B9%89/"/>
    
      <category term="生命意义" scheme="http://shenxiaobing.com/tags/%E7%94%9F%E5%91%BD%E6%84%8F%E4%B9%89/"/>
    
  </entry>
  
  <entry>
    <title>《爱上跑步的13周》专属App软件</title>
    <link href="http://shenxiaobing.com/2018/app-for-13-week-run-program/"/>
    <id>http://shenxiaobing.com/2018/app-for-13-week-run-program/</id>
    <published>2018-08-04T15:05:26.000Z</published>
    <updated>2019-11-22T14:47:48.159Z</updated>
    
    <content type="html"><![CDATA[<p>《爱上跑步的13周》提供了完整的13周跑步训练计划。该计划核心在于循序渐进地提升运动量，在避免运动受伤的前提下，用13周让几乎任何体能状况的人完成自己的10公里跑。</p><p>心动不如行动。</p><p>但实际行动起来，却发现要完全跟随计划有点困难，因为这套训练计划的核心是跑步与走路相结合。我们需要知道什么时候该跑步，什么时候该走路。</p><p>《爱跑十三周》这个工具型app就是为此而生。</p><ul><li>下载地址：<a href="https://itunes.apple.com/cn/app/id1403686503" target="_blank" rel="noopener">https://itunes.apple.com/cn/app/id1403686503</a> </li><li>或苹果商店搜索「爱跑十三周」下载。</li></ul><p>《爱跑十三周》的主要功能如下：</p><a id="more"></a><h3 id="一、内置完整13周训练计划"><a href="#一、内置完整13周训练计划" class="headerlink" title="一、内置完整13周训练计划"></a>一、内置完整13周训练计划</h3><p>《爱跑十三周》100%还原《爱上跑步的13周》中制定的训练计划，包括中后期的「跑步多一些」和「走路多一些」选项，也都可以在《爱跑十三周》中进行设定。除了基础计划，还包括进阶的13周维持计划和13周快跑计划，完全还原原书计划。</p><img alt="program" style="zoom:67%;" data-src="program.png"><h3 id="二、后台语音提示，践行计划无压力"><a href="#二、后台语音提示，践行计划无压力" class="headerlink" title="二、后台语音提示，践行计划无压力"></a>二、后台语音提示，践行计划无压力</h3><p>根据训练计划，在跑步与走路需要切换时，会有语音提示。再也不用担心跟不上计划了。</p><p>同时，每满1公里，还会有语音提示。即使熄灭手机跑步，一样可以在切换跑步走路时进行语音提示。</p><h3 id="三、实时GPS数据，一目了然"><a href="#三、实时GPS数据，一目了然" class="headerlink" title="三、实时GPS数据，一目了然"></a>三、实时GPS数据，一目了然</h3><p>基于GPS，可以实时看到自己跑步的速度、距离、卡路里。跑完，还可以看到自己跑步的路线。</p><img alt="IMG_0008" style="zoom:50%;" data-src="IMG_0008.PNG"><h3 id="四、详细运动记录，方便回顾"><a href="#四、详细运动记录，方便回顾" class="headerlink" title="四、详细运动记录，方便回顾"></a>四、详细运动记录，方便回顾</h3><p>每次运动，这款专属《爱上跑步的13周》的工具软件都会记录详细的跑步数据以及跑步路线。</p><img alt="record" style="zoom:50%;" data-src="record.png"><h3 id="五、跑步提醒，规律运动"><a href="#五、跑步提醒，规律运动" class="headerlink" title="五、跑步提醒，规律运动"></a>五、跑步提醒，规律运动</h3><p>每隔2天，系统会提醒你该进行下一次训练了。就是这样。</p><blockquote><p>如果你想践行《爱上跑步的13周》跑步计划，这就是你最佳的工具软件App。</p></blockquote><h3 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h3><p>最后，再发一次下载地址，仅支持苹果手机哦！</p><ul><li>下载地址：<a href="https://itunes.apple.com/cn/app/id1403686503" target="_blank" rel="noopener">https://itunes.apple.com/cn/app/id1403686503</a> </li><li>或苹果商店搜索「爱跑十三周」下载。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《爱上跑步的13周》提供了完整的13周跑步训练计划。该计划核心在于循序渐进地提升运动量，在避免运动受伤的前提下，用13周让几乎任何体能状况的人完成自己的10公里跑。&lt;/p&gt;
&lt;p&gt;心动不如行动。&lt;/p&gt;
&lt;p&gt;但实际行动起来，却发现要完全跟随计划有点困难，因为这套训练计划的核心是跑步与走路相结合。我们需要知道什么时候该跑步，什么时候该走路。&lt;/p&gt;
&lt;p&gt;《爱跑十三周》这个工具型app就是为此而生。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;下载地址：&lt;a href=&quot;https://itunes.apple.com/cn/app/id1403686503&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://itunes.apple.com/cn/app/id1403686503&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;或苹果商店搜索「爱跑十三周」下载。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;《爱跑十三周》的主要功能如下：&lt;/p&gt;
    
    </summary>
    
    
      <category term="其他" scheme="http://shenxiaobing.com/categories/other/"/>
    
    
      <category term="爱上跑步的13周" scheme="http://shenxiaobing.com/tags/%E7%88%B1%E4%B8%8A%E8%B7%91%E6%AD%A5%E7%9A%8413%E5%91%A8/"/>
    
      <category term="爱跑十三周" scheme="http://shenxiaobing.com/tags/%E7%88%B1%E8%B7%91%E5%8D%81%E4%B8%89%E5%91%A8/"/>
    
  </entry>
  
  <entry>
    <title>我的App审核简史</title>
    <link href="http://shenxiaobing.com/2018/a-brief-history-of-app-review/"/>
    <id>http://shenxiaobing.com/2018/a-brief-history-of-app-review/</id>
    <published>2018-07-27T04:33:33.000Z</published>
    <updated>2019-09-05T02:39:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>两款应用终于过审了。记录下过程，以备参考。</p><p>先交代下两款应用的背景：<br>应用一：爱跑十三周，跑步应用，本地化为3种语言，没有开关隐藏、热更、第三方支付等常见违规问题；<br>应用二：魔板拼图，解密游戏应用，本地化为3种语言，没有开关隐藏、热更、第三方支付等常见违规问题。</p><a id="more"></a><h2 id="「爱跑十三周」审核来往记录"><a href="#「爱跑十三周」审核来往记录" class="headerlink" title="「爱跑十三周」审核来往记录"></a>「爱跑十三周」审核来往记录</h2><p>6月29日，首次提交审核；<br>6月30日，进入审核，元数据被拒；原因主要有两点：</p><ol><li>需要确认并声明遵守Guideline 2.1，因为这个类型的应用被认为可能会违反苹果审核规定。</li><li>苹果截图中不能包含价格或者免费字样。因为我的一张截图提到了免费字眼。</li></ol><p>6月30日，修改截图，并在待审核版本备注上声明遵守协议；重新提交审核。</p><p>7月3日，进入In Review状态。<br>7月17日，审核状态一直没变化。于是参考晚上的建议，将应用撤回，修改为1元付费应用，并重新提交审核。</p><p>7月20日，进入In Review状态。<br>7月21日，被拒绝，原因是：App在iPv6网络下点击某个菜单按键会闪退。我查看了他们附带的崩溃日志，没看到代码相关的报错。而且实际利用Mac创建iPv6网络测试，也没有问题。不过实际测试时，确实发现了因为没有及时移除KVO观察导致的崩溃，于是修复了这个Bug。但依然不确定，苹果审核人员的闪退是不是由这个Bug导致的。</p><p>7月23日，重新提交应用审核。<br>7月24日，进入In Review状态。<br>7月24日，元数据被拒，理由是：应用的中文名，包含了关键词或者描述语句。我的中文名是：爱跑 - 爱上跑步的13周。于是，我把中文名直接改成了爱跑十三周。并重新提交审核。</p><p>7月25日，再次进入In Review，并当天被拒，理由是：</p><ol><li>爱跑十三周，依然被认为是关键词或者描述语句，需要修改；</li><li>应用请求用户的位置但没有说明使用目的。</li></ol><p>我直接回复，爱跑十三周就是正式的app名字；同时截图给他看了我的本地化后的关于InfoPlist.string中与获取位置权限相关的描述。</p><p>7月26日，苹果回复说，中文名翻译以后是Love running for thirteen weeks，如果这是本意的话，则需要修改英文名字。当前的英文名是Into Run。<br>我回复说，在13周内爱上跑步就是本意。对于英文名来说，Into Run意思就是Love Running，英文名太长，不能完全照搬中文名的含义。同时举例微信和Wechat的例子来说明我的观点。最后，总结说这个名字是有效的。</p><p>7月26日下午，苹果回复说，中文名描述了在13周内跑步这个过程，但英文名却没有符合那个名字或过程。因此，要求修改名字，使之匹配。<br>我直接将英文名改为：Into Run: 13-week Run Program，然后回复说已经修改。</p><p>7月26日晚上将近12点左右，应用过审。</p><h2 id="「魔板拼图」审核来往记录"><a href="#「魔板拼图」审核来往记录" class="headerlink" title="「魔板拼图」审核来往记录"></a>「魔板拼图」审核来往记录</h2><p>7月21日，首次提交审核；提审后大约2个小时，返回错误：Invalid Binary。原因是我用了Xcode 10 Beta去编译生成的包。<br>于是，重新下载Xcode 9正式版，调整了app里的Swift4.2的方法，编译测试通过后，重新提交。</p><p>7月24日，重新提交并进入In Review状态；<br>7月24日，被拒，原因是：元数据包含误导或者故意欺骗用户的信息。我猜测大概是因为截图，因为我在中国区和其他语言使用了不同的截图，app内实际也是这样的设定。于是，回复说明了这个情况。<br>大约10分钟，他们就回复了，当时是上午9点21分。回复提到了另一个问题：说中文名可能存在利用另一个类似app的情况，要求改名字。<br>我当时立刻修改了名字。然后，我又重新提交了一次应用。</p><p>7月27日，凌晨2点左右，应用过审。</p><h2 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h2><ol><li>进入审核超过3天状态没有变化，可以撤掉重新提审，从记录来看，进入审核1-2天内就有结果；</li><li>主动声明绝无违反Guidline 2.1提到的那几个条款；</li><li>主动用iPv6测试App；</li><li>本地化的各个名字在实际含义上要匹配；</li><li>对于权限的请求，主动声明或者提供相关描述的截图；</li><li>应用名称中不要加各种看似关键词的东西；</li><li>不要使用Xcode的beta版本去打提审包；</li><li>对于不同地区使用不同截图的情况，可以主动说明情况；</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两款应用终于过审了。记录下过程，以备参考。&lt;/p&gt;
&lt;p&gt;先交代下两款应用的背景：&lt;br&gt;应用一：爱跑十三周，跑步应用，本地化为3种语言，没有开关隐藏、热更、第三方支付等常见违规问题；&lt;br&gt;应用二：魔板拼图，解密游戏应用，本地化为3种语言，没有开关隐藏、热更、第三方支付等常见违规问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/categories/programming/"/>
    
    
      <category term="iOS" scheme="http://shenxiaobing.com/tags/iOS/"/>
    
      <category term="审核" scheme="http://shenxiaobing.com/tags/%E5%AE%A1%E6%A0%B8/"/>
    
  </entry>
  
  <entry>
    <title>数字华容道怎样才能有解</title>
    <link href="http://shenxiaobing.com/2018/puzzle-random-algorithm/"/>
    <id>http://shenxiaobing.com/2018/puzzle-random-algorithm/</id>
    <published>2018-07-05T16:01:16.000Z</published>
    <updated>2018-07-05T16:39:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>数字华容道，是在4x4的格子中，依次从左到右，从上到下放置1-15这15个数字。经过一定的随机，必须将这15个数字复原。每个数字只能向相邻的唯一空格移动。难度更高的，格子和数字会更多，比如5x5。</p><p>我在开发一个类数字华容道游戏时，发现自己3x3的格子，居然怎么都解不出来。比如：一排1、2、3，二排4、5、6，三排8，7。经过网上查询，才知道完全随机位置的数值华容道仅有50%的概率是有解的。而我就是用的完全随机方式去打乱次序。</p><p>网上有两篇文章说的很好，以下是根据这两篇文章的总结。</p><h2 id="数字华容道必然有解的前提"><a href="#数字华容道必然有解的前提" class="headerlink" title="数字华容道必然有解的前提"></a>数字华容道必然有解的前提</h2><p>首先，要弄清楚一个概念：逆序数。逆序数，即一个数字序列，将其中所有数字依次两两对比，若大数在前，小数在后，那么这就是一对逆序数。这里说到的逆序数，指的是数字序列中逆序数的数量。比如：上文提到的1、2、3、4、5、6、8、7，逆序数只有1个，即8和7。</p><p>另外，还有一点要提出来。一般来讲，复原状态（初始状态）的数字华容道，会有一个空格，一般会设置在最末行的右下角。但也可以根据实际的需求，设置在其他行。请留意，初始空格所在的行数，是决定是否有解的一个重要因素。</p><p>数字华容道，必然有解，只存在于如下3个细分情形：</p><ol><li>若格子列数为奇数，则逆序数必须为偶数；</li><li>若格子列数为偶数，且逆序数为偶数，则当前空格所在行数与初始空格所在行数的差为偶数；</li><li>若格子列数为偶数，且逆序数为奇数，则当前空格所在行数与初始空格所在行数的差为奇数。</li></ol><p>实际的推演涉及到我一时难以彻底理解的数学推算，我只能用浅显的方式来理解这个问题。</p><a id="more"></a><h2 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h2><p>首先，有解的前提在于：当前空格回到初始空格所在行数时，逆序数一定得是偶数！为什么，我不清楚。</p><p>要想把空格移动到初始空格所在行，必须进行若干次上下移动和若干次左右移动。</p><p>左右移动，不会改变逆序数；上下移动，若格子列数为奇数，则每次增减偶数个逆序数，若格子列数为偶数，则每次增减奇数个逆序数。</p><p>也就是说：</p><ol><li>格子列数为奇数，怎么移动，都不会改变原始的逆序数。因为奇数加减偶数还是奇数，偶数加减偶数还是偶数。所以，只要保证逆序数是偶数即可，不必关心空格的位置。</li><li>格子列数为偶数，那么进行奇数次上下移动，会改变其逆序数的奇偶性。所以，如果当前逆序数是偶数，要想有解，就要保证实际上下移动会进行偶数次，也就是说空格所在行与初始空格所在行的差为偶数。</li><li>同理，若当前逆序数是奇数，要想有解，要进行奇数次的移动，才能保证最终逆序数是偶数。</li></ol><h2 id="如何转换逆序数奇偶性"><a href="#如何转换逆序数奇偶性" class="headerlink" title="如何转换逆序数奇偶性"></a>如何转换逆序数奇偶性</h2><p>具体实现应该很简单，不多说了，就说一点。如果想更改一个数字序列的逆序数的奇偶性，只需要调换一对逆序数的位置即可。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>可能是CS106A课程上的一句话，并不是原文：</p><blockquote><p>程序员要在不理解内在实现逻辑的情况下，也能顺畅地使用别人的成果。</p></blockquote><p>不理解没关系，会用就行。</p><p>参考文档：</p><ul><li><a href="https://www.guokr.com/article/54088/" target="_blank" rel="noopener">https://www.guokr.com/article/54088/</a></li><li><a href="https://segmentfault.com/a/1190000013284274" target="_blank" rel="noopener">用React写一个数字华容道，你需要知道的秘密 - 地铁上的小前端 - SegmentFault 思否</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数字华容道，是在4x4的格子中，依次从左到右，从上到下放置1-15这15个数字。经过一定的随机，必须将这15个数字复原。每个数字只能向相邻的唯一空格移动。难度更高的，格子和数字会更多，比如5x5。&lt;/p&gt;
&lt;p&gt;我在开发一个类数字华容道游戏时，发现自己3x3的格子，居然怎么都解不出来。比如：一排1、2、3，二排4、5、6，三排8，7。经过网上查询，才知道完全随机位置的数值华容道仅有50%的概率是有解的。而我就是用的完全随机方式去打乱次序。&lt;/p&gt;
&lt;p&gt;网上有两篇文章说的很好，以下是根据这两篇文章的总结。&lt;/p&gt;
&lt;h2 id=&quot;数字华容道必然有解的前提&quot;&gt;&lt;a href=&quot;#数字华容道必然有解的前提&quot; class=&quot;headerlink&quot; title=&quot;数字华容道必然有解的前提&quot;&gt;&lt;/a&gt;数字华容道必然有解的前提&lt;/h2&gt;&lt;p&gt;首先，要弄清楚一个概念：逆序数。逆序数，即一个数字序列，将其中所有数字依次两两对比，若大数在前，小数在后，那么这就是一对逆序数。这里说到的逆序数，指的是数字序列中逆序数的数量。比如：上文提到的1、2、3、4、5、6、8、7，逆序数只有1个，即8和7。&lt;/p&gt;
&lt;p&gt;另外，还有一点要提出来。一般来讲，复原状态（初始状态）的数字华容道，会有一个空格，一般会设置在最末行的右下角。但也可以根据实际的需求，设置在其他行。请留意，初始空格所在的行数，是决定是否有解的一个重要因素。&lt;/p&gt;
&lt;p&gt;数字华容道，必然有解，只存在于如下3个细分情形：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若格子列数为奇数，则逆序数必须为偶数；&lt;/li&gt;
&lt;li&gt;若格子列数为偶数，且逆序数为偶数，则当前空格所在行数与初始空格所在行数的差为偶数；&lt;/li&gt;
&lt;li&gt;若格子列数为偶数，且逆序数为奇数，则当前空格所在行数与初始空格所在行数的差为奇数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实际的推演涉及到我一时难以彻底理解的数学推算，我只能用浅显的方式来理解这个问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/categories/programming/"/>
    
    
      <category term="华容道" scheme="http://shenxiaobing.com/tags/%E5%8D%8E%E5%AE%B9%E9%81%93/"/>
    
      <category term="算法" scheme="http://shenxiaobing.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>引用类型 vs 数值类型</title>
    <link href="http://shenxiaobing.com/2018/reference-type-and-value-type/"/>
    <id>http://shenxiaobing.com/2018/reference-type-and-value-type/</id>
    <published>2018-07-04T15:24:24.000Z</published>
    <updated>2018-07-04T16:13:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>引用类型，Reference Type，多个实例可以共享统一份数据。</p><p>数值类型，Value Type，一个实例独享一份数据。这里的数据指的是内存中位置，并不是指具体的数值。</p><p>如果要将一个引用类型的的实例，赋值给一个变量，那么变量仅仅是共享内存中的这份数据，变量获得的是对这份数据的引用；如果是将一个数值类型的实例赋值给一个变量，那么将会在内存中创建一份相同的数据，赋值给变量。</p><p>两者的核心在于：</p><ul><li>引用类型实例赋值给其他变量后，对变量的修改，原引用实例会一起被修改；</li><li>数值类型实例赋值给其他变量后，对变量的修改，不会影响原来的数值实例。</li></ul><p>平时在使用和选择时，务必要记得这一点，否则可能会像我一样用踩坑来获取知识。（PS，我也不好说踩坑一定不好，我踩了一天的坑，对这个问题才会印象深刻。）</p><a id="more"></a><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>一般的类，大多都是引用类型，自定义的类更是如此。</p><p>下面用代码说明下引用类型赋值后共享数据的情况：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> name: <span class="type">String</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstPerson = <span class="type">Person</span>(<span class="string">"Shen"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将引用类型的实例赋值给变量</span></span><br><span class="line"><span class="keyword">var</span> secondPerson = firstPerson</span><br><span class="line">secondPerson.name = <span class="string">"Mike"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是Mike，因为引用类型共享同一份数据</span></span><br><span class="line"><span class="built_in">print</span>(firstPerson.name)</span><br></pre></td></tr></table></figure><h2 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h2><p>在Swift里，基本数据类型，都是数值类型，比如：<code>Int</code>、<code>Bool</code>、<code>Double</code>等。</p><p>另外，<code>String</code>、<code>Array</code>、<code>Dictionary</code>这些基础的类也是数值类型。</p><p>最后，<code>struct</code>、<code>enum</code>、<code>tuple</code>这些也都是数值类型。</p><p>下面用代码说明下，数据类型赋值后，独享数据互不干涉的情况：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SuperPerson</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> firstSuper = <span class="type">SuperPerson</span>(name: <span class="string">"Clark"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> secondSuper = firstSuper</span><br><span class="line">secondSuper.name = <span class="string">"Bruce"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是Clark，因为Struct是数值类型，赋值给其他变量时，是直接复制给其他变量的。</span></span><br><span class="line"><span class="built_in">print</span>(firstSuper.name)</span><br></pre></td></tr></table></figure><h2 id="特殊情形：Array里的引用类型"><a href="#特殊情形：Array里的引用类型" class="headerlink" title="特殊情形：Array里的引用类型"></a>特殊情形：Array里的引用类型</h2><p>Array是数值类型，就是说，将一个Array赋值给另一个变量时，变量持有的是不同的Array，在内存中的数据是不同的。比如下面的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstPerson = <span class="type">Person</span>(<span class="string">"Huo"</span>)</span><br><span class="line"><span class="keyword">let</span> secondPerson = <span class="type">Person</span>(<span class="string">"Shi"</span>)</span><br><span class="line"><span class="keyword">let</span> persons = [firstPerson, secondPerson]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数值类型的Array赋值给一个变量</span></span><br><span class="line"><span class="keyword">var</span> newPersons = persons</span><br><span class="line"><span class="comment">// 修改变量</span></span><br><span class="line">newPersons[<span class="number">0</span>] = <span class="type">Person</span>(<span class="string">"Mike"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是Huo，即newPersons和persons其实是两个不同的对象。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(persons[0].name)"</span>)</span><br></pre></td></tr></table></figure><p>对于一般的赋值，比如上面的<code>var newPersons = persons</code>，因为<code>persons</code>里面的元素本身是引用类型，而且这种默认执行的是<strong>浅复制</strong>，所以在新的<code>newPersons</code>中包含的并不是拥有全新数据的元素，而仅仅是分享<code>persons</code>中所包含的元素的内存数据而已，就像上面讨论的引用类型一样。请参考下面的代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取newPersons中的第2个元素，并修改元素的name属性</span></span><br><span class="line"><span class="keyword">let</span> second = newPersons[<span class="number">1</span>]</span><br><span class="line">second.name = <span class="string">"Jim"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果也是Jim，即虽然newPersons和persons是不同的数组。</span></span><br><span class="line"><span class="comment">// 但由于其生成方式是直接赋值，两个数组里其实是相同的元素。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(persons[1].name)"</span>)</span><br></pre></td></tr></table></figure><p>如果你在赋值时，关心里面的元素且需要对元素进行独立修改，那么就需要使用<strong>深复制</strong>，或者将元素替换为数值类型。</p><p>以下是对上面<code>Person</code>类的深复制代码实例：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义一个深复制方法，其实就是重新创建一个实例，并且对其属性赋予相同的数值。</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">copy</span><span class="params">()</span></span> -&gt; <span class="type">Person</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> person = <span class="type">Person</span>(name)</span><br><span class="line">        <span class="keyword">return</span> person</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对每个元素进行深复制然后加入新的Array</span></span><br><span class="line"><span class="keyword">var</span> newerPersons = persons.<span class="built_in">map</span> &#123; $<span class="number">0</span>.copy() &#125;</span><br><span class="line"><span class="keyword">let</span> secondP = newerPersons[<span class="number">1</span>]</span><br><span class="line">secondP.name = <span class="string">"Jim"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果不是Jim</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"\(persons[1].name)"</span>)</span><br></pre></td></tr></table></figure><h2 id="使用数据类型时的注意事项"><a href="#使用数据类型时的注意事项" class="headerlink" title="使用数据类型时的注意事项"></a>使用数据类型时的注意事项</h2><p>务必记得，要修改数据变量，必须直接对其进行修改，而不能像对普通类的对象一样，先进行一次临时变量赋值，再对变量进行修改。</p><p>最后：</p><blockquote><ul><li>引用类型实例赋值给其他变量后，对变量的修改，原引用实例会一起被修改；</li><li>数值类型实例赋值给其他变量后，对变量的修改，不会影响原来的数值实例。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;引用类型，Reference Type，多个实例可以共享统一份数据。&lt;/p&gt;
&lt;p&gt;数值类型，Value Type，一个实例独享一份数据。这里的数据指的是内存中位置，并不是指具体的数值。&lt;/p&gt;
&lt;p&gt;如果要将一个引用类型的的实例，赋值给一个变量，那么变量仅仅是共享内存中的这份数据，变量获得的是对这份数据的引用；如果是将一个数值类型的实例赋值给一个变量，那么将会在内存中创建一份相同的数据，赋值给变量。&lt;/p&gt;
&lt;p&gt;两者的核心在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引用类型实例赋值给其他变量后，对变量的修改，原引用实例会一起被修改；&lt;/li&gt;
&lt;li&gt;数值类型实例赋值给其他变量后，对变量的修改，不会影响原来的数值实例。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;平时在使用和选择时，务必要记得这一点，否则可能会像我一样用踩坑来获取知识。（PS，我也不好说踩坑一定不好，我踩了一天的坑，对这个问题才会印象深刻。）&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/categories/programming/"/>
    
    
      <category term="iOS" scheme="http://shenxiaobing.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://shenxiaobing.com/tags/Swift/"/>
    
      <category term="引用类型" scheme="http://shenxiaobing.com/tags/%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    
      <category term="数值类型" scheme="http://shenxiaobing.com/tags/%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>iOS工程的本地化-Swift</title>
    <link href="http://shenxiaobing.com/2018/localization-of-ios-project/"/>
    <id>http://shenxiaobing.com/2018/localization-of-ios-project/</id>
    <published>2018-06-29T06:20:39.000Z</published>
    <updated>2018-06-29T09:27:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>应用如果需要根据设备语言显示不同的语言，就需要进行本地化的工作。就iOS工程而言，需要本地化的内容主要有：文字、图片、语音。一般而言，图片和语言的本地化，都可以转化为实质上的字符串的本地化。</p><ul><li>info.plist本地化</li><li>代码字符串本地化</li><li>storyboard, xib文件本地化</li><li>launchScreen.storyboard本地化</li><li>图片本地化</li><li>一次性导出本地化文件</li><li>新增内容的本地化</li><li>多人协作下使用自定义Localizable.strings文件</li></ul><a id="more"></a><h2 id="本地化的前置配置"><a href="#本地化的前置配置" class="headerlink" title="本地化的前置配置"></a>本地化的前置配置</h2><p>要进行任何本地化之前，需要先配置本地化语言。前往Project - Info - Localizations，添加本地化的目标语言。</p><h2 id="Info-Plist本地化"><a href="#Info-Plist本地化" class="headerlink" title="Info.Plist本地化"></a>Info.Plist本地化</h2><p><code>Info.plist</code>文件中，有：应用显示名称，还有系统权限文字说明，比如：请求位置或者拍照时弹出系统提示，我们需要在那里显示请求权限的用途。这部分的文字，都在<code>info.plist</code>中。</p><h3 id="创建文件InfoPlist-strings"><a href="#创建文件InfoPlist-strings" class="headerlink" title="创建文件InfoPlist.strings"></a>创建文件InfoPlist.strings</h3><p>我们可以直接创建名为<code>InfoPlist.strings</code>的文件。文件名不能自定义。</p><h3 id="勾选本地化语言"><a href="#勾选本地化语言" class="headerlink" title="勾选本地化语言"></a>勾选本地化语言</h3><p>创建后，选中文件，在Xcode右侧边栏<code>File Inspector</code>中可以找到<code>Localization</code>勾选项。勾选一个语言，就会自动生成一个对应那个语言的<code>InfoPlist.strings</code>文件。</p><h3 id="添加要修改键值对"><a href="#添加要修改键值对" class="headerlink" title="添加要修改键值对"></a>添加要修改键值对</h3><p>在<code>InfoPlist.strings</code>文件中，我们可以直接像这样一样，去手动输入键和对应的本地化文本，最后用分号标识：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Bundle display name */</span></span><br><span class="line"><span class="string">"CFBundleDisplayName"</span> = <span class="string">"爱跑十三周"</span>;</span><br></pre></td></tr></table></figure><p>前提是你得知道要修改的文本对应的键是什么，比如`”CFBundleDisplayName”是应用的显示名称。</p><p>如果想知道键是什么，可以选中<code>info.plist</code>，右键选择<code>Open As - Source Code</code>。在那里可以到真实的键名。</p><h2 id="代码字符串的本地化"><a href="#代码字符串的本地化" class="headerlink" title="代码字符串的本地化"></a>代码字符串的本地化</h2><h3 id="代码中调用NSLocalizedString"><a href="#代码中调用NSLocalizedString" class="headerlink" title="代码中调用NSLocalizedString"></a>代码中调用NSLocalizedString</h3><p>要本地化代码字符串，在使用字符串时，不能直接用具体明文的<code>String</code>，而要把需要本地化显示的字符串写成<code>NSLolalizedString(string: String, comment: String)</code>。方法里第一个参数，可以理解为本地化的键，这个值应该是唯一的，是本地化字符串的唯一标识。comment，是字符串的注释，方便你进行后续的翻译。</p><p>比如：<code>label. text = NSLocalizedString(&quot;屏幕尺寸&quot;, comment: &quot;屏幕尺寸label的标题&quot;)</code></p><h3 id="创建文件Localizable-Strings"><a href="#创建文件Localizable-Strings" class="headerlink" title="创建文件Localizable.Strings"></a>创建文件Localizable.Strings</h3><p>创建名为<code>Localizable</code>的<code>strings</code>文件，名称不能自定义。</p><h3 id="勾选本地化语言-1"><a href="#勾选本地化语言-1" class="headerlink" title="勾选本地化语言"></a>勾选本地化语言</h3><p>创建后，选中文件，在Xcode右侧边栏<code>File Inspector</code>中可以找到<code>Localization</code>勾选项。勾选一个语言，就会自动生成一个对应那个语言的<code>Localizable.strings</code>文件。</p><h3 id="添加要修改的本地化键值对"><a href="#添加要修改的本地化键值对" class="headerlink" title="添加要修改的本地化键值对"></a>添加要修改的本地化键值对</h3><p>添加如下代码进入<code>Localizable.strings</code>。<strong>请注意添加代码末尾的分号</strong></p><p>简体中文的<code>Localizable.strings</code></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 屏幕尺寸label的标题 */</span></span><br><span class="line"><span class="string">"屏幕尺寸"</span> = <span class="string">"屏幕尺寸"</span>;</span><br></pre></td></tr></table></figure><p>繁体中文的<code>Localizable.strings</code></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 屏幕尺寸label的标题 */</span> </span><br><span class="line"><span class="string">"屏幕尺寸"</span> = <span class="string">"熒幕尺寸"</span>;</span><br></pre></td></tr></table></figure><p>英文的<code>Localizable.strings</code></p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 屏幕尺寸label的标题 */</span>  </span><br><span class="line"><span class="string">"屏幕尺寸"</span> = <span class="string">"Screen Size"</span>;</span><br></pre></td></tr></table></figure><p>这样那一处的字符串就完成了本地化。再对其他需要本地化的字符串做相同的处理即可。</p><h2 id="storyboard和xib的本地化"><a href="#storyboard和xib的本地化" class="headerlink" title="storyboard和xib的本地化"></a>storyboard和xib的本地化</h2><p>有时我们创建的storyboard和xib上也有字符串需要本地化。要做也非常简单。</p><h3 id="勾选本地化语言-2"><a href="#勾选本地化语言-2" class="headerlink" title="勾选本地化语言"></a>勾选本地化语言</h3><p>选中storyboard或者xib，在File Inspector中勾选Localization中需要本地化的语言。勾选后，就会在原来的文件下面生成本地化的strings文件，文件名是storyboard或者xib的名称。</p><h3 id="进入strings文件修改"><a href="#进入strings文件修改" class="headerlink" title="进入strings文件修改"></a>进入strings文件修改</h3><p>进入自动生成的strings文件，可以看到里面把带有字符串的按钮都列出来了。我们可以直接去修改对应的数值即可。</p><h2 id="LaunchScreen-storyboard的本地化"><a href="#LaunchScreen-storyboard的本地化" class="headerlink" title="LaunchScreen.storyboard的本地化"></a>LaunchScreen.storyboard的本地化</h2><p>上面本地化storboard的方法并不适用于<code>LaunchScreen.storyboard</code>。但要本地化也有办法。</p><h3 id="手动创建多个storyboard"><a href="#手动创建多个storyboard" class="headerlink" title="手动创建多个storyboard"></a>手动创建多个storyboard</h3><p>手动创建多个针对不同语言的storyboard，设置其样式和外观。</p><h3 id="添加InfoPlist-strings键值对"><a href="#添加InfoPlist-strings键值对" class="headerlink" title="添加InfoPlist.strings键值对"></a>添加InfoPlist.strings键值对</h3><p>在上文提到的InfoPlist.strings中加入如下代码：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* LauchScreen storyboard for the language */</span></span><br><span class="line"><span class="string">"UILaunchStoryboardName"</span> = <span class="string">"LaunchScreenSC"</span>;</span><br></pre></td></tr></table></figure><p>为不同语言的InfoPlist.strings指定不同的用于启动的storyboard名称。</p><h2 id="图片的本地化"><a href="#图片的本地化" class="headerlink" title="图片的本地化"></a>图片的本地化</h2><h3 id="使用本地化的图片名称"><a href="#使用本地化的图片名称" class="headerlink" title="使用本地化的图片名称"></a>使用本地化的图片名称</h3><p>图片的调用一般是用图片名称，也就是字符串，因此图片本地化可以转化为字符串本地化问题。</p><h3 id="对图片资源设置本地化语言"><a href="#对图片资源设置本地化语言" class="headerlink" title="对图片资源设置本地化语言"></a>对图片资源设置本地化语言</h3><p>像对xib那样在File Inspector中配置本地化语言，这样就会在不同的本地化文件夹中出现同名的图片。根据需要替换即可。</p><h2 id="一次性导出本地化文件"><a href="#一次性导出本地化文件" class="headerlink" title="一次性导出本地化文件"></a>一次性导出本地化文件</h2><p>上面的这些方法都没问题，但如果要修改的文字很多，如果翻译需要多人去做，这样就很低效。Xcode提供了一个工具，可以导出所有本地化字符串。</p><h3 id="确认已配置本地化语言"><a href="#确认已配置本地化语言" class="headerlink" title="确认已配置本地化语言"></a>确认已配置本地化语言</h3><ol><li>将需要本地化的storyboard和xib勾选本地化语言</li><li>在代码里添加需要本地化的NSLocalizedString</li></ol><h3 id="导出xliff文件"><a href="#导出xliff文件" class="headerlink" title="导出xliff文件"></a>导出xliff文件</h3><p>选中<code>Target</code>，点击顶部<code>Editor</code>，然后点击<code>Export For Localization</code>。选择要导出的语言，即可导出<code>xliff</code>文件。</p><h3 id="导入xliff文件"><a href="#导入xliff文件" class="headerlink" title="导入xliff文件"></a>导入xliff文件</h3><p>将xliff文件发给本地化小组完成本地化后，可以直接在<code>Editor</code> - <code>Import Localization</code>导入<code>xliff</code>文件。</p><h2 id="新增内容的本地化"><a href="#新增内容的本地化" class="headerlink" title="新增内容的本地化"></a>新增内容的本地化</h2><p>应用出了新版本，又有了新的需要本地化的内容。这时，只需要重新导出<code>xliff</code>文件。原有的本地化内容在导出时会被保留，只需要对新的内容本地化。完成后，重新导入，即可。</p><h2 id="从指定自定义strings文件加载本地化字符串"><a href="#从指定自定义strings文件加载本地化字符串" class="headerlink" title="从指定自定义strings文件加载本地化字符串"></a>从指定自定义strings文件加载本地化字符串</h2><p>如果多人需要操作字符串，那么可以自己创建一个专属于自己的strings字符串，不使用默认的Localizable.strings。比如，你创建了名为<code>MyLocalizable.strings</code>的文件。那么你在调用本地化字符串时，就应该这样写：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="type">NSLocalziableString</span>(<span class="string">"屏幕尺寸"</span>, tableName: <span class="string">"MyLocalizable"</span>, comment: <span class="string">"屏幕尺寸"</span>))</span><br></pre></td></tr></table></figure><p>即在参数中加入<code>tableName</code>，指定从哪个文件加载。</p><p>参考文档：</p><ul><li><a href="https://www.jianshu.com/p/88c1b65e3ddb" target="_blank" rel="noopener">https://www.jianshu.com/p/88c1b65e3ddb</a> </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应用如果需要根据设备语言显示不同的语言，就需要进行本地化的工作。就iOS工程而言，需要本地化的内容主要有：文字、图片、语音。一般而言，图片和语言的本地化，都可以转化为实质上的字符串的本地化。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;info.plist本地化&lt;/li&gt;
&lt;li&gt;代码字符串本地化&lt;/li&gt;
&lt;li&gt;storyboard, xib文件本地化&lt;/li&gt;
&lt;li&gt;launchScreen.storyboard本地化&lt;/li&gt;
&lt;li&gt;图片本地化&lt;/li&gt;
&lt;li&gt;一次性导出本地化文件&lt;/li&gt;
&lt;li&gt;新增内容的本地化&lt;/li&gt;
&lt;li&gt;多人协作下使用自定义Localizable.strings文件&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/categories/programming/"/>
    
    
      <category term="iOS" scheme="http://shenxiaobing.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://shenxiaobing.com/tags/Swift/"/>
    
      <category term="Loalization" scheme="http://shenxiaobing.com/tags/Loalization/"/>
    
      <category term="本地化" scheme="http://shenxiaobing.com/tags/%E6%9C%AC%E5%9C%B0%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>I made an app</title>
    <link href="http://shenxiaobing.com/2018/i-made-an-app/"/>
    <id>http://shenxiaobing.com/2018/i-made-an-app/</id>
    <published>2018-06-29T03:03:50.000Z</published>
    <updated>2018-06-29T08:33:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>我的第一个App终于提审了。</p><p>从2015年开始，我就念叨着要做一个App；而2016和2017年的年度目标之一就是上架一个App。但直到现在，2018年，我才真正完成我的第一款App。</p><p>我看了下代码文档的创建时间最早是在4月23日，也就是说我用了2个月时间完成了一款简单的跑步App。这2个月一开始也是松松垮垮，直到最后几天才通宵达旦地冲着目标冲刺。</p><p>有时候，我会想，我是真的喜欢编程么？是的话，为何这几年都没有实质的进展；而不是的话，为何这几年都心心念念？理性地讲，如果时间回到我刚毕业那会，我可能会选择编程，毫无疑问。但现在，调转航道的成本和风险不能不让我三思。</p><p>不管怎样，至少这是一个里程碑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我的第一个App终于提审了。&lt;/p&gt;
&lt;p&gt;从2015年开始，我就念叨着要做一个App；而2016和2017年的年度目标之一就是上架一个App。但直到现在，2018年，我才真正完成我的第一款App。&lt;/p&gt;
&lt;p&gt;我看了下代码文档的创建时间最早是在4月23日，也就是说我用了
      
    
    </summary>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/categories/programming/"/>
    
    
      <category term="iOS" scheme="http://shenxiaobing.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://shenxiaobing.com/tags/Swift/"/>
    
      <category term="App" scheme="http://shenxiaobing.com/tags/App/"/>
    
  </entry>
  
  <entry>
    <title>仿照微信WebView实现ProgressBar</title>
    <link href="http://shenxiaobing.com/2018/progress-bar-like-wechat-webview/"/>
    <id>http://shenxiaobing.com/2018/progress-bar-like-wechat-webview/</id>
    <published>2018-06-28T02:03:47.000Z</published>
    <updated>2018-06-28T03:24:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="两种进度条逻辑"><a href="#两种进度条逻辑" class="headerlink" title="两种进度条逻辑"></a>两种进度条逻辑</h2><p>在网页中，一般我们会用顶部进度条来表示当前网页加载的进度。这里最常见的就是像Safari或Chrome浏览器那样的，用真实的进度百分比来更新进度条。当网速较慢时，进度条几乎完全不动；当网速较快时，进度条则会从大约20%位置嗖一下快速变为100%。</p><p>还有一种，就是微信App里的网页加载进度条。这里的进度条反映的不是真实的加载进度，其设计初衷应该就是让网页加载『看起来』更快。经过观察，大约是这样的一个逻辑：</p><blockquote><p>打开网页，进度条就进到10%；</p><p>再用3秒钟，进度条从10%走到60%；</p><p>再用4秒钟，进度条从60%走到80%；</p><p>再用8秒钟，进度条从80%走到90%；</p><p>从90%位置开始，进度条开始反应真实的加载进度。若此时网络连接极差，那么将会在90%卡住很久。</p><p>在以上的15秒内，若真实进度超过90%，则直接切换到真实进度，所以2秒打开的网页，也只会用2秒，不会固定加载15秒。</p></blockquote><p>从用户提交角度，可以对比不同网速下打开网页时进度条的表现：</p><ul><li>网速快，那么微信用3秒就进到60%，然后第4秒刷一下到100%；而Safari则是慢慢地移动到30%左右，然后刷的进到100%。</li><li>网速慢，那么微信用15秒加载了90%，只差最后10%加载不出；而Safari则一直处于不足10%的加载状态。</li></ul><p>对于小白用户而言，微信的加载条让人『感觉』更快。</p><p>除了这一点，<code>WKWebView</code>的<code>estimatedProgress</code>并不会均匀地返回结果。很可能第一次返回结果就是0.5，然后就是0.1。这样Safari加载时，会看到进度条忽快忽慢。</p><p>总结起来：</p><ul><li><code>estimatedProgress</code>返回值不均匀，这样进度条进度并不平滑；</li><li>虚假进度给人『更好』的用户体验。</li></ul><h2 id="仿微信网页进度条实现方式Swift4"><a href="#仿微信网页进度条实现方式Swift4" class="headerlink" title="仿微信网页进度条实现方式Swift4"></a>仿微信网页进度条实现方式Swift4</h2><p>该实现依赖于对KVO有一定的了解，若不了解，可以参考另一篇：<a href="http://pkuflint.me/2018/understanding-kvo-in-swift/" target="_blank" rel="noopener">理解KVO - 用Swift在WKWebView中添加进度条</a></p><p>首先，声明必要的变量。</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们的网页，因为要使用KVO，所以对象必须添加@objc</span></span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">var</span> webView = <span class="type">WKWebView</span>()</span><br><span class="line"><span class="comment">// 我们要监听的另一个对象，即网页加载时间，同样因为要使用KVO，属性要添加@objc和dynamic</span></span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> loadTime: <span class="type">Double</span> = <span class="number">0.0</span></span><br><span class="line"><span class="comment">// 这个是我们的进度条</span></span><br><span class="line"><span class="keyword">var</span> progressLayer: <span class="type">CALayer!</span></span><br><span class="line"><span class="comment">// 统计页面加载时间的timer</span></span><br><span class="line"><span class="keyword">var</span> timer: <span class="type">Timer?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这是用于监听webView.estimatedProgress和loadTime的两个监听对象</span></span><br><span class="line"><span class="keyword">var</span> progressObservation: <span class="type">NSKeyValueObservation?</span></span><br><span class="line"><span class="keyword">var</span> loadTimeObservation: <span class="type">NSKeyValueObservation?</span></span><br></pre></td></tr></table></figure><p>接着，创建进度条。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setUpWebView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    webView.frame = view.bounds</span><br><span class="line">    webView.navigationDelegate = <span class="keyword">self</span></span><br><span class="line">    webView.autoresizingMask = [.flexibleWidth, .flexibleHeight]</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: urlString!) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"url is nil"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    webView.load(<span class="type">URLRequest</span>(url: url))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> progress = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: webView.frame.width, height: <span class="number">3</span>))</span><br><span class="line">    webView.addSubview(progress)</span><br><span class="line">    progressLayer = <span class="type">CALayer</span>()</span><br><span class="line">    progressLayer.backgroundColor = <span class="type">APPColor</span>.orange.cgColor</span><br><span class="line">    progress.layer.addSublayer(progressLayer!)</span><br><span class="line"></span><br><span class="line">    view.addSubview(webView)</span><br><span class="line">    <span class="comment">// 设置初始进度条位置为10%</span></span><br><span class="line">    progressLayer!.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: webView.frame.width * <span class="number">0.1</span>, height: <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明遵循<code>WKNavigationDelegate</code>协议后，在协议方法中添加设置监听对象和包含对应处理方法的闭包。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">webView</span><span class="params">(<span class="number">_</span> webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping <span class="params">(WKNavigationActionPolicy)</span></span></span> -&gt; <span class="type">Void</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> navigationAction.navigationType &#123;</span><br><span class="line">    <span class="comment">// other类型，直接从外部赋值url打开页面时，就属于other</span></span><br><span class="line">    <span class="keyword">case</span> .other:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"its an other situation"</span>)</span><br><span class="line">    <span class="keyword">case</span> .reload:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"it's a reload situation"</span>)</span><br><span class="line">    <span class="keyword">case</span> .backForward:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"its going back"</span>)</span><br><span class="line">    <span class="keyword">case</span> .formResubmitted:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"resubmited"</span>)</span><br><span class="line">    <span class="keyword">case</span> .formSubmitted:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"from submitted"</span>)</span><br><span class="line">    <span class="comment">// 点击当前页面连接打开新连接</span></span><br><span class="line">    <span class="keyword">case</span> .linkActivated:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"link activited"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    startProgress()<span class="comment">// 设置progressBar初始状态，并添加观察，参考下文</span></span><br><span class="line">    destroyTimer()<span class="comment">// 保险起见，再摧毁一次timer</span></span><br><span class="line">    startTimer()<span class="comment">// 启动timer开始计时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否允许访问</span></span><br><span class="line">    decisionHandler(.allow)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置timer为每0.1秒为loadTime赋值，这样可以大约0.1秒就修改一次进度条，看起来更平滑</span></span><br><span class="line">    timer = <span class="type">Timer</span>.scheduledTimer(withTimeInterval: <span class="number">0.1</span>, repeats: <span class="literal">true</span>, block: &#123; (timer) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">        weakself?.loadTime += <span class="number">0.1</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">destroyTimer</span><span class="params">()</span></span> &#123;</span><br><span class="line">    timer?.invalidate()</span><br><span class="line">    loadTime = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">startProgress</span><span class="params">()</span></span> &#123;</span><br><span class="line">    progressLayer.opacity = <span class="number">1</span></span><br><span class="line">    progressLayer!.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: webView.frame.width * <span class="number">0.1</span>, height: <span class="number">3</span>)</span><br><span class="line">    setupObservations()<span class="comment">// 设置监听</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置监听</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupObservations</span><span class="params">()</span></span> &#123;</span><br><span class="line">    setupProgressObservation()</span><br><span class="line">    setupLoadTimeObservation()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停止监听</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stopObservations</span><span class="params">()</span></span> &#123;</span><br><span class="line">    progressObservation?.invalidate()</span><br><span class="line">    loadTimeObservation?.invalidate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是设置监听的具体方法，也是重头戏：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听webView.estimatedProgress，即页面加载实际进度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupProgressObservation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    progressObservation = webView.observe(\.estimatedProgress, options: [.old, .new], changeHandler: &#123; (webView, change) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> newValue = change.newValue  ?? <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> oldValue = change.oldValue  ?? <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">        <span class="comment">//  在达到0.9之前，进度条由loadTime决定；到0.9以后，根据实际进度进行加载</span></span><br><span class="line">        <span class="keyword">if</span> newValue &gt; oldValue &amp;&amp; newValue &gt; <span class="number">0.9</span> &#123;</span><br><span class="line">            weakself?.progressLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: (weakself?.webView.frame.width)! * <span class="type">CGFloat</span>(newValue), height: <span class="number">3</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> newValue == <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="comment">// 加载结束时，停止监听，停止timer</span></span><br><span class="line">            weakself?.stopObservations()</span><br><span class="line">            weakself?.destroyTimer()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 结束时隐藏progress bar并回到初始位置</span></span><br><span class="line">            <span class="keyword">let</span> time1 = <span class="type">DispatchTime</span>.now() + <span class="number">0.4</span></span><br><span class="line">            <span class="keyword">let</span> time2 = time1 + <span class="number">0.1</span></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: time1) &#123;</span><br><span class="line">                weakself?.progressLayer.opacity = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: time2) &#123;</span><br><span class="line">                weakself?.progressLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">0</span>, height: <span class="number">3</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听loadTime</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupLoadTimeObservation</span><span class="params">()</span></span> &#123;</span><br><span class="line">    loadTimeObservation = observe(\.loadTime, changeHandler: &#123; (<span class="keyword">self</span>, changes) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">        <span class="comment">// 假如加载进度超过90%，则不再通过loadTime更新</span></span><br><span class="line">        <span class="keyword">if</span> weakself!.progressLayer.frame.width &gt;= weakself!.webView.frame.width * <span class="number">0.9</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> ratio = <span class="number">0.0</span> <span class="comment">// 进度条的进度比例</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> time = weakself?.loadTime <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        <span class="keyword">if</span> time &lt;= <span class="number">3</span> &#123;</span><br><span class="line">            <span class="comment">// 前3秒进度条走50%，那么每秒是走0.5 / 3；</span></span><br><span class="line">            <span class="comment">// 0.1是已经固定的进度，下面的逻辑类似</span></span><br><span class="line">            ratio = time * <span class="number">0.5</span> / <span class="number">3</span> + <span class="number">0.1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> time &gt; <span class="number">3</span> &amp;&amp; time &lt;= <span class="number">7</span> &#123;</span><br><span class="line">            ratio = (time - <span class="number">3</span>) * <span class="number">0.2</span> / <span class="number">4</span> + <span class="number">0.6</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> time &gt; <span class="number">7</span> &amp;&amp; time &lt;= <span class="number">15</span> &#123;</span><br><span class="line">            ratio = (time - <span class="number">7</span>) * <span class="number">0.1</span> / <span class="number">8</span> + <span class="number">0.8</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> time &gt; <span class="number">15</span> &amp;&amp; time &lt;  <span class="number">25</span> &#123;</span><br><span class="line">            ratio = <span class="number">0.9</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        weakself?.progressLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: weakself!.webView.frame.width * <span class="type">CGFloat</span>(ratio), height: <span class="number">3</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，进度条的全部实现已经完成。</p><p>如果对KVO有不理解，可以参考我的另一篇使用KVO的例子：<a href="http://pkuflint.me/2018/understanding-kvo-in-swift/" target="_blank" rel="noopener">理解KVO - 用Swift在WKWebView中添加进度条</a>。在这篇文章中，我用于实现进度条的逻辑正是像Safari那样的真实进度。</p><blockquote><p>本人初学，有错误或疏漏之处，欢迎斧正！</p></blockquote><p>参考文档：</p><ul><li><a href="https://www.jianshu.com/p/24b3e3ddc946" target="_blank" rel="noopener">https://www.jianshu.com/p/24b3e3ddc946</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;两种进度条逻辑&quot;&gt;&lt;a href=&quot;#两种进度条逻辑&quot; class=&quot;headerlink&quot; title=&quot;两种进度条逻辑&quot;&gt;&lt;/a&gt;两种进度条逻辑&lt;/h2&gt;&lt;p&gt;在网页中，一般我们会用顶部进度条来表示当前网页加载的进度。这里最常见的就是像Safari或Chrome浏览器那样的，用真实的进度百分比来更新进度条。当网速较慢时，进度条几乎完全不动；当网速较快时，进度条则会从大约20%位置嗖一下快速变为100%。&lt;/p&gt;
&lt;p&gt;还有一种，就是微信App里的网页加载进度条。这里的进度条反映的不是真实的加载进度，其设计初衷应该就是让网页加载『看起来』更快。经过观察，大约是这样的一个逻辑：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;打开网页，进度条就进到10%；&lt;/p&gt;
&lt;p&gt;再用3秒钟，进度条从10%走到60%；&lt;/p&gt;
&lt;p&gt;再用4秒钟，进度条从60%走到80%；&lt;/p&gt;
&lt;p&gt;再用8秒钟，进度条从80%走到90%；&lt;/p&gt;
&lt;p&gt;从90%位置开始，进度条开始反应真实的加载进度。若此时网络连接极差，那么将会在90%卡住很久。&lt;/p&gt;
&lt;p&gt;在以上的15秒内，若真实进度超过90%，则直接切换到真实进度，所以2秒打开的网页，也只会用2秒，不会固定加载15秒。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从用户提交角度，可以对比不同网速下打开网页时进度条的表现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网速快，那么微信用3秒就进到60%，然后第4秒刷一下到100%；而Safari则是慢慢地移动到30%左右，然后刷的进到100%。&lt;/li&gt;
&lt;li&gt;网速慢，那么微信用15秒加载了90%，只差最后10%加载不出；而Safari则一直处于不足10%的加载状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于小白用户而言，微信的加载条让人『感觉』更快。&lt;/p&gt;
&lt;p&gt;除了这一点，&lt;code&gt;WKWebView&lt;/code&gt;的&lt;code&gt;estimatedProgress&lt;/code&gt;并不会均匀地返回结果。很可能第一次返回结果就是0.5，然后就是0.1。这样Safari加载时，会看到进度条忽快忽慢。&lt;/p&gt;
&lt;p&gt;总结起来：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;estimatedProgress&lt;/code&gt;返回值不均匀，这样进度条进度并不平滑；&lt;/li&gt;
&lt;li&gt;虚假进度给人『更好』的用户体验。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;仿微信网页进度条实现方式Swift4&quot;&gt;&lt;a href=&quot;#仿微信网页进度条实现方式Swift4&quot; class=&quot;headerlink&quot; title=&quot;仿微信网页进度条实现方式Swift4&quot;&gt;&lt;/a&gt;仿微信网页进度条实现方式Swift4&lt;/h2&gt;&lt;p&gt;该实现依赖于对KVO有一定的了解，若不了解，可以参考另一篇：&lt;a href=&quot;http://pkuflint.me/2018/understanding-kvo-in-swift/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;理解KVO - 用Swift在WKWebView中添加进度条&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先，声明必要的变量。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/categories/programming/"/>
    
    
      <category term="Swift" scheme="http://shenxiaobing.com/tags/Swift/"/>
    
      <category term="进度条" scheme="http://shenxiaobing.com/tags/%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    
      <category term="WKWebView" scheme="http://shenxiaobing.com/tags/WKWebView/"/>
    
      <category term="Progress bar" scheme="http://shenxiaobing.com/tags/Progress-bar/"/>
    
  </entry>
  
  <entry>
    <title>理解KVO - 用Swift在WKWebView中添加进度条</title>
    <link href="http://shenxiaobing.com/2018/understanding-kvo-in-swift/"/>
    <id>http://shenxiaobing.com/2018/understanding-kvo-in-swift/</id>
    <published>2018-06-27T21:40:11.000Z</published>
    <updated>2018-07-13T05:39:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>KVO，即Key-value observation，是苹果提供的一种机制，它可以使监听对象在被监听对象的数值发生改变时收到通知，进而去进行响应的处理。</p><p>KVO实现起来比较简单，主要的流程只有3个：</p><ol><li>添加观察者</li><li>在监听方法中处理监听结果</li><li>监听结束后移除观察者</li></ol><p>下面我们用一个实际的例子来说明一下这3个步骤。在App里使用<code>WKWebView</code>来加载网页时，我们希望实现一个在页面顶部的进度条，来表示网页加载的进度。而恰好<code>WKWebView</code>的实例有一个<code>estimatedProgress</code>属性，我们可以在此基础上使用KVO来实现。</p><h2 id="添加观察者"><a href="#添加观察者" class="headerlink" title="添加观察者"></a>添加观察者</h2><p>第一步，是要正确地声明变量。因为KVO是在Objective-C中提供的，要在Swift中使用，被观察的属性必须添加<code>@objc</code>和<code>dynamic</code>关键词，来确保可以正确地被观察到。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明属性，我们的网页视图</span></span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">var</span> webview: <span class="type">WKWebView!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建私有变量，用于添加观察者时创建context参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> progressContext = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>第二步，就是在适合的位置添加观察者。一般来说在<code>viewDidLoad</code>中添加就可以。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 订阅观察webView.estimatedProgress属性</span></span><br><span class="line">webView.addObserver(<span class="keyword">self</span>, forKeyPath: #keyPath(estimatedProgress), options: [.new, .old], context: &amp;progressContext)</span><br></pre></td></tr></table></figure><a id="more"></a><p>对于方法<code>func addObserver(_ observer: NSObject, forKeyPath keyPath: String, options: NSKeyValueObservingOptions = [], context: UnsafeMutableRawPointer?)</code>简单介绍下其参数：</p><ul><li><p>方法消息接受者，就是被监听的对象。不过就上面的代码而言，<code>webView</code>同样也是<code>self</code>当前controller的属性，所以这条消息也可以发送给<code>self</code>，但是<code>keyPath</code>就要相应地修改为<code>keyPath(webView.estimatedProgress)</code>。</p></li><li><p>观察者，即订阅观察的对象，在被观察者数值变化时收到通知。一般来说，就是当前的controller。</p></li><li><p>keyPath，即相对于接受者对象，需要观察的属性。可以直接用明确的字符串<code>&quot;estimatedProgress&quot;</code>来替代<code>#keyPath(estimatedProgress)</code>，但那样直接操作字符串出现打错，还是用#keyPath构造比较简单。</p></li><li><p>options，这里是接收对象时，选择接收的累类型。总共有4种，需要接受就添加其enum值进入数组参数传入：</p><ul><li><code>.new</code>，接收到变化后的新数值。</li><li><code>.old</code>，接收到变化前的老数值。</li><li><code>initial</code>，即要求立刻返回通知给观察者，在注册观察者方法返回之前。</li><li><code>.prior</code>，即是否需要在数值变化前和变化后各发送一条通知，而不是默认的只在变化后发送通知。</li></ul></li><li><p>context，这里的环境变量，一般用于在不同的观察者在观察相同的<code>keyPath</code>时用于区分。上面的添加观察者代码中，我其实没必要传入<code>context</code>，只是为了演示如何创建与传入<code>context</code>。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先是声明私有变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> myContext = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后直接使用`&amp;myContext`作为`context`参数传入。</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="接收被观察者通知并响应处理"><a href="#接收被观察者通知并响应处理" class="headerlink" title="接收被观察者通知并响应处理"></a>接收被观察者通知并响应处理</h2><p>我们的目的是实现进度条，因此需要先添加一条进度条。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setUpWebView</span><span class="params">()</span></span> &#123;</span><br><span class="line">    webView.frame = view.bounds</span><br><span class="line">    webView.navigationDelegate = <span class="keyword">self</span></span><br><span class="line">    webView.autoresizingMask = [.flexibleWidth, .flexibleHeight]</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">URL</span>(string: urlString!) <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"url is nil"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    webView.load(<span class="type">URLRequest</span>(url: url))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建名为progress的进度条</span></span><br><span class="line">    <span class="keyword">let</span> progress = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: webView.frame.width, height: <span class="number">3</span>))</span><br><span class="line">    webView.addSubview(progress)</span><br><span class="line">    <span class="comment">// 之前已经提前声明了progressLayer作为实例变量，方便作为进度条修改</span></span><br><span class="line">    progressLayer = <span class="type">CALayer</span>()</span><br><span class="line">    progressLayer.backgroundColor = <span class="type">APPColor</span>.orange.cgColor</span><br><span class="line">    progress.layer.addSublayer(progressLayer!)</span><br><span class="line"></span><br><span class="line">    view.addSubview(webView)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置进度条进度的方法，这里直接在打开网页时，设置10%的加载进度，让页面加载看起来更快</span></span><br><span class="line">    progressLayer!.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: webView.frame.width * <span class="number">0.1</span>, height: <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进度条配置好了，下面就可以设置监听方法，来处理进度条了。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">observeValue</span><span class="params">(forKeyPath keyPath: String?, of object: <span class="keyword">Any</span>?, change: [NSKeyValueChangeKey : <span class="keyword">Any</span>]?, context: UnsafeMutableRawPointer?)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> keyPath == #keyPath(webView.estimatedProgress) &amp;&amp; context == &amp;progressContext &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> changes = change <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="comment">//请注意这里读取options中数值的方法</span></span><br><span class="line">    <span class="keyword">let</span> newValue = changes[<span class="type">NSKeyValueChangeKey</span>.newKey] <span class="keyword">as</span>? <span class="type">Double</span> ?? <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> oldValue = changes[<span class="type">NSKeyValueChangeKey</span>.oldKey] <span class="keyword">as</span>? <span class="type">Double</span> ?? <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为我们已经设置了进度条为0.1，所以只有在进度大于0.1后再进行变化</span></span><br><span class="line">    <span class="keyword">if</span> newValue &gt; oldValue &amp;&amp; newValue &gt; <span class="number">0.1</span> &#123;</span><br><span class="line">        progressLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: webView.frame.width * <span class="type">CGFloat</span>(newValue), height: <span class="number">3</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当进度为100%时，隐藏progressLayer并将其初始值改为0</span></span><br><span class="line">    <span class="keyword">if</span> newValue == <span class="number">1.0</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> time1 = <span class="type">DispatchTime</span>.now() + <span class="number">0.4</span></span><br><span class="line">        <span class="keyword">let</span> time2 = time1 + <span class="number">0.1</span></span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: time1) &#123;</span><br><span class="line">            <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">            weakself?.progressLayer.opacity = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: time2) &#123;</span><br><span class="line">            <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">            weakself?.progressLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">0</span>, height: <span class="number">3</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="移除观察者"><a href="#移除观察者" class="headerlink" title="移除观察者"></a>移除观察者</h2><p>在不需要监听时，或者至少在<code>观察者</code>要被释放之前，需要移除观察者身份。</p><p>在<code>viewDidDisappear</code>或者其他适当的位置，调用：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">removeObserver(<span class="keyword">self</span>, forKeyPath: #keyPath(webView.estimatedProgress))</span><br></pre></td></tr></table></figure><p>这样利用KVO实现加载进度条的目的已经达成了。</p><h2 id="更Swifty的实现方式：Block-based-KVO"><a href="#更Swifty的实现方式：Block-based-KVO" class="headerlink" title="更Swifty的实现方式：Block-based KVO"></a>更Swifty的实现方式：Block-based KVO</h2><p>在Swift4里，官方推荐了另外Key-value Oberservation的实现方式。简单来说，就是创建一个变量observation、给obervation赋值。赋值实现了既添加观察者又实现响应通知的功能。最后在不需要观察时，直接把observation设置为<code>nil</code>即可。</p><p>针对上面的进度加载条，实现代码如下：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明变量，被观察的属性依然还需要添加@objc和dynamic</span></span><br><span class="line"><span class="meta">@objc</span> <span class="keyword">var</span> webView = <span class="type">WKWebView</span>()</span><br><span class="line"><span class="keyword">var</span> progressLayer: <span class="type">CALayer!</span></span><br><span class="line"><span class="keyword">var</span> progressObervation: <span class="type">NSKeyValueObservation?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置观察</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setupObserver</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 请务必注意方法的写法</span></span><br><span class="line">    progressObservation = observe(\.webView.estimatedProgress, options: [.old, .new], changeHandler: &#123; (<span class="keyword">self</span>, change) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> newValue = change.newValue  ?? <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> oldValue = change.oldValue  ?? <span class="number">0</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"new value is \(newValue)"</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"new value is \(oldValue)"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> newValue &gt; oldValue &amp;&amp; newValue &gt; <span class="number">0.1</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"time to reset new value"</span>)</span><br><span class="line">            <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">            weakself?.progressLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: (weakself?.webView.frame.width)! * <span class="type">CGFloat</span>(newValue), height: <span class="number">3</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> newValue == <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> time1 = <span class="type">DispatchTime</span>.now() + <span class="number">0.4</span></span><br><span class="line">            <span class="keyword">let</span> time2 = time1 + <span class="number">0.1</span></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: time1) &#123;</span><br><span class="line">                <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">                weakself?.progressLayer.opacity = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: time2) &#123;</span><br><span class="line">                <span class="keyword">weak</span> <span class="keyword">var</span> weakself = <span class="keyword">self</span></span><br><span class="line">                weakself?.progressLayer.frame = <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="number">0</span>, height: <span class="number">3</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">destroyObserver</span><span class="params">()</span></span> &#123;</span><br><span class="line">    progressObservation = <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    progressObserver?.invalidate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看来是不是很简单？而且一个NSKeyValueObservation对象只负责观察一个<code>keyPath</code>，非常清晰。同时只用一行代码和闭包，更简洁。</p><p>这里介绍下给observation赋值的方法参数。</p><ul><li><p>receiver，即方法的接受者。上面的方法可以改成：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">progressObserver = webView.observe(\.estimatedProgress, options: [.old, .new], changeHandler: &#123; (webView, change) &#123;</span><br><span class="line"><span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>keyPath，这里的<code>keyPath</code>与上文中的<code>keyPath</code>接收的参数类型不同。这里是<code>KeyPath</code>类型，而上面<code>addObserver</code>方法中的<code>keyPath</code>是字符串。写法是<code>\.property</code>，这里的<code>property</code>是相对于<code>receiver</code>的，所以当<code>receiver</code>是controller时，<code>keyPath</code>就是<code>\.webView.estimatedProgress</code>；而当<code>receiver</code>是<code>webView</code>时，keyPath则是<code>\.estimatedProgress</code>。</p></li><li><p>options，与上文一样，传入可选的<code>.new, .old, .initial, .prior</code>。可不传入options，这样的话，不能从闭包中接收到的<code>change</code>里的<code>newValue</code>和<code>oldValue</code>都是0。</p></li><li><p>closure，闭包接收2个参数，即<code>receiver</code>和作为<code>NSKeyValueObservedChange</code>类型的<code>change</code>。从change可以读取其<code>newValue</code>和<code>oldValue</code>。</p></li></ul><p>最后关于停止监听，有两个办法可选：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁</span></span><br><span class="line">progressObserver = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不销毁，仅仅停止监听</span></span><br><span class="line">progressObserver?.invalidate()</span><br></pre></td></tr></table></figure><p>如果不需要停止，可以不用处理，也不用刻意去移除监听，<code>controller</code>作为<code>observation</code>的<code>owner</code>会自动处理。</p><blockquote><p>本人初学，有错误或疏漏之处，欢迎斧正！</p></blockquote><p>参考文档：</p><ul><li><a href="http://swifter.tips/kvo/" target="_blank" rel="noopener">http://swifter.tips/kvo/</a></li><li><a href="https://cocoacasts.com/key-value-observing-kvo-and-swift-3" target="_blank" rel="noopener">https://cocoacasts.com/key-value-observing-kvo-and-swift-3</a></li><li><a href="https://www.jianshu.com/p/24b3e3ddc946" target="_blank" rel="noopener">https://www.jianshu.com/p/24b3e3ddc946</a></li><li><a href="https://developer.apple.com/documentation/swift/cocoa_design_patterns/using_key_value_observing_in_swift" target="_blank" rel="noopener">Using Key-Value Observing in Swift | Apple Developer Documentation</a></li><li><a href="https://nshipster.com/key-value-observing/" target="_blank" rel="noopener">https://nshipster.com/key-value-observing/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;KVO，即Key-value observation，是苹果提供的一种机制，它可以使监听对象在被监听对象的数值发生改变时收到通知，进而去进行响应的处理。&lt;/p&gt;
&lt;p&gt;KVO实现起来比较简单，主要的流程只有3个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加观察者&lt;/li&gt;
&lt;li&gt;在监听方法中处理监听结果&lt;/li&gt;
&lt;li&gt;监听结束后移除观察者&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面我们用一个实际的例子来说明一下这3个步骤。在App里使用&lt;code&gt;WKWebView&lt;/code&gt;来加载网页时，我们希望实现一个在页面顶部的进度条，来表示网页加载的进度。而恰好&lt;code&gt;WKWebView&lt;/code&gt;的实例有一个&lt;code&gt;estimatedProgress&lt;/code&gt;属性，我们可以在此基础上使用KVO来实现。&lt;/p&gt;
&lt;h2 id=&quot;添加观察者&quot;&gt;&lt;a href=&quot;#添加观察者&quot; class=&quot;headerlink&quot; title=&quot;添加观察者&quot;&gt;&lt;/a&gt;添加观察者&lt;/h2&gt;&lt;p&gt;第一步，是要正确地声明变量。因为KVO是在Objective-C中提供的，要在Swift中使用，被观察的属性必须添加&lt;code&gt;@objc&lt;/code&gt;和&lt;code&gt;dynamic&lt;/code&gt;关键词，来确保可以正确地被观察到。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 声明属性，我们的网页视图&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@objc&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; webview: &lt;span class=&quot;type&quot;&gt;WKWebView!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 创建私有变量，用于添加观察者时创建context参数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; progressContext = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;第二步，就是在适合的位置添加观察者。一般来说在&lt;code&gt;viewDidLoad&lt;/code&gt;中添加就可以。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 订阅观察webView.estimatedProgress属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;webView.addObserver(&lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;, forKeyPath: #keyPath(estimatedProgress), options: [.new, .old], context: &amp;amp;progressContext)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/categories/programming/"/>
    
    
      <category term="Swift" scheme="http://shenxiaobing.com/tags/Swift/"/>
    
      <category term="KVO" scheme="http://shenxiaobing.com/tags/KVO/"/>
    
  </entry>
  
  <entry>
    <title>苹果内购接入的坑与核心流程 - Swift</title>
    <link href="http://shenxiaobing.com/2018/swift-iap-pitfalls/"/>
    <id>http://shenxiaobing.com/2018/swift-iap-pitfalls/</id>
    <published>2018-06-27T11:56:09.000Z</published>
    <updated>2018-07-13T05:46:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>通过苹果开发文档、搜索与挣扎摸索，我已经在App上实现了【消耗型商品】的内购。总结流程如下：</p><ol><li>完成必须的准备工作</li><li>用有效的商品id创建<code>SKProductRequest</code>请求苹果服务器返回商品（<code>SKProduct</code>）。</li><li>用返回的有效的商品创建payment，并将payment加入苹果的支付队列。</li><li>监听队列，并根据监听到的交易状态进行适当的处理，尤其需要在交易完毕时关闭交易。</li></ol><p>这方面的文档，我觉得苹果官方的Programming Guide就写的很好。可以仔细读一下。</p><h2 id="我实际遇到的坑"><a href="#我实际遇到的坑" class="headerlink" title="我实际遇到的坑"></a>我实际遇到的坑</h2><ol><li><p>必须先签署协议才能进行内购开发，否则无法返回商品。</p></li><li><p>创建沙箱测试员时，密码必须是强密码，即同时包含大写字母、小写字母和数字。否则，会报错：Unknown Errors while creating Sandbox Tester, Please check Error Log, email=xxx。</p></li><li><p>请求商品的<code>SKProductRequest</code>实例的<code>delegate</code>必须在离开页面时<code>viewDidDisappear</code>设置为<code>nil</code>，因为即使你已经离开了页面，苹果依然会尝试向<code>SKProductRequest</code>的代理发送消息，然后App就崩溃了。</p></li><li><p>必须在<code>AppDelegate</code>中声明遵守<code>SKPaymentTransactionObserver</code>协议、实现协议方法<code>updatedTransactions</code>、并在<code>didFinishLaunching</code>方法中加入如下代码<code>SKPaymentQueue.default().add(self)</code>。</p><p>这一行代码是将AppDelegate作为内购队列的监听者。这样，即使你离开了内购页面、即使上次支付未完成等情况，都能够在这里得到及时的处理。</p><p>如果不在这里这么做，可能的报错有：<br><code>This In-App purchase has already been bought. It will be restored for free.</code></p><p>如果需要在内购页面上实现交互，可以也在内购界面上添加监听，并进行交互上面适当的处理。但无路如何，不能省掉<code>AppDelegate</code>中的那部分。</p></li></ol><h2 id="内购接入核心流程"><a href="#内购接入核心流程" class="headerlink" title="内购接入核心流程"></a>内购接入核心流程</h2><p>以下是我实际接入中使用的代码。</p><a id="more"></a><h3 id="请求商品"><a href="#请求商品" class="headerlink" title="请求商品"></a>请求商品</h3><p>商品是由苹果服务器返回的，请求有三个步骤：获取商品id字符串、发起请求、代理协议中处理结果。</p><h4 id="获取商品id"><a href="#获取商品id" class="headerlink" title="获取商品id"></a>获取商品id</h4><p>获取商品id，这个可以请求服务器，也可以保存在App上。我的App是用的后者。</p><p>首先创建一个名为<code>ProductID</code>的<code>plist</code>文件。文件内容是一个<code>Array</code>，里面是保存的商品id字符串。</p><blockquote><p>这里需要说明的是，商品id，即product identifier，就是你在iTunes Connect 内购列表页面上看到的商品id，不需要再拼接包名bundle identifier。</p></blockquote><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Get product id from plist.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">predefinedProductIdentifiers</span><span class="params">()</span></span> -&gt; [<span class="type">String</span>]? &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> url = <span class="type">Bundle</span>.main.url(forResource: <span class="string">"ProductID"</span>, withExtension: <span class="string">"plist"</span>) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> productIdentifiers = <span class="type">NSArray</span>(contentsOf: url) <span class="keyword">as</span>? [<span class="type">String</span>] <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> productIdentifiers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="验证商品id"><a href="#验证商品id" class="headerlink" title="验证商品id"></a>验证商品id</h4><p>请求苹果服务器验证我们提供的商品id是否有效。不过记得要把内购Controller设置为遵循<code>SKProductsRequestDelegate</code>协议，否则无法收到通知。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateProductIdentifers</span><span class="params">(with productIdentifiers: [String])</span></span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> <span class="keyword">set</span> = <span class="type">NSSet</span>(array: productIdentifiers) <span class="keyword">as</span>? <span class="type">Set</span>&lt;<span class="type">String</span>&gt; <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">    <span class="keyword">let</span> productRequest = <span class="type">SKProductsRequest</span>(productIdentifiers: <span class="keyword">set</span>)</span><br><span class="line">    request = productRequest<span class="comment">// 将request强引用，避免在完成前被提前释放；不过也务必在离开页面后，将request.delegate设置为nil</span></span><br><span class="line">    productRequest.delegate = <span class="keyword">self</span></span><br><span class="line">    productRequest.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在协议中处理商品"><a href="#在协议中处理商品" class="headerlink" title="在协议中处理商品"></a>在协议中处理商品</h4><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">productsRequest</span><span class="params">(<span class="number">_</span> request: SKProductsRequest, didReceive response: SKProductsResponse)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"received product response"</span>)</span><br><span class="line">    products = response.products<span class="comment">// 将获取到的商品存储在界面实例变量，再次购买时不需要重复请求商品</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面是继续进行支付请求</span></span><br></pre></td></tr></table></figure><h3 id="请求支付"><a href="#请求支付" class="headerlink" title="请求支付"></a>请求支付</h3><p>在获取了有效商品后，就可以用商品创建<code>SKPayment</code>，并将<code>payment</code>实例加入苹果支付队列中。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">requestPayment</span><span class="params">(with product: SKProduct)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> payment = <span class="type">SKPayment</span>(product: product)</span><br><span class="line">    <span class="type">SKPaymentQueue</span>.<span class="keyword">default</span>().add(payment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理支付"><a href="#处理支付" class="headerlink" title="处理支付"></a>处理支付</h3><p>这个步骤核心的点就是创建并添加<code>SKPaymentTransactionObserver</code>。</p><h4 id="AppDelegate添加observer"><a href="#AppDelegate添加observer" class="headerlink" title="AppDelegate添加observer"></a>AppDelegate添加observer</h4><ol><li><p>在AppDelegate声明遵循<code>SKPaymentTransactionObserver</code>协议。</p></li><li><p>实现协议方法，实现后实现者就可以作为observer。</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">*<span class="comment">// MARK: - SK Product Request Delegate*</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">paymentQueue</span><span class="params">(<span class="number">_</span> queue: SKPaymentQueue, updatedTransactions transactions: [SKPaymentTransaction])</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> transaction <span class="keyword">in</span> transactions &#123;</span><br><span class="line">        <span class="keyword">switch</span> transaction.transactionState &#123;</span><br><span class="line">        <span class="keyword">case</span> .purchasing:</span><br><span class="line">            <span class="type">DispatchQueue</span>.main.async &#123;</span><br><span class="line">                <span class="type">SVProgressHUD</span>.show(withStatus: <span class="type">NSLocalizedString</span>(<span class="string">"订单处理中"</span>, comment: <span class="string">"请求支付提示"</span> ))</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> .deferred:</span><br><span class="line">            <span class="type">SVProgressHUD</span>.show(withStatus: <span class="type">NSLocalizedString</span>(<span class="string">"订单处理中"</span>, comment: <span class="string">"请求支付提示"</span> ))</span><br><span class="line">        <span class="keyword">case</span> .purchased:</span><br><span class="line">        <span class="comment">// 购买成功，此处需要发送玩家道具、保存凭证等动作。    </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当然交易完毕后，一定要手动关闭            </span></span><br><span class="line">        <span class="type">SKPaymentQueue</span>.<span class="keyword">default</span>().finishTransaction(transaction)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> .failed:</span><br><span class="line">        <span class="comment">// 交易失败，也要关闭交易         </span></span><br><span class="line">        <span class="type">SKPaymentQueue</span>.<span class="keyword">default</span>().finishTransaction(transaction)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> .restored:</span><br><span class="line">        <span class="comment">// 恢复订单</span></span><br><span class="line">        <span class="type">SKPaymentQueue</span>.<span class="keyword">default</span>().finishTransaction(transaction)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"other situation"</span>)</span><br><span class="line">        <span class="type">SKPaymentQueue</span>.<span class="keyword">default</span>().finishTransaction(transaction)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>didFinishLaunchingWithOptions</code>方法中添加观察者：<br> <code>SKPaymentQueue.default().add(self)</code></p></li></ol><h4 id="其他界面添加observer"><a href="#其他界面添加observer" class="headerlink" title="其他界面添加observer"></a>其他界面添加observer</h4><p>假如用户一直呆在内购界面等待结束，我们很可能需要在内购界面也要一套前端的展示机制。跟AppDelegate的流程一样，我们将内购界面也作为<code>SKPaymentTransactionObserver</code>添加到队列中。这样，内购界面也能收到通知了。</p><blockquote><p>离开其他界面时，记得调用<code>SKPaymentQueue.default().remove(self)</code>来移除observer，否则可能会崩溃。</p></blockquote><p>当内购界面可用的时候，就可以让内购界面去处理一些前端交互，比如弹出窗口，关闭当前界面等。</p><h3 id="恢复支付"><a href="#恢复支付" class="headerlink" title="恢复支付"></a>恢复支付</h3><p>如果用户购买的是非消耗型商品，比如是一个去广告服务。用户卸载后，如果重新安装回来，是可以申请恢复记录的。我使用的办法比较简陋，没有用加密和服务端验证，只是对比了下<code>transaction.payment.productIdentifier</code>。</p><p>首先，在用户发起「恢复购买记录」后，调用<code>SKPaymentQueue.default().restoreCompletedTransactions()</code>。</p><p>然后，在<code>updateTransactions</code>协议方法中，在<code>case .restored</code>中验证用户的<code>transaction.payment.productIdentifier</code>，若符合，则修改<code>UerDefaults</code>中的去广告标记。</p><blockquote><p>本人初学，有不当或错漏之处，感谢斧正！</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通过苹果开发文档、搜索与挣扎摸索，我已经在App上实现了【消耗型商品】的内购。总结流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成必须的准备工作&lt;/li&gt;
&lt;li&gt;用有效的商品id创建&lt;code&gt;SKProductRequest&lt;/code&gt;请求苹果服务器返回商品（&lt;code&gt;SKProduct&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;用返回的有效的商品创建payment，并将payment加入苹果的支付队列。&lt;/li&gt;
&lt;li&gt;监听队列，并根据监听到的交易状态进行适当的处理，尤其需要在交易完毕时关闭交易。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这方面的文档，我觉得苹果官方的Programming Guide就写的很好。可以仔细读一下。&lt;/p&gt;
&lt;h2 id=&quot;我实际遇到的坑&quot;&gt;&lt;a href=&quot;#我实际遇到的坑&quot; class=&quot;headerlink&quot; title=&quot;我实际遇到的坑&quot;&gt;&lt;/a&gt;我实际遇到的坑&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;必须先签署协议才能进行内购开发，否则无法返回商品。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建沙箱测试员时，密码必须是强密码，即同时包含大写字母、小写字母和数字。否则，会报错：Unknown Errors while creating Sandbox Tester, Please check Error Log, email=xxx。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;请求商品的&lt;code&gt;SKProductRequest&lt;/code&gt;实例的&lt;code&gt;delegate&lt;/code&gt;必须在离开页面时&lt;code&gt;viewDidDisappear&lt;/code&gt;设置为&lt;code&gt;nil&lt;/code&gt;，因为即使你已经离开了页面，苹果依然会尝试向&lt;code&gt;SKProductRequest&lt;/code&gt;的代理发送消息，然后App就崩溃了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;必须在&lt;code&gt;AppDelegate&lt;/code&gt;中声明遵守&lt;code&gt;SKPaymentTransactionObserver&lt;/code&gt;协议、实现协议方法&lt;code&gt;updatedTransactions&lt;/code&gt;、并在&lt;code&gt;didFinishLaunching&lt;/code&gt;方法中加入如下代码&lt;code&gt;SKPaymentQueue.default().add(self)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这一行代码是将AppDelegate作为内购队列的监听者。这样，即使你离开了内购页面、即使上次支付未完成等情况，都能够在这里得到及时的处理。&lt;/p&gt;
&lt;p&gt;如果不在这里这么做，可能的报错有：&lt;br&gt;&lt;code&gt;This In-App purchase has already been bought. It will be restored for free.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果需要在内购页面上实现交互，可以也在内购界面上添加监听，并进行交互上面适当的处理。但无路如何，不能省掉&lt;code&gt;AppDelegate&lt;/code&gt;中的那部分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;内购接入核心流程&quot;&gt;&lt;a href=&quot;#内购接入核心流程&quot; class=&quot;headerlink&quot; title=&quot;内购接入核心流程&quot;&gt;&lt;/a&gt;内购接入核心流程&lt;/h2&gt;&lt;p&gt;以下是我实际接入中使用的代码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/categories/programming/"/>
    
    
      <category term="Swift" scheme="http://shenxiaobing.com/tags/Swift/"/>
    
      <category term="坑" scheme="http://shenxiaobing.com/tags/%E5%9D%91/"/>
    
      <category term="IAP" scheme="http://shenxiaobing.com/tags/IAP/"/>
    
      <category term="In App Purchase" scheme="http://shenxiaobing.com/tags/In-App-Purchase/"/>
    
      <category term="内购" scheme="http://shenxiaobing.com/tags/%E5%86%85%E8%B4%AD/"/>
    
  </entry>
  
  <entry>
    <title>自学路上的坑01 - Scheme勾选项带来的一些列问题</title>
    <link href="http://shenxiaobing.com/2018/self-taught-swift-lesson-01/"/>
    <id>http://shenxiaobing.com/2018/self-taught-swift-lesson-01/</id>
    <published>2018-06-19T23:43:51.000Z</published>
    <updated>2018-06-19T23:54:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">如果你的问题在网上找不到，那一定是你犯了一个低级错误。</blockquote><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><blockquote><p><code>Edit Scheme</code>中勾选<code>Malloc Stack</code>会导致每次Xcode覆盖安装App都预先占用一定量的数据存储空间，且由于某种原因，本来每次存储几十KB的数据结果占用了几十MB；同时，这个勾选项还会导致<code>Instrument - Leak</code>界面出现名为<code>&lt;Allocated Prior To Attach&gt;</code>的Leak。</p></blockquote><p><code>Edit Scheme</code>中<code>Zombie Object</code>调试结束要记得关掉，否则会在<code>Instrument - Leak</code>界面产生大量的名为<code>Zombie Object</code>的Leak。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>有天突然发现iPhone储存空间管理界面，显示我的App占用了3.7GB的文稿数据空间。震惊之余，立马用模拟器和真机重新安装，边跑边记录文稿数据变化情况。经过整理如下有2个问题表现：</p><ol><li><p>真机每次跑完一次步，会增加10几MB的文稿数据存储空间。</p></li><li><p>真机每次Xcode覆盖安装都会额外增加8MB的文稿数据存储空间。</p></li><li><p>在<code>Instruments - Leak</code>中有数不尽的Leaks，其中占比最大的是叫做<code>&lt;Allocated Prior To Attach&gt;</code>的Leak。</p><p> <img alt data-src="http://p94ibkeg8.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-20%2007.09.57.png"></p></li></ol><p>一通搜索，尝试了以下几个方案：</p><ol><li>将工程代码中闭包里的被强引用的<code>self</code>全部改为弱引用。虽然这点学了点东西，不过对于当前的问题，没有实际效果。</li><li>在<code>Leak</code>界面看到了<code>Zombie Object</code>，想到之前修改过<code>Scheme</code>，于是前往将<code>Zombie Object</code>反选。之后Leak界面一下子少了很多所谓的<code>Leak</code>。</li><li>数据量大的问题，一筹莫展之际，去看了<code>Xcode</code>运行状态中的<code>Disk</code>，发现确实每次都有7MB新增的空间，于是拿这个界面的关键词进行搜索，结果还是<code>Scheme</code>的锅。在<code>Edit Scheme</code>中反选<code>Malloc Stack</code>，问题立马解决了。</li><li>步骤三做了以后，<code>Leak</code>界面就没有<code>&lt;Allocated Prior To Attach&gt;</code>的Leak名称了。</li></ol><h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p>整个过程，前后搜索、尝试、验证，花了我大约5个小时。就是这样的时刻，让我觉得新手自学有太多的艰难。有些东西，对于别人几乎像是常识般；而对于新手，就是一个有待解决的问题，而正因为在别人眼里是常识，导致新手很难在网络上找到现成的答案。</p><blockquote><p>如果你的问题在网上找不到答案，那一定是你犯了一个低级错误。</p></blockquote><p>我之前就有这样的意识了，也许以后可以考虑先把问题搁置起来，而不必第一时间就要找到解决方案，尤其是网上搜不到同类问题的时候。</p><p>不过，今天这番至少知道了：要在闭包里用弱引用，怎样使用Instrument - Leak，以及查看Xcode的运行状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote class=&quot;blockquote-center&quot;&gt;如果你的问题在网上找不到，那一定是你犯了一个低级错误。&lt;/blockquote&gt;

&lt;h2 id=&quot;结论&quot;&gt;&lt;a href=&quot;#结论&quot; class=&quot;headerlink&quot; title=&quot;结论&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/categories/programming/"/>
    
    
      <category term="iOS" scheme="http://shenxiaobing.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://shenxiaobing.com/tags/Swift/"/>
    
      <category term="自学" scheme="http://shenxiaobing.com/tags/%E8%87%AA%E5%AD%A6/"/>
    
      <category term="坑" scheme="http://shenxiaobing.com/tags/%E5%9D%91/"/>
    
      <category term="Scheme" scheme="http://shenxiaobing.com/tags/Scheme/"/>
    
  </entry>
  
  <entry>
    <title>自学编程6年，从入门到放弃</title>
    <link href="http://shenxiaobing.com/2018/from-zero-to-quit/"/>
    <id>http://shenxiaobing.com/2018/from-zero-to-quit/</id>
    <published>2018-06-19T18:49:00.000Z</published>
    <updated>2018-06-19T19:08:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center">我会用4种编程语言写出Hello World！</blockquote><h2 id="2013年-C语言"><a href="#2013年-C语言" class="headerlink" title="2013年 C语言"></a>2013年 C语言</h2><p>自学编程的想法，最早应该可以追溯到2013年，证据就是我于当时写下的博客，以及博客中提到的新买的、后来被村长带走的《C语言编程》。我已经记不得当时为何要学编程，为何要从C语言开始，以及那本书我看了多少。</p><p>不过，打出上面最后一句话后，我还是想起来了：当时我没能用C语言打出<code>Hello World!</code>就放弃了，因为没弄好编译器。</p><a id="more"></a><h2 id="2014年-购入Macbook"><a href="#2014年-购入Macbook" class="headerlink" title="2014年 购入Macbook"></a>2014年 购入Macbook</h2><p>这一年，我花了六千大洋买了最低配的Macbook Air 11.6英寸版本。</p><p>为什么要买？在我的记忆里，应该就是为了编写iOS App。不过，我并没有在这一年留下任何的学习笔记。</p><h2 id="2015年-Java语言"><a href="#2015年-Java语言" class="headerlink" title="2015年 Java语言"></a>2015年 Java语言</h2><p>这一年工作中略有些空闲。在工作时间间隙和下班后，我开始学习Java。这时候学的是网易公开课上的斯坦福大学的CS106A课程。</p><p>我清晰地记得这波自学最后一次编程是用Java语言在画布上画出三节火车车厢。而印象笔记显示我只学到了教材第6章：Methods。</p><h2 id="2016年-Objective-C语言"><a href="#2016年-Objective-C语言" class="headerlink" title="2016年 Objective-C语言"></a>2016年 Objective-C语言</h2><p>机缘巧合，凭借我学到的这点皮毛，我从游戏运营岗位跳到一家云计算公司做售后技术支持，平时就是解答下我们的商业SDK和其他产品使用和接入中的一些问题。我有了工作时间学习编程的理由和一定的时间。</p><p>我开始跟随王寒翻译的Ray Wenderlich的iOS学习教材学习，接着跟着我自己买的书籍，也看过一点网易公开课上的斯坦福大学白胡子老师的课。</p><p>最后的成果，就是我用Objective-C模仿【雨时】开发了一个天气App。基本的界面、天气请求、设置等都已经做的差不多了，大约完成度有7成。</p><p>不过，项目一旦搁置，可能就永远捡不起了。现在这个做了一半的项目还在我的电脑上。</p><h2 id="2017年-Python语言"><a href="#2017年-Python语言" class="headerlink" title="2017年 Python语言"></a>2017年 Python语言</h2><p>在做技术支持的最后一段日子，我开始学习Python。我想用Python写一些工作上可以用到的工具，比如：接口检测脚本，但Objective-C做不到。</p><p>我找到了网上的廖雪峰的Python课程开始学习，基本完成了教程的内容并进行笔记，不过并未完成最后的实战。</p><p>我很快就离职了，最终也没有找到实际使用Python的场景。</p><h2 id="2018年-Swift语言"><a href="#2018年-Swift语言" class="headerlink" title="2018年 Swift语言"></a>2018年 Swift语言</h2><p>我从Udemy上购买了一套Swift课程。我用了一个多月的时间跟着完成了Swift开发相关的部分。我开始开发自己的App，这次是一个跑步App。现在App的开发进度也基本上有八成了。</p><p>现在我又开始复习学过的Python内容。</p><h2 id="我该学什么语言？"><a href="#我该学什么语言？" class="headerlink" title="我该学什么语言？"></a>我该学什么语言？</h2><p>我也曾经有这样的疑问，而且上面提到的几乎每一年我应该都有这样的疑问，即使我已经在学习某种语言的时候，我还是会有疑问，尤其是当我遇到瓶颈和阻碍的时候。</p><p>大约是2018年初，我可能再次提出了这个疑问。我看到廖雪峰也回答说Java开始学习编程。于是，我又捡起了斯坦福大学CS106A网络课程。这次，我学到了第19节课，第19节的标题是：Interface &amp; Map。</p><p>但是，这个问题重要吗？你看了我的经历，你还觉得重要吗？6年了，从自学编程的想法萌发直到现在，我学习了4种编程语言的基本语法。但这有什么用呢？</p><p>中肯地说，我这次在学Swift时，很多概念就很快就能理解，因为之前学过Objective-C，所以通用的代理、通知、第三方库、界面等都不再是问题。所以，实际上每段学习，都有它的价值。这是肯定的，只是，就结果而言，都不能令人满意。毕竟，精通一门语言比仅仅熟悉10门语言的语法要强上10倍吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;我会用4种编程语言写出Hello World！&lt;/blockquote&gt;

&lt;h2 id=&quot;2013年-C语言&quot;&gt;&lt;a href=&quot;#2013年-C语言&quot; class=&quot;headerlink&quot; title=&quot;2013年 C语言&quot;&gt;&lt;/a&gt;2013年 C语言&lt;/h2&gt;&lt;p&gt;自学编程的想法，最早应该可以追溯到2013年，证据就是我于当时写下的博客，以及博客中提到的新买的、后来被村长带走的《C语言编程》。我已经记不得当时为何要学编程，为何要从C语言开始，以及那本书我看了多少。&lt;/p&gt;
&lt;p&gt;不过，打出上面最后一句话后，我还是想起来了：当时我没能用C语言打出&lt;code&gt;Hello World!&lt;/code&gt;就放弃了，因为没弄好编译器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://shenxiaobing.com/categories/essay/"/>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一天</title>
    <link href="http://shenxiaobing.com/2018/one-day/"/>
    <id>http://shenxiaobing.com/2018/one-day/</id>
    <published>2018-05-14T08:30:02.000Z</published>
    <updated>2018-05-14T09:16:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>我下楼去买可乐。</p><p>走下楼梯时，看到楼梯上靠墙坐着一个头发花白的中年人。他低着头，在玩开心消消乐。我走过了，却还是忍不住回头看了他一样。他很严肃。</p><p>这是我今天喝的第三罐可乐。可乐倒进嘴里，苦味已经盖过了甜味。我只能喝可乐。喝酒太辣太苦，而我也没有配得上酒的忧愁或把酒言欢的朋友。我有的只是这种说不出是甜还是苦的平常生活。</p><a id="more"></a><p>是不是太平常了呢？我七点二十起床，有时会赖到七点半。如果前一天晚上没洗澡，那么早上会洗个澡。妈在这里帮忙带孩子，早上她也会准备早饭。吃完早饭，大约八点到八点十分之间离家去上班。我先走十几分钟到一个停放了功能正常的共享单车的公司门口，然后骑车5分钟到地铁站。如果是上一周，进了地铁，我会掏出Kindle来读我下载的古龙小说。今天我却不想。我不关心七种武器那最后一种是怎样的。</p><p>话说回来，是古龙小说不合我的胃口，还是我已经过了为武侠小说着迷的年纪？我看了《多情剑客无情剑》和《七种武器》的前75%部分，并没有欲罢不能的感觉，在思想深度与触动人方面，连同时阅读的另一本《无声告白》都比不上。</p><p>继续说回地铁上，今天我没有掏出Kindle。我今天起来心情就不好，好像又忘记了自己的目标，或者说，又开始在意自己的没有目标的状态。我想要不就随便想点事儿吧，就在这地铁碾压铁轨的有规律的声响中。要不要记录下自己的想法呢？我伸手进口袋掏出了手机。我什么也没有记录，却看了一路的火影漫画，昨天晚上刚下载的APP。</p><p>三忍大战，当时多么激动人心的情节。在漫画上，缺少了音乐、配音、画面的渲染，让感染力减弱了不少。而且我还是二刷，几乎是无感，只是会想起当时自己应该是很激动的。</p><p>到公司后去楼下的自动售卖机买可乐。想着这次要不用支付宝吧。结果用支付宝扫描后反而报错了。</p><p>今天的主要任务就是测试一个新开发完成的麻将玩法。其他同事可以搞定，我就安排与追踪下进度。产品还是有很多小问题，让人有点无可奈何。我又列了下当前主要的模块，安排了下优先级。</p><p>然后，我又开始出离，观察自己现在的这个状态。我需要一罐可乐。</p><p>于是，我下楼去买可乐，今天的第三罐可乐。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我下楼去买可乐。&lt;/p&gt;
&lt;p&gt;走下楼梯时，看到楼梯上靠墙坐着一个头发花白的中年人。他低着头，在玩开心消消乐。我走过了，却还是忍不住回头看了他一样。他很严肃。&lt;/p&gt;
&lt;p&gt;这是我今天喝的第三罐可乐。可乐倒进嘴里，苦味已经盖过了甜味。我只能喝可乐。喝酒太辣太苦，而我也没有配得上酒的忧愁或把酒言欢的朋友。我有的只是这种说不出是甜还是苦的平常生活。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://shenxiaobing.com/categories/essay/"/>
    
    
      <category term="胡思乱想" scheme="http://shenxiaobing.com/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Core Data入门</title>
    <link href="http://shenxiaobing.com/2018/Beginning-Core-Data/"/>
    <id>http://shenxiaobing.com/2018/Beginning-Core-Data/</id>
    <published>2018-04-26T05:49:23.000Z</published>
    <updated>2018-04-27T15:53:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>在iOS App中，如果要存储的数据量比较大，就会使用Core Data。这里汇总了下使用Core Data的基本方式。</p><ol><li>添加Core Data</li><li>配置Core Data中的Entity</li><li>添加新数据</li><li>读取与修改数据</li><li>使用NSPredicate筛选数据</li><li>删除数据</li><li>保存数据</li><li>一份NSPredicate使用备忘清单</li></ol><a id="more"></a><h2 id="添加Core-Data"><a href="#添加Core-Data" class="headerlink" title="添加Core Data"></a>添加Core Data</h2><p>如果在创建项目时没有勾选Using Core Data，可以手动创建Core Data。手动创建Core Data的方式如下：</p><ol><li>在项目中创建新的文件，类型为：Core Data。</li><li>添加相关的预设方法进入<code>AppDelegate</code>中，相关方法如下：</li></ol><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationWillTerminate</span><span class="params">(<span class="number">_</span> application: UIApplication)</span></span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.saveContext()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - Core Data stack</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> persistentContainer: <span class="type">NSPersistentContainer</span> = &#123;</span><br><span class="line">    <span class="keyword">let</span> container = <span class="type">NSPersistentContainer</span>(name: <span class="string">"DataModel"</span>)</span><br><span class="line">    container.loadPersistentStores(completionHandler: &#123; </span><br><span class="line">    (storeDescription, error) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> error = error <span class="keyword">as</span> <span class="type">NSError?</span> &#123;</span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Unresolved error \(error), \(error.userInfo)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> container</span><br><span class="line">&#125;()</span><br><span class="line">    </span><br><span class="line"><span class="comment">// MARK: - Core Data Saving support</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveContext</span> <span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> context = persistentContainer.viewContext</span><br><span class="line">    <span class="keyword">if</span> context.hasChanges &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> context.save()</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> nserror = error <span class="keyword">as</span> <span class="type">NSError</span></span><br><span class="line">            <span class="built_in">fatalError</span>(<span class="string">"Unresolved error \(nserror), \(nserror.userInfo)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个方法是Xcode为使用Core Data的新项目自动创建的，我这里只是拷贝了进来。</p><h2 id="配置Core-Data中的Entity"><a href="#配置Core-Data中的Entity" class="headerlink" title="配置Core Data中的Entity"></a>配置Core Data中的Entity</h2><p>点击创建的Core Data文件，我们在界面中配置Entity。Core Data中的Entity，就相当于编程语言中的Class，类比数据库就是一个Table。Entity的Attribute，就是Class的Property，Table中的Field。</p><p>举个例子：<br>我的To-do App中需要两个类，一个是Category，代表清单的类别；一个是Item，代表清单中的具体事项。</p><p>在Core Data中创建2个Entity分别是Category和Item。Category设置1个Attribute：name，类型为String；Item设置2个Attribute：title和done，分别是String和Bool类型。</p><p>然后配置Category和Item的关系，将Category对Item的关系设置为一对多，而Item对Category的关系设置为一对一，毕竟一个事项只有一个类别。</p><h2 id="添加新数据"><a href="#添加新数据" class="headerlink" title="添加新数据"></a>添加新数据</h2><p>无论要对Core Data做什么，都需要用到<code>context</code>，因此需要在用到Core Data的类中添加一个实例变量：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">let context = (UIApplication<span class="selector-class">.shared</span><span class="selector-class">.delegate</span></span><br><span class="line">as! AppDelegate)<span class="selector-class">.persistentContainer</span><span class="selector-class">.viewContext</span></span><br></pre></td></tr></table></figure><p>我要添加一个新的Category，那么从Core Data的Entity中创建对象是这样的：</p><figure class="highlight haxe"><table><tr><td class="code"><pre><span class="line">let <span class="keyword">new</span><span class="type">Category</span> = Category(context: <span class="type">self</span>.context)   <span class="comment">// 用Core Data中的Entity创建对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span><span class="type">Category</span>.name = <span class="string">"Work"</span> <span class="comment">// 设置Entity对象的必要attribute</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将新的category对象加入categoryList，而categoryList则指向是从数据库中读取的数据。</span></span><br><span class="line">categoryList.append(<span class="keyword">new</span><span class="type">Category</span>)</span><br></pre></td></tr></table></figure><h2 id="读取与修改数据"><a href="#读取与修改数据" class="headerlink" title="读取与修改数据"></a>读取与修改数据</h2><p>从Core Data中读取全部数据：</p><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> request: <span class="type">NSFetchRequest</span>&lt;<span class="type">Category</span>&gt; = <span class="type">Category</span>.fetchRequest()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 将实例变量categoryList指向读取的数据</span></span><br><span class="line">        categoryList = <span class="keyword">try</span> context.fetch(request)  </span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Error fetching request, \(error)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而要修改数据，则可以选择使用以下两种方式之一：</p><figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将刚加入的Work改为Shopping</span></span><br><span class="line">categoryList[<span class="number">0</span>]<span class="selector-class">.name</span> = <span class="string">"Shopping"</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">// 将刚才的Shopping category的name attribute改为"Chores"</span></span><br><span class="line">categoryList[<span class="number">0</span>].setValue(<span class="string">"Chores"</span>, forKey: <span class="string">"name"</span>)</span><br></pre></td></tr></table></figure><h2 id="使用Predicate筛选数据"><a href="#使用Predicate筛选数据" class="headerlink" title="使用Predicate筛选数据"></a>使用Predicate筛选数据</h2><p>有时我们不需要读取数据库中的所有数据，比如我只想读取：Category是Work的所有待办事项Item；或者我想搜索Work类别里待办事项中名字里包含”urgent”的事项，这时，我们这样写：</p><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> selectedCategory = <span class="string">"Work"</span>  // 清单类别</span><br><span class="line"><span class="keyword">let</span> searchKeyword = <span class="string">"urgent"</span>  // 搜索筛选的关键词</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reques<span class="variable">t:</span> NSFetchRequest<span class="symbol">&lt;Item&gt;</span> = Item.fetchRequest()</span><br><span class="line"></span><br><span class="line">// 此处parentCategory是Core Data中Item的一个关系设定，将关系指向Category并命名为parentCategory。</span><br><span class="line"><span class="keyword">let</span> predicate1 = NSPredicate(forma<span class="variable">t:</span> <span class="string">"parentCategory.name MATCHES %@"</span>, selectedCategory) </span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> predicate2 = NSPredicate(forma<span class="variable">t:</span> <span class="string">"title CONTAINS[cd] %@"</span>, searchKeyword)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compoundPredicate = NSCompoundPredicate(andPredicateWithSubpredicate<span class="variable">s:</span> [predicate1, predicate2])</span><br><span class="line"></span><br><span class="line">request.predicate = compoundPredicate</span><br><span class="line">request.sortDescriptors = [NSSortDescriptor(key: <span class="string">"title"</span>, ascendin<span class="variable">g:</span> true)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    self.selectedItems = <span class="keyword">try</span> context.fetch(request)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">"Error fetching data, \(error)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><p>读取数据后，直接从指向数据的变量中，删除对应的数据即可。</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">self</span><span class="selector-class">.context</span><span class="selector-class">.delete</span>(selectedItems[<span class="number">1</span>]) <span class="comment">// 从数据中移除</span></span><br><span class="line"><span class="selector-tag">selectedItems</span><span class="selector-class">.remove</span>(<span class="attribute">at</span>: <span class="number">1</span>) <span class="comment">// 接着更新下指向数据的实例变量</span></span><br></pre></td></tr></table></figure><h2 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h2><p>对Core Data进行新增、修改、删除后，都要进行保存才能生效。</p><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    try <span class="built_in">context</span>.<span class="built_in">save</span>()</span><br><span class="line">&#125; <span class="built_in">catch</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Error saving data, \(error)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NSPredicate使用备忘"><a href="#NSPredicate使用备忘" class="headerlink" title="NSPredicate使用备忘"></a>NSPredicate使用备忘</h2><p>关于Predicate的一份备忘清单，可以随时查看：<a href="https://academy.realm.io/posts/nspredicate-cheatsheet/" target="_blank" rel="noopener">NSPredicate备忘清单</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在iOS App中，如果要存储的数据量比较大，就会使用Core Data。这里汇总了下使用Core Data的基本方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加Core Data&lt;/li&gt;
&lt;li&gt;配置Core Data中的Entity&lt;/li&gt;
&lt;li&gt;添加新数据&lt;/li&gt;
&lt;li&gt;读取与修改数据&lt;/li&gt;
&lt;li&gt;使用NSPredicate筛选数据&lt;/li&gt;
&lt;li&gt;删除数据&lt;/li&gt;
&lt;li&gt;保存数据&lt;/li&gt;
&lt;li&gt;一份NSPredicate使用备忘清单&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="编程" scheme="http://shenxiaobing.com/categories/programming/"/>
    
    
      <category term="iOS" scheme="http://shenxiaobing.com/tags/iOS/"/>
    
      <category term="Swift" scheme="http://shenxiaobing.com/tags/Swift/"/>
    
      <category term="Core Data" scheme="http://shenxiaobing.com/tags/Core-Data/"/>
    
  </entry>
  
</feed>
